# Skill: Notify Team via Slack
# Send notifications to Slack channels

name: notify_team
description: |
  Send notifications to Slack channels for key workflow events.

  Use for:
  - Deployment completed notifications
  - MR ready for review
  - Alert resolved
  - Release announcements
  - General team updates

  The skill will:
  1. Find the appropriate channel
  2. Format the message nicely
  3. Post to Slack
  4. Optionally mention specific users

version: "1.0"

inputs:
  - name: message
    type: string
    required: true
    description: "Message to send"

  - name: channel
    type: string
    required: false
    default: "team-automation-analytics"
    description: "Slack channel name (without #)"

  - name: type
    type: string
    required: false
    default: "info"
    description: "Message type: 'info', 'success', 'warning', 'error', 'deployment', 'release'"

  - name: mention
    type: string
    required: false
    description: "User to mention (Slack username or email)"

  - name: thread_ts
    type: string
    required: false
    description: "Thread timestamp to reply to (for threaded messages)"

  - name: context
    type: string
    required: false
    description: "Additional context (e.g., MR ID, namespace, issue key)"

steps:

  # ==================== PROACTIVE ISSUE DETECTION ====================

  - name: check_slack_known_issues
    description: "Check for known Slack issues before starting"
    tool: check_known_issues
    args:
      tool_name: "slack_post_message"
      error_text: ""
    output: slack_known_issues
    on_error: continue

  - name: init_autoheal
    description: "Initialize failure tracking"
    compute: |
      result = {"slack_failures": []}
    output: autoheal_state
    on_error: continue

  # ==================== FIND CHANNEL ====================

  - name: list_channels
    description: "List available Slack channels"
    tool: slack_list_channels
    args:
      limit: 100
    output: channels_raw
    on_error: auto_heal  # Slack API - may need auth

  - name: find_channel
    description: "Find the target channel"
    compute: |
      channels_text = str(channels_raw) if channels_raw else ""

      target = inputs.channel.lower().replace("#", "")
      channel_found = target in channels_text.lower()

      # Try to extract channel ID
      import re
      channel_id = None
      for line in channels_text.split("\n"):
          if target in line.lower():
              # Look for channel ID pattern
              id_match = re.search(r'(C[A-Z0-9]+)', line)
              if id_match:
                  channel_id = id_match.group(1)
                  break

      result = {
          "found": channel_found,
          "channel_id": channel_id,
          "channel_name": target,
      }
    output: channel_info

  # ==================== RESOLVE USER ====================

  - name: get_user_info
    description: "Get Slack user info for mentions"
    condition: "inputs.mention"
    tool: slack_get_user
    args:
      user: "{{ inputs.mention }}"
    output: user_info_raw
    on_error: continue

  - name: parse_user
    description: "Parse user info for mention"
    condition: "inputs.mention"
    compute: |
      user_text = str(user_info_raw) if 'user_info_raw' in dir() and user_info_raw else ""

      # Extract user ID for mention
      import re
      user_id = None
      id_match = re.search(r'(U[A-Z0-9]+)', user_text)
      if id_match:
          user_id = id_match.group(1)

      result = {
          "user_id": user_id,
          "mention_text": f"<@{user_id}>" if user_id else inputs.mention,
      }
    output: user_mention
    on_error: continue

  # ==================== FORMAT MESSAGE ====================

  - name: format_message
    description: "Format the Slack message with emoji and structure"
    compute: |
      msg_type = inputs.type.lower()

      # Choose emoji based on type
      emoji_map = {
          "info": "‚ÑπÔ∏è",
          "success": "‚úÖ",
          "warning": "‚ö†Ô∏è",
          "error": "‚ùå",
          "deployment": "üöÄ",
          "release": "üì¶",
      }
      emoji = emoji_map.get(msg_type, "üì¢")

      # Build message
      parts = [f"{emoji} {inputs.message}"]

      # Add mention
      if 'user_mention' in dir() and user_mention and user_mention.get('mention_text'):
          parts.append(f"\ncc: {user_mention['mention_text']}")

      # Add context
      if inputs.context:
          parts.append(f"\n```{inputs.context}```")

      formatted = "".join(parts)

      result = {
          "text": formatted,
          "emoji": emoji,
      }
    output: formatted_msg

  # ==================== SEND MESSAGE ====================

  - name: post_message
    description: "Post the message to Slack"
    tool: slack_post_message
    args:
      channel: "{{ channel_info.channel_name }}"
      message: "{{ formatted_msg.text }}"
      thread_ts: "{{ inputs.thread_ts or '' }}"
    output: post_result
    on_error: auto_heal  # Slack API - may need auth

  - name: parse_post_result
    description: "Parse post result"
    compute: |
      result_text = str(post_result) if post_result else ""

      success = "error" not in result_text.lower() and "failed" not in result_text.lower()

      # Extract message timestamp for threading
      import re
      ts = None
      ts_match = re.search(r'(\d+\.\d+)', result_text)
      if ts_match:
          ts = ts_match.group(1)

      result = {
          "success": success,
          "thread_ts": ts,
          "raw": result_text[:300] if result_text else "No response",
      }
    output: post_status

  # ==================== SEMANTIC SEARCH ====================

  - name: search_context_code
    description: "Search for code related to the notification context"
    condition: "inputs.context"
    tool: code_search
    args:
      query: "{{ inputs.context }}"
      project: "automation-analytics-backend"
      limit: 3
    output: context_code_raw
    on_error: continue

  - name: parse_context_code
    description: "Parse context code search results"
    condition: "context_code_raw"
    compute: |
      code_result = context_code_raw if context_code_raw else {}

      related_code = []
      if isinstance(code_result, dict) and code_result.get('found'):
          for item in code_result.get('content', []):
              related_code.append(item.get('path', '') + ":" + str(item.get('line_number', '')))

      result = {
          "has_code": len(related_code) > 0,
          "code_snippets": related_code[:5],
      }
    output: context_code_search
    on_error: continue

  # ==================== MEMORY ====================

  - name: log_notification
    description: "Log notification to session"
    condition: "post_status.success"
    tool: memory_session_log
    args:
      action: "Sent Slack notification"
      details: "Channel: #{{ channel_info.channel_name }}, Type: {{ inputs.type }}"
    on_error: continue

  - name: track_notifications
    description: "Track notifications for patterns"
    condition: "post_status.success"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "slack_notifications" not in patterns:
          patterns["slack_notifications"] = []

      # Record this notification
      notification_record = {
          "channel": channel_info.channel_name if channel_info else "unknown",
          "type": inputs.type,
          "has_mention": bool(inputs.mention),
          "has_context": bool(inputs.context),
          "threaded": bool(inputs.thread_ts),
          "timestamp": datetime.now().isoformat(),
      }

      patterns["slack_notifications"].append(notification_record)

      # Keep last 100 notifications
      patterns["slack_notifications"] = patterns["slack_notifications"][-100:]

      memory.write_memory("learned/patterns", patterns)
      result = "notification tracked"
    output: notification_tracking_result
    on_error: continue

outputs:
  - name: report
    value: |
      ## üí¨ Slack Notification

      {% if post_status.success %}
      ‚úÖ **Message Sent**

      **Channel:** #{{ channel_info.channel_name }}
      **Type:** {{ formatted_msg.emoji }} {{ inputs.type }}

      {% if post_status.thread_ts %}
      **Thread ID:** `{{ post_status.thread_ts }}`

      To reply in thread:
      ```python
      skill_run("notify_team", '{"message": "Follow-up", "channel": "{{ channel_info.channel_name }}", "thread_ts": "{{ post_status.thread_ts }}"}')
      ```
      {% endif %}

      {% else %}
      ‚ùå **Failed to Send**

      {{ post_status.raw }}

      {% if not channel_info.found %}
      ‚ö†Ô∏è Channel `#{{ inputs.channel }}` not found.

      Available channels:
      ```python
      slack_list_channels(limit=50)
      ```
      {% endif %}
      {% endif %}

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_notify_team_failures
    description: "Detect failure patterns from team notification"
    compute: |
      errors_detected = []

      # Check Slack failures
      post_text = str(post_result_raw) if 'post_result_raw' in dir() and post_result_raw else ""
      channel_text = str(channel_info) if 'channel_info' in dir() and channel_info else ""
      combined = post_text + channel_text

      if "not_in_channel" in combined.lower() or "channel_not_found" in combined.lower():
          errors_detected.append({
              "tool": "slack_post_message",
              "pattern": "channel_not_found",
              "cause": "Slack channel not found or bot not added",
              "fix": "Check channel name and invite bot to channel"
          })
      if "invalid_auth" in combined.lower():
          errors_detected.append({
              "tool": "slack_post_message",
              "pattern": "invalid_auth",
              "cause": "Slack token expired or invalid",
              "fix": "Check Slack token in config.json"
          })
      if "rate_limited" in combined.lower():
          errors_detected.append({
              "tool": "slack_post_message",
              "pattern": "rate_limited",
              "cause": "Slack API rate limit exceeded",
              "fix": "Wait a few seconds and retry"
          })

      result = errors_detected
    output: notify_team_errors_detected
    on_error: continue

  - name: learn_notify_team_channel_failure
    description: "Learn from channel not found failures"
    condition: "notify_team_errors_detected and any(e.get('pattern') == 'channel_not_found' for e in notify_team_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "slack_post_message"
      error_pattern: "channel_not_found"
      root_cause: "Slack channel not found or bot not added"
      fix_description: "Check channel name and invite bot to channel"
    output: notify_team_channel_fix_learned
    on_error: continue

  - name: context
    value:
      sent: "{{ post_status.success }}"
      channel: "{{ channel_info.channel_name }}"
      thread_ts: "{{ post_status.thread_ts }}"
