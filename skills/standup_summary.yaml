# Skill: Standup Summary
# Generate standup summary from recent activity

name: standup_summary
description: |
  Generate a standup summary from recent activity:
  - Git commits from yesterday/today
  - Jira issues worked on (In Progress, In Review)
  - MRs created/reviewed
  - Issues closed

  If 'repo' is not provided, can be resolved from 'repo_name' or 'issue_key' via config.

  Perfect for daily standups or status updates.
version: "1.1"

inputs:
  - name: repo
    type: string
    required: false
    default: ""
    description: "Repository path - if not provided, resolved from repo_name or issue_key"

  - name: repo_name
    type: string
    required: false
    description: "Repository name from config (e.g., 'automation-analytics-backend')"

  - name: issue_key
    type: string
    required: false
    description: "Jira issue key - used to resolve repo and Jira project"

  - name: days
    type: integer
    required: false
    default: 1
    description: "How many days back to look (default: 1 for yesterday)"

  - name: include_jira
    type: boolean
    required: false
    default: true
    description: "Include Jira issues"

  - name: include_gitlab
    type: boolean
    required: false
    default: true
    description: "Include GitLab MR activity"

  - name: author
    type: string
    required: false
    description: "Git author email (defaults to git config)"

  - name: slack_format
    type: boolean
    required: false
    default: false
    description: "Use Slack link format in summary"

# jira_url loaded from config.json in load_config step

steps:

  # ==================== PROACTIVE ISSUE DETECTION ====================

  - name: check_gitlab_known_issues
    description: "Check for known GitLab issues before starting"
    tool: check_known_issues
    args:
      tool_name: "gitlab_mr_list"
      error_text: ""
    output: gitlab_known_issues
    on_error: continue

  - name: check_jira_known_issues
    description: "Check for known Jira issues before starting"
    tool: check_known_issues
    args:
      tool_name: "jira_search"
      error_text: ""
    output: jira_known_issues
    on_error: continue

  - name: init_autoheal
    description: "Initialize failure tracking"
    compute: |
      result = {"failures": []}
    output: autoheal_state
    on_error: continue

  # ==================== RESOLVE REPOSITORY ====================

  - name: resolve_repo
    description: "Determine which repo and GitLab project to use"
    compute: |
      import os
      from scripts.common.config_loader import load_config

      repo_path = None
      gitlab_project = "automation-analytics/automation-analytics-backend"
      jira_project = "AAP"

      # Load config using shared loader
      config = load_config()
      repos = config.get("repositories", {})

      # Explicit repo path
      if inputs.repo and inputs.repo != "" and inputs.repo != ".":
          repo_path = inputs.repo
          for name, cfg in repos.items():
              if cfg.get("path") == repo_path:
                  gitlab_project = cfg.get("gitlab", gitlab_project)
                  jira_project = cfg.get("jira_project", jira_project)
                  break
      # Repo name from config
      elif inputs.repo_name and inputs.repo_name in repos:
          cfg = repos[inputs.repo_name]
          repo_path = cfg.get("path")
          gitlab_project = cfg.get("gitlab", gitlab_project)
          jira_project = cfg.get("jira_project", jira_project)
      # Resolve from issue key
      elif inputs.issue_key:
          project_prefix = inputs.issue_key.split("-")[0].upper()
          jira_project = project_prefix
          for name, cfg in repos.items():
              if cfg.get("jira_project") == project_prefix:
                  repo_path = cfg.get("path")
                  gitlab_project = cfg.get("gitlab", gitlab_project)
                  break
      # Fall back to cwd
      else:
          cwd = os.getcwd()
          if os.path.exists(os.path.join(cwd, ".git")):
              repo_path = cwd
              for name, cfg in repos.items():
                  if cfg.get("path") == cwd:
                      gitlab_project = cfg.get("gitlab", gitlab_project)
                      jira_project = cfg.get("jira_project", jira_project)
                      break

      if not repo_path:
          raise ValueError("Repository not specified. Provide 'repo', 'repo_name', or 'issue_key'.")

      result = {"path": repo_path, "gitlab_project": gitlab_project, "jira_project": jira_project}
    output: resolved_repo

  # ==================== GET AUTHOR ====================

  - name: get_author_email
    description: "Get git author email"
    condition: "not inputs.author"
    tool: git_config_get
    args:
      repo: "{{ resolved_repo.path }}"
      key: "user.email"
    output: author_email_raw
    on_error: continue

  - name: get_author_name
    description: "Get git author name"
    tool: git_config_get
    args:
      repo: "{{ resolved_repo.path }}"
      key: "user.name"
    output: author_name_raw
    on_error: continue

  - name: parse_author
    description: "Parse author info"
    compute: |
      if inputs.author:
        author = inputs.author
      else:
        author = str(author_email_raw).strip() if 'author_email_raw' in dir() and author_email_raw else ""
        # Remove error prefix if present
        if author.startswith("âŒ"):
          author = ""

      name = str(author_name_raw).strip() if 'author_name_raw' in dir() and author_name_raw else ""
      if name.startswith("âŒ"):
        name = ""

      result = {"email": author, "name": name}
    output: author_info

  # ==================== GET COMMITS (using MCP tool) ====================

  - name: get_commit_log
    description: "Get recent commits"
    tool: git_log
    args:
      repo: "{{ resolved_repo.path }}"
      limit: 30
      oneline: true
    output: commit_log_raw
    on_error: continue

  - name: parse_commits
    description: "Parse commit log for standup"
    compute: |
      # parsers is available from skill engine safe_globals
      # Use shared parser for git log
      commits = parsers.parse_git_log(commit_log_raw) if parsers and commit_log_raw else []

      # Extract issue keys from commit messages using shared parser
      issue_keys = set()
      for commit in commits:
        key = parsers.extract_jira_key(commit.get("message", "")) if parsers else None
        if key:
          issue_keys.add(key.upper())

      result = {
        "commits": commits[:20],
        "count": len(commits),
        "issue_keys": list(issue_keys),
      }
    output: commit_info

  # ==================== GET TODAY'S CALENDAR ====================

  - name: get_todays_meetings
    description: "Get today's calendar events"
    tool: google_calendar_list_events
    args:
      days: 1
    output: calendar_events_raw
    on_error: continue

  - name: parse_calendar_events
    description: "Parse calendar events"
    compute: |
      cal_text = str(calendar_events_raw) if 'calendar_events_raw' in dir() and calendar_events_raw else ""

      meetings = []
      if cal_text and "error" not in cal_text.lower() and "unauthorized" not in cal_text.lower():
          import re
          # Look for time patterns
          for line in cal_text.split("\n"):
              if any(kw in line for kw in [":", "AM", "PM", "standup", "meeting", "sync"]):
                  # Extract time and title
                  time_match = re.search(r'(\d{1,2}:\d{2}(?:\s*[AP]M)?)', line, re.I)
                  if time_match:
                      meetings.append({"time": time_match.group(1), "title": line.strip()[:60]})

      result = {
          "meetings": meetings[:10],
          "has_calendar": bool(meetings),
      }
    output: calendar_events
    on_error: continue

  # ==================== GET SLACK UPDATES ====================

  - name: get_slack_mentions
    description: "Get recent Slack mentions"
    tool: slack_channel_read
    args:
      channel: "team-automation-analytics"
      limit: 20
    output: slack_messages_raw
    on_error: continue

  - name: parse_slack_mentions
    description: "Parse Slack messages"
    compute: |
      slack_text = str(slack_messages_raw) if 'slack_messages_raw' in dir() and slack_messages_raw else ""

      mentions = []
      if slack_text and "error" not in slack_text.lower():
          for line in slack_text.split("\n")[:20]:
              if line.strip():
                  mentions.append(line.strip()[:100])

      result = {
          "recent_messages": mentions[:10],
          "has_slack": bool(mentions),
      }
    output: slack_activity
    on_error: continue

  # ==================== GET JIRA ACTIVITY ====================

  - name: get_my_jira_issues
    description: "Get all my assigned issues (quick query)"
    condition: "inputs.include_jira"
    tool: jira_my_issues
    args:
      max_results: 20
    output: my_issues_raw
    on_error: auto_heal  # Jira API - may need auth refresh

  - name: get_jira_in_progress
    description: "Get my issues in progress"
    condition: "inputs.include_jira"
    tool: jira_search
    args:
      jql: 'project = {{ resolved_repo.jira_project }} AND assignee = currentUser() AND status in ("In Progress", "In Review") ORDER BY updated DESC'
    output: jira_in_progress
    on_error: auto_heal  # Jira API - may need auth refresh

  - name: get_jira_done_recently
    description: "Get recently closed issues"
    condition: "inputs.include_jira"
    tool: jira_search
    args:
      jql: 'project = {{ resolved_repo.jira_project }} AND assignee = currentUser() AND status = Done AND updated >= -{{ inputs.days }}d ORDER BY updated DESC'
    output: jira_done
    on_error: auto_heal  # Jira API - may need auth refresh

  - name: parse_jira_issues
    description: "Parse Jira issues using shared parser"
    condition: "inputs.include_jira"
    compute: |
      from scripts.common.parsers import parse_jira_issues

      # Use shared parser for Jira issues
      in_progress = parse_jira_issues(str(jira_in_progress) if jira_in_progress else "")
      done = parse_jira_issues(str(jira_done) if jira_done else "")

      result = {
          "in_progress": in_progress[:10],
          "done": done[:10],
      }
    output: jira_issues
    on_error: continue

  # ==================== GET GITLAB ACTIVITY ====================

  - name: get_my_mrs
    description: "Get MRs I created"
    condition: "inputs.include_gitlab"
    tool: gitlab_mr_list
    args:
      project: "{{ resolved_repo.gitlab_project }}"
      state: all
      author: "{{ author_info.name }}"
    output: my_mrs_raw
    on_error: auto_heal  # GitLab API - may need auth refresh

  - name: get_mr_reviews
    description: "Get MRs I reviewed"
    condition: "inputs.include_gitlab"
    tool: gitlab_mr_list
    args:
      project: "{{ resolved_repo.gitlab_project }}"
      state: all
      reviewer: "{{ author_info.name }}"
    output: reviewed_mrs_raw
    on_error: auto_heal  # GitLab API - may need auth refresh

  - name: parse_gitlab_activity
    description: "Parse GitLab MR activity using shared parser"
    condition: "inputs.include_gitlab"
    compute: |
      from scripts.common.parsers import parse_mr_list

      # Use shared parser for MR lists
      my_mrs = parse_mr_list(str(my_mrs_raw) if my_mrs_raw else "")
      reviewed = parse_mr_list(str(reviewed_mrs_raw) if reviewed_mrs_raw else "")

      result = {
          "my_mrs": my_mrs[:5],
          "reviewed": reviewed[:5],
      }
    output: gitlab_activity
    on_error: continue

  # ==================== BUILD SUMMARY ====================

  - name: build_summary
    description: "Build standup summary"
    compute: |
      from datetime import datetime
      from scripts.common.parsers import linkify_jira_keys, linkify_mr_ids

      is_slack = inputs.get('slack_format', True)

      lines = []
      lines.append(f"## ðŸ“‹ Standup Summary")
      lines.append(f"**Date:** {datetime.now().strftime('%Y-%m-%d')}")
      lines.append(f"**Author:** {author_info.get('name', 'Unknown')}")
      lines.append("")

      # Yesterday / Done
      lines.append("### âœ… What I Did")
      if commit_info.get("commits"):
          lines.append(f"**Commits:** {commit_info['count']}")
          for c in commit_info["commits"][:5]:
              msg = linkify_jira_keys(c['message'], slack_format=is_slack)
              lines.append(f"- `{c['sha']}` {msg[:70]}")
          if commit_info["count"] > 5:
              lines.append(f"- ... and {commit_info['count'] - 5} more")
      else:
          lines.append("- No commits in the last day")

      if jira_issues and jira_issues.get("done"):
          lines.append("")
          lines.append("**Issues Closed:**")
          for issue in jira_issues["done"][:5]:
              key_str = linkify_jira_keys(issue['key'], slack_format=is_slack)
              summary = linkify_jira_keys(issue['summary'], slack_format=is_slack)
              lines.append(f"- {key_str} {summary}")

      if gitlab_activity and gitlab_activity.get("reviewed"):
          lines.append("")
          lines.append("**PRs Reviewed:**")
          for mr in gitlab_activity["reviewed"][:3]:
              mr_id = linkify_mr_ids(f"!{mr['iid']}", slack_format=is_slack)
              title = linkify_jira_keys(mr['title'], slack_format=is_slack)
              lines.append(f"- {mr_id}: {title}")

      lines.append("")

      # Today / In Progress
      lines.append("### ðŸ”„ What I'm Working On")
      if jira_issues and jira_issues.get("in_progress"):
          for issue in jira_issues["in_progress"][:5]:
              key_str = linkify_jira_keys(issue['key'], slack_format=is_slack)
              summary = linkify_jira_keys(issue['summary'], slack_format=is_slack)
              lines.append(f"- {key_str} {summary}")
      elif commit_info.get("issue_keys"):
          for key in commit_info["issue_keys"][:5]:
              lines.append(f"- {linkify_jira_keys(key, slack_format=is_slack)}")
      else:
          lines.append("- (Add your current work here)")

      if gitlab_activity and gitlab_activity.get("my_mrs"):
          lines.append("")
          lines.append("**Open MRs:**")
          for mr in gitlab_activity["my_mrs"][:3]:
              mr_id = linkify_mr_ids(f"!{mr['iid']}", slack_format=is_slack)
              title = linkify_jira_keys(mr['title'], slack_format=is_slack)
              lines.append(f"- {mr_id}: {title}")

      lines.append("")

      # Today's Meetings
      if calendar_events and calendar_events.get('has_calendar'):
          lines.append("### ðŸ“… Today's Meetings")
          for mtg in calendar_events.get('meetings', [])[:5]:
              lines.append(f"- {mtg['time']}: {mtg['title']}")
          lines.append("")

      # Slack Updates
      if slack_activity and slack_activity.get('has_slack'):
          lines.append("### ðŸ’¬ Team Channel (Recent)")
          for msg in slack_activity.get('recent_messages', [])[:3]:
              lines.append(f"- {msg[:80]}")
          lines.append("")

      # Blockers
      lines.append("### ðŸš§ Blockers")
      lines.append("- None")
      lines.append("")

      # AI Assistant Status
      if knowledge_status and knowledge_status.get('has_knowledge'):
          lines.append("### ðŸ¤– AI Assistant Status")
          lines.append(f"- **Knowledge Confidence:** {knowledge_status.get('confidence', 0)}%")
          if vector_status and vector_status.get('has_index'):
              lines.append(f"- **Code Index:** {vector_status.get('files_indexed', 0)} files, {vector_status.get('chunks', 0)} chunks")
              if vector_status.get('search_count', 0) > 0:
                  lines.append(f"- **Searches Today:** {vector_status.get('search_count', 0)}")
          lines.append("")

      lines.append("---")
      lines.append("*Generated by standup_summary skill*")

      result = "\n".join(lines)
    output: standup

  # ==================== MEMORY INTEGRATION ====================

  # ==================== KNOWLEDGE & VECTOR STATS ====================

  - name: get_knowledge_confidence
    description: "Get project knowledge confidence score"
    tool: knowledge_query
    args:
      project: "automation-analytics-backend"
      persona: "developer"
      section: "metadata"
    output: knowledge_meta_raw
    on_error: continue

  - name: parse_knowledge_meta
    description: "Parse knowledge metadata"
    compute: |
      meta_result = knowledge_meta_raw if 'knowledge_meta_raw' in dir() and knowledge_meta_raw else {}

      confidence = 0
      last_updated = None
      if isinstance(meta_result, dict) and meta_result.get('found'):
          content = meta_result.get('content', {})
          if isinstance(content, dict):
              confidence = content.get('confidence', 0)
              last_updated = content.get('last_updated', None)

      result = {
          'confidence': confidence,
          'last_updated': last_updated,
          'has_knowledge': confidence > 0,
      }
    output: knowledge_status
    on_error: continue

  - name: get_vector_stats
    description: "Get vector index statistics"
    tool: code_stats
    args:
      project: "automation-analytics-backend"
    output: vector_stats_raw
    on_error: continue

  - name: parse_vector_stats
    description: "Parse vector stats"
    compute: |
      stats_result = vector_stats_raw if 'vector_stats_raw' in dir() and vector_stats_raw else {}

      if isinstance(stats_result, dict):
          result = {
              'files_indexed': stats_result.get('files_indexed', 0),
              'chunks': stats_result.get('chunks_created', 0),
              'search_count': stats_result.get('search_count', 0),
              'has_index': stats_result.get('files_indexed', 0) > 0,
          }
      else:
          result = {
              'files_indexed': 0,
              'chunks': 0,
              'search_count': 0,
              'has_index': False,
          }
    output: vector_status
    on_error: continue

  - name: load_memory
    description: "Load current work state from memory"
    tool: memory_read
    args:
      key: "state/current_work"
    output: memory_state_raw
    on_error: continue

  - name: enhance_with_memory
    description: "Enhance standup with memory context"
    compute: |
      import yaml

      lines = [standup]

      # Parse memory
      memory_state = {}
      if memory_state_raw and isinstance(memory_state_raw, str):
          try:
              memory_state = yaml.safe_load(memory_state_raw) or {}
          except:
              pass

      # Add follow-ups from memory
      follow_ups = memory_state.get("follow_ups", [])
      if follow_ups:
          lines.append("")
          lines.append("### ðŸ“‹ Follow-ups (from memory)")
          for fu in follow_ups[:5]:
              priority = fu.get("priority", "normal")
              emoji = "ðŸ”´" if priority == "high" else "ðŸŸ¡" if priority == "medium" else "âšª"
              lines.append(f"- {emoji} {fu.get('task', 'N/A')}")

      result = "\n".join(lines)
    output: enhanced_standup

  - name: log_standup
    description: "Log standup generation to session"
    tool: memory_session_log
    args:
      action: "Generated standup summary"
      details: "{{ commit_info.count }} commits, {{ jira_issues.in_progress|length if jira_issues and jira_issues.in_progress else 0 }} issues in progress"
    on_error: continue

  - name: learn_standup_pattern
    description: "Learn from this standup for activity tracking"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "standup_patterns" not in patterns:
          patterns["standup_patterns"] = []

      # Record this standup
      standup_record = {
          "date": datetime.now().strftime("%Y-%m-%d"),
          "day_of_week": datetime.now().strftime("%A"),
          "commits": commit_info.get("count", 0) if commit_info else 0,
          "issue_keys": commit_info.get("issue_keys", []) if commit_info else [],
          "in_progress": len(jira_issues.get("in_progress", [])) if jira_issues else 0,
          "done": len(jira_issues.get("done", [])) if jira_issues else 0,
          "my_mrs": len(gitlab_activity.get("my_mrs", [])) if gitlab_activity else 0,
          "reviewed": len(gitlab_activity.get("reviewed", [])) if gitlab_activity else 0,
          "meetings": len(calendar_events.get("meetings", [])) if calendar_events else 0,
          "timestamp": datetime.now().isoformat(),
      }

      patterns["standup_patterns"].append(standup_record)

      # Keep last 60 standup records
      patterns["standup_patterns"] = patterns["standup_patterns"][-60:]

      memory.write_memory("learned/patterns", patterns)
      result = "standup pattern learned"
    output: pattern_learn_result
    on_error: continue

  - name: track_active_issues
    description: "Track which issues are actively being worked on"
    condition: "commit_info and commit_info.get('issue_keys')"
    compute: |
      from datetime import datetime

      # Update current work with detected issue activity
      current_work = memory.read_memory("state/current_work") or {}
      if "active_issues" not in current_work:
          current_work["active_issues"] = []

      # Add newly detected issues from commits
      for key in (commit_info.get("issue_keys", []) or []):
          existing = [i for i in current_work["active_issues"] if i.get("key") == key]
          if not existing:
              current_work["active_issues"].append({
                  "key": key,
                  "added": datetime.now().isoformat(),
                  "source": "commit",
              })

      # Keep last 20 active issues
      current_work["active_issues"] = current_work["active_issues"][-20:]

      memory.write_memory("state/current_work", current_work)
      result = "active issues tracked"
    output: issue_tracking_result
    on_error: continue

  - name: save_shared_context
    description: "Save standup context for other skills"
    compute: |
      from datetime import datetime

      # Share context that other skills can use
      shared = memory.read_memory("state/shared_context") or {}

      shared["last_standup"] = {
          "timestamp": datetime.now().isoformat(),
          "commits": commit_info.get("count", 0) if commit_info else 0,
          "issue_keys": commit_info.get("issue_keys", []) if commit_info else [],
          "in_progress": len(jira_issues.get("in_progress", [])) if jira_issues else 0,
          "done": len(jira_issues.get("done", [])) if jira_issues else 0,
          "open_mrs": len(gitlab_activity.get("my_mrs", [])) if gitlab_activity else 0,
      }

      memory.write_memory("state/shared_context", shared)
      result = "shared context saved"
    output: shared_context_result
    on_error: continue

  # ==================== SEMANTIC SEARCH ====================

  - name: search_recent_code
    description: "Search for code related to recent commits"
    condition: "commit_info and commit_info.get('issue_keys')"
    tool: code_search
    args:
      query: "recent commits {{ commit_info.issue_keys[0] if commit_info.issue_keys else '' }} standup"
      project: "automation-analytics-backend"
      limit: 3
    output: recent_code_raw
    on_error: continue

  - name: parse_recent_code
    description: "Parse recent code search results"
    condition: "recent_code_raw"
    compute: |
      code_result = recent_code_raw if recent_code_raw else {}

      related_code = []
      if isinstance(code_result, dict) and code_result.get('found'):
          for item in code_result.get('content', []):
              related_code.append(item.get('path', '') + ":" + str(item.get('line_number', '')))

      result = {
          "has_code": len(related_code) > 0,
          "code_snippets": related_code[:5],
      }
    output: recent_code_search
    on_error: continue

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_standup_failures
    description: "Detect failure patterns from standup data gathering"
    compute: |
      errors_detected = []

      # Check git failures
      commit_log_text = str(commit_log_raw) if 'commit_log_raw' in dir() and commit_log_raw else ""
      if "permission denied" in commit_log_text.lower():
          errors_detected.append({
              "tool": "git_log",
              "pattern": "permission denied",
              "cause": "Git repository access denied",
              "fix": "Check repository permissions and SSH keys"
          })

      # Check GitLab failures
      gitlab_text = str(gitlab_mrs_raw) if 'gitlab_mrs_raw' in dir() and gitlab_mrs_raw else ""
      if "no such host" in gitlab_text.lower():
          errors_detected.append({
              "tool": "gitlab_mr_list",
              "pattern": "no such host",
              "cause": "VPN not connected - internal GitLab not reachable",
              "fix": "Run vpn_connect() to connect to Red Hat VPN"
          })
      if "unauthorized" in gitlab_text.lower():
          errors_detected.append({
              "tool": "gitlab_mr_list",
              "pattern": "unauthorized",
              "cause": "GitLab authentication failed",
              "fix": "Check GitLab token in config.json"
          })

      # Check Jira failures
      jira_text = str(jira_issues_raw) if 'jira_issues_raw' in dir() and jira_issues_raw else ""
      if "command timed out" in jira_text.lower():
          errors_detected.append({
              "tool": "jira_search",
              "pattern": "command timed out",
              "cause": "Jira API timeout - network or server issue",
              "fix": "Check VPN connection and retry"
          })
      if "unauthorized" in jira_text.lower():
          errors_detected.append({
              "tool": "jira_search",
              "pattern": "unauthorized",
              "cause": "Jira authentication failed",
              "fix": "Check Jira credentials in config.json"
          })

      result = errors_detected
    output: standup_errors_detected
    on_error: continue

  - name: learn_standup_vpn_failure
    description: "Learn from GitLab VPN failures"
    condition: "standup_errors_detected and any(e.get('pattern') == 'no such host' for e in standup_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "gitlab_mr_list"
      error_pattern: "no such host"
      root_cause: "VPN not connected - internal GitLab not reachable"
      fix_description: "Run vpn_connect() to connect to Red Hat VPN"
    output: standup_vpn_fix_learned
    on_error: continue

  - name: learn_standup_jira_failure
    description: "Learn from Jira timeout failures"
    condition: "standup_errors_detected and any(e.get('pattern') == 'command timed out' for e in standup_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "jira_search"
      error_pattern: "command timed out"
      root_cause: "Jira API timeout - network or server issue"
      fix_description: "Check VPN connection and retry"
    output: standup_jira_fix_learned
    on_error: continue

  - name: log_standup_session
    description: "Log standup generation to session"
    tool: memory_session_log
    args:
      action: "Generated standup summary"
      details: "{{ commit_info.count if commit_info else 0 }} commits, {{ jira_issues.in_progress | length if jira_issues and jira_issues.in_progress else 0 }} in progress"
    on_error: continue

# ==================== OUTPUT ====================

outputs:
  - name: summary
    value: |
      {{ enhanced_standup }}

  - name: context
    value:
      author: "{{ author_info.name }}"
      repo: "{{ resolved_repo.path }}"
      gitlab_project: "{{ resolved_repo.gitlab_project }}"
      jira_project: "{{ resolved_repo.jira_project }}"
      commits: "{{ commit_info.count }}"
      issue_keys: "{{ commit_info.issue_keys }}"
