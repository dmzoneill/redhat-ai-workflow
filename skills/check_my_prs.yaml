# Skill: Check My PRs for Feedback
# Review feedback on your own MRs and help respond

name: check_my_prs
description: |
  Check your open MRs for feedback from reviewers.

  Shows:
  - MRs with unaddressed feedback (need your response)
  - MRs awaiting review (no feedback yet)
  - MRs ready to merge (approved)

  Helps you respond to reviewer comments.

  Resolves project from repo_name or issue_key if not explicitly provided.

version: "1.2"

inputs:
  - name: project
    type: string
    required: false
    default: ""
    description: "GitLab project path (resolved from repo_name if not provided)"

  - name: repo_name
    type: string
    required: false
    description: "Repository name from config (e.g., 'automation-analytics-backend')"

  - name: show_approved
    type: boolean
    required: false
    default: true
    description: "Include approved MRs in output"

  - name: auto_merge
    type: boolean
    required: false
    default: false
    description: "Automatically merge approved MRs (asks first if false)"

  - name: auto_rebase
    type: boolean
    required: false
    default: false
    description: "Automatically rebase MRs with merge conflicts"

  - name: slack_format
    type: boolean
    required: false
    default: false
    description: "Use Slack link format in summary"

# No hardcoded constants - resolved dynamically

steps:

  - name: init_autoheal
    description: "Initialize failure tracking"
    compute: |
      result = {"gitlab_failures": []}
    output: autoheal_state
    on_error: continue

  # ==================== KNOWLEDGE INTEGRATION ====================

  - name: get_pr_best_practices
    description: "Get PR best practices from knowledge"
    tool: knowledge_query
    args:
      project: "automation-analytics-backend"
      persona: "developer"
      section: "patterns.coding"
    output: pr_practices_raw
    on_error: continue

  - name: parse_pr_practices
    description: "Parse PR best practices"
    compute: |
      practices_result = pr_practices_raw if 'pr_practices_raw' in dir() and pr_practices_raw else {}

      pr_practices = []
      if isinstance(practices_result, dict) and practices_result.get('found'):
          content = practices_result.get('content', [])
          if isinstance(content, list):
              # Filter for PR-related practices
              for p in content:
                  p_str = str(p).lower()
                  if any(kw in p_str for kw in ['pr', 'mr', 'review', 'feedback', 'merge', 'rebase']):
                      pr_practices.append(p)

      result = {
          'practices': pr_practices[:5],
          'has_practices': len(pr_practices) > 0,
      }
    output: pr_best_practices
    on_error: continue

  - name: check_gitlab_known_issues
    description: "Check for known GitLab MR issues"
    compute: |
      # Check known issues for GitLab operations
      gitlab_issues = memory.check_known_issues("gitlab", "") or {}
      mr_issues = memory.check_known_issues("merge_request", "") or {}

      all_issues = []
      for issues in [gitlab_issues, mr_issues]:
          if issues and issues.get("matches"):
              all_issues.extend(issues.get("matches", [])[:2])

      result = {
          "has_known_issues": len(all_issues) > 0,
          "issues": all_issues[:5],
      }
    output: gitlab_known_issues
    on_error: continue

  # ==================== RESOLVE PROJECT ====================

  - name: resolve_project
    description: "Determine which GitLab project to check"
    compute: |
      import os
      from scripts.common.config_loader import load_config

      gitlab_project = None

      # Load config using shared loader
      config = load_config()
      repos = config.get("repositories", {})

      # Explicit project
      if inputs.project:
          gitlab_project = inputs.project
      # Repo name from config
      elif inputs.repo_name and inputs.repo_name in repos:
          gitlab_project = repos[inputs.repo_name].get("gitlab")
      # Fall back to cwd
      else:
          cwd = os.getcwd()
          for name, cfg in repos.items():
              if cfg.get("path") == cwd:
                  gitlab_project = cfg.get("gitlab")
                  break

      if not gitlab_project:
          gitlab_project = "automation-analytics/automation-analytics-backend"

      result = {"gitlab_project": gitlab_project}
    output: resolved
  # ==================== GET CURRENT USER ====================

  - name: get_username
    description: "Get current system username"
    compute: |
      import getpass
      import os

      username = os.getenv('USER') or os.getenv('USERNAME') or getpass.getuser()
      result = username
    output: my_username

  # ==================== GET MY MRs ====================

  - name: list_my_mrs
    description: "Fetch my open MRs from GitLab"
    tool: gitlab_mr_list
    args:
      project: "{{ resolved.gitlab_project }}"
      state: opened
      author: "{{ my_username }}"
    output: my_mrs_raw
    on_error: auto_heal  # GitLab API - may need auth refresh

  - name: parse_my_mrs
    description: "Parse MR list using shared parser"
    compute: |
      from scripts.common.parsers import parse_mr_list

      # Use shared parser - already handles deduplication and multi-format parsing
      result = parse_mr_list(my_mrs_raw or "")
    output: my_mrs

  # ==================== CHECK EACH MR FOR FEEDBACK ====================

  - name: check_first_mr
    description: "Get details of first MR"
    condition: "len(my_mrs) > 0"
    tool: gitlab_mr_view
    args:
      project: "{{ resolved.gitlab_project }}"
      mr_id: "{{ my_mrs[0]['iid'] }}"
    output: first_mr_details
    on_error: auto_heal  # GitLab API - may need auth refresh

  - name: analyze_first_mr
    description: "Analyze feedback status of first MR using shared parser"
    condition: "len(my_mrs) > 0 and first_mr_details"
    compute: |
      from scripts.common.parsers import analyze_mr_status

      mr = my_mrs[0]

      # Use shared MR status analyzer
      analysis = analyze_mr_status(first_mr_details or "", my_username)

      # Combine MR info with analysis
      result = {
        'iid': mr.get('iid'),
        'title': mr.get('title', ''),
        **analysis  # Spread all analysis fields (status, action, is_approved, etc.)
      }
    output: first_mr_status

  # ==================== GET COMMENTS IF NEEDS RESPONSE ====================

  - name: get_feedback_details
    description: "Get detailed comments if MR needs response"
    condition: "first_mr_status and first_mr_status.get('status') == 'needs_response'"
    tool: gitlab_mr_view
    args:
      project: "{{ resolved.gitlab_project }}"
      mr_id: "{{ first_mr_status.get('iid') }}"
    output: feedback_details
    on_error: auto_heal  # GitLab API - may need auth refresh

  # ==================== AUTO-REBASE IF NEEDED ====================

  - name: auto_rebase_mr
    description: "Automatically rebase MR with conflicts"
    condition: "inputs.auto_rebase and first_mr_status and first_mr_status.get('needs_rebase')"
    tool: skill_run
    args:
      skill_name: rebase_pr
      inputs: '{"mr_id": {{ first_mr_status.get("iid", 0) }}, "force_push": false}'
    output: rebase_result
    on_error: continue

  # ==================== BUILD SUMMARY ====================

  - name: build_summary
    description: "Compile status of all my MRs"
    compute: |
      from scripts.common.parsers import linkify_mr_ids, linkify_jira_keys
      is_slack = inputs.get('slack_format', True)

      lines = ["## ðŸ“‹ Your Open MRs", ""]
      lines.append(f"**User:** {my_username}")
      lines.append(f"**Project:** {resolved['gitlab_project']}")
      lines.append(f"**Open MRs:** {len(my_mrs)}")
      lines.append("")

      if not my_mrs:
        lines.append("*No open MRs found.*")
        result = '\n'.join(lines)
      else:
        # Categorize
        needs_response = []
        awaiting = []
        approved = []
        failed = []
        needs_rebase = []

        if first_mr_status:
          status = first_mr_status.get('status', 'unknown')
          if status == 'needs_response':
            needs_response.append(first_mr_status)
          elif status == 'approved':
            approved.append(first_mr_status)
          elif status == 'pipeline_failed':
            failed.append(first_mr_status)
          elif status == 'needs_rebase':
            needs_rebase.append(first_mr_status)
          else:
            awaiting.append(first_mr_status)

        # Add remaining MRs as "awaiting" (not analyzed in detail)
        for mr in my_mrs[1:]:
          awaiting.append({'iid': mr.get('iid'), 'title': mr.get('title', ''), 'status': 'not_checked'})

        # Show MRs needing response first (most important)
        if needs_response:
          lines.append("### ðŸ”´ Needs Your Response")
          lines.append("*Reviewers have left feedback - please address*")
          lines.append("")
          for mr in needs_response:
            mr_id = linkify_mr_ids(f"!{mr['iid']}", slack_format=is_slack)
            title = linkify_jira_keys(mr.get('title', ''), slack_format=is_slack)
            lines.append(f"**{mr_id}**: {title}")
            if mr.get('reviewers'):
              lines.append(f"  - Feedback from: {', '.join(mr['reviewers'])}")
            if mr.get('unresolved'):
              lines.append(f"  - âš ï¸ Has unresolved discussions")
            lines.append("")

        if needs_rebase:
          lines.append("### ðŸ”„ Needs Rebase")
          for mr in needs_rebase:
            mr_id = linkify_mr_ids(f"!{mr['iid']}", slack_format=is_slack)
            title = linkify_jira_keys(mr.get('title', ''), slack_format=is_slack)
            if rebase_result:
              lines.append(f"- {mr_id}: {title} ðŸ”„ **Rebased!**")
              lines.append(f"  - *See rebase results below*")
            else:
              lines.append(f"- {mr_id}: {title} âš ï¸ Has merge conflicts")
              lines.append(f"  - Run: `skill_run(\"rebase_pr\", '{{\"mr_id\": {mr[\"iid\"]}}}')`")
          lines.append("")

        if failed:
          lines.append("### ðŸ”´ Pipeline Failed")
          for mr in failed:
            mr_id = linkify_mr_ids(f"!{mr['iid']}", slack_format=is_slack)
            title = linkify_jira_keys(mr.get('title', ''), slack_format=is_slack)
            lines.append(f"- {mr_id}: {title} - Fix CI before review")
          lines.append("")

        if awaiting:
          lines.append("### ðŸŸ¡ Awaiting Review")
          for mr in awaiting:
            mr_id = linkify_mr_ids(f"!{mr['iid']}", slack_format=is_slack)
            title = linkify_jira_keys(mr.get('title', ''), slack_format=is_slack)
            lines.append(f"- {mr_id}: {title}")
          lines.append("")

        if approved and inputs.show_approved:
          lines.append("### ðŸŸ¢ Approved - Ready to Merge")
          for mr in approved:
            mr_id = linkify_mr_ids(f"!{mr['iid']}", slack_format=is_slack)
            title = linkify_jira_keys(mr.get('title', ''), slack_format=is_slack)
            lines.append(f"- {mr_id}: {title} âœ…")
          lines.append("")

        result = '\n'.join(lines)
    output: summary

  # ==================== MERGE APPROVED MRs ====================

  - name: update_summary_with_merge
    description: "Update summary if MR was merged"
    condition: "merge_result"
    compute: |
      merged_mr = first_mr_status.get('iid', '?')
      result = summary + f"\n\n### âœ… Merged\n- !{merged_mr} has been merged!"
    output: final_summary

  # ==================== MEMORY INTEGRATION ====================

  - name: update_mr_status_in_memory
    description: "Update open MRs in memory with current status"
    condition: "mr_statuses"
    compute: |
      # Use shared memory helpers (available via skill engine)
      data = memory.read_memory("state/current_work")
      open_mrs = data.get("open_mrs", []) if isinstance(data.get("open_mrs"), list) else []
      now = memory.get_timestamp()

      # Update status for each checked MR
      for mr_status in (mr_statuses or []):
          mr_id = str(mr_status.get("iid", ""))
          status = mr_status.get("status", "unknown")
          pipeline = mr_status.get("pipeline_status", "unknown")

          # Find and update existing MR
          for mr in open_mrs:
              if str(mr.get("id", "")) == mr_id:
                  mr["pipeline_status"] = pipeline
                  mr["needs_review"] = status != "approved"
                  mr["last_checked"] = now
                  break

      data["open_mrs"] = open_mrs
      memory.write_memory("state/current_work", data)
      result = f"updated {len(mr_statuses or [])} MRs"
    output: memory_update_result
    on_error: continue

  - name: log_check_prs
    description: "Log PR check to session"
    tool: memory_session_log
    args:
      action: "Checked {{ mr_statuses|length if mr_statuses else 0 }} of my PRs"
      details: "{{ 'Merged one' if merge_result else 'No merges' }}"
    on_error: continue

  # ==================== SEMANTIC SEARCH ====================

  - name: search_pr_code
    description: "Search for code related to my PRs"
    condition: "first_mr_status and first_mr_status.get('iid')"
    tool: code_search
    args:
      query: "GitLab MR !{{ first_mr_status.get('iid') }} {{ first_mr_status.get('title', '')[:50] }}"
      project: "automation-analytics-backend"
      limit: 3
    output: pr_code_raw
    on_error: continue

  - name: parse_pr_code
    description: "Parse PR code search results"
    condition: "pr_code_raw"
    compute: |
      code_result = pr_code_raw if pr_code_raw else {}

      related_code = []
      if isinstance(code_result, dict) and code_result.get('found'):
          for item in code_result.get('content', []):
              related_code.append(item.get('path', '') + ":" + str(item.get('line_number', '')))

      result = {
          "has_code": len(related_code) > 0,
          "code_snippets": related_code[:5],
      }
    output: pr_code_search
    on_error: continue

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_my_prs_failures
    description: "Detect failure patterns from PR checks"
    compute: |
      errors_detected = []

      # Check GitLab API failures
      mrs_text = str(my_mrs_raw) if 'my_mrs_raw' in dir() and my_mrs_raw else ""
      details_text = str(first_mr_details) if 'first_mr_details' in dir() and first_mr_details else ""
      combined = mrs_text + details_text

      if "no such host" in combined.lower() or "dial tcp" in combined.lower():
          errors_detected.append({
              "tool": "gitlab_mr_list",
              "pattern": "no such host",
              "cause": "VPN not connected - internal GitLab not reachable",
              "fix": "Run vpn_connect() to connect to Red Hat VPN"
          })
      if "unauthorized" in combined.lower() or "401" in combined:
          errors_detected.append({
              "tool": "gitlab_mr_list",
              "pattern": "unauthorized",
              "cause": "GitLab authentication failed or token expired",
              "fix": "Check GitLab token in config.json"
          })
      if "merge conflict" in combined.lower():
          errors_detected.append({
              "tool": "gitlab_mr_merge",
              "pattern": "merge conflict",
              "cause": "MR has merge conflicts with target branch",
              "fix": "Run skill_run('rebase_pr', '{\"mr_id\": <id>}') to rebase"
          })

      result = errors_detected
    output: my_prs_errors_detected
    on_error: continue

  - name: learn_my_prs_vpn_failure
    description: "Learn from GitLab VPN failures"
    condition: "my_prs_errors_detected and any(e.get('pattern') == 'no such host' for e in my_prs_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "gitlab_mr_list"
      error_pattern: "no such host"
      root_cause: "VPN not connected - internal GitLab not reachable"
      fix_description: "Run vpn_connect() to connect to Red Hat VPN"
    output: my_prs_vpn_fix_learned
    on_error: continue

  - name: learn_merge_conflict_failure
    description: "Learn from merge conflict failures"
    condition: "my_prs_errors_detected and any(e.get('pattern') == 'merge conflict' for e in my_prs_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "gitlab_mr_merge"
      error_pattern: "merge conflict"
      root_cause: "MR has merge conflicts with target branch"
      fix_description: "Run skill_run('rebase_pr', '{\"mr_id\": <id>}') to rebase"
    output: merge_conflict_fix_learned
    on_error: continue

# ==================== OUTPUT ====================

outputs:
  - name: summary
    value: |
      {{ final_summary if final_summary else summary }}

      ---

      ## Quick Actions

      {% if merge_result %}
      âœ… **MR !{{ first_mr_status.get('iid') }} has been merged!**

      {% elif first_mr_status and first_mr_status.get('status') == 'needs_response' %}
      **To respond to feedback on !{{ first_mr_status.get('iid') }}:**

      1. View the comments:
         ```
         gitlab_mr_view(project="{{ resolved.gitlab_project }}", mr_id={{ first_mr_status.get('iid') }})
         ```

      2. After making changes, push and comment:
         ```
         gitlab_mr_comment(project="{{ resolved.gitlab_project }}", mr_id={{ first_mr_status.get('iid') }}, comment="Addressed feedback: ...")
         ```
      {% elif first_mr_status and first_mr_status.get('status') == 'approved' %}
      ðŸŽ‰ **!{{ first_mr_status.get('iid') }} is approved!**

      Would you like me to merge it? Just say:
      - **"Yes, merge it"** or **"merge !{{ first_mr_status.get('iid') }}"**

      Or run:
      ```
      skill_run("check_my_prs", '{"auto_merge": true}')
      ```
      {% elif first_mr_status and first_mr_status.get('status') == 'needs_rebase' %}
      ðŸ”„ **!{{ first_mr_status.get('iid') }} has merge conflicts!**

      {% if rebase_result %}
      âœ… Rebase completed! Check the results above.
      {% else %}
      Would you like me to rebase it? Just say:
      - **"Yes, rebase it"** or **"rebase !{{ first_mr_status.get('iid') }}"**

      Or run:
      ```
      skill_run("rebase_pr", '{"mr_id": {{ first_mr_status.get('iid') }}}')
      ```

      Or auto-rebase when checking PRs:
      ```
      skill_run("check_my_prs", '{"auto_rebase": true}')
      ```
      {% endif %}
      {% else %}
      - View MR details: `gitlab_mr_view(project="...", mr_id=<id>)`
      - Check all MRs again: `skill_run("check_my_prs", '{}')`
      {% endif %}

      {% if pr_best_practices and pr_best_practices.has_practices %}
      ---

      ### ðŸ“‹ PR Best Practices

      {% for practice in pr_best_practices.practices[:3] %}
      - {{ practice }}
      {% endfor %}
      {% endif %}

      {% if gitlab_known_issues and gitlab_known_issues.has_known_issues %}
      ---

      ### ðŸ’¡ Known Issues

      {% for issue in gitlab_known_issues.issues[:3] %}
      - {{ issue.pattern if issue.pattern else issue }}
      {% endfor %}
      {% endif %}

  - name: context
    value:
      username: "{{ my_username }}"
      total_mrs: "{{ len(my_mrs) }}"
      first_mr_status: "{{ first_mr_status.get('status') if first_mr_status else 'none' }}"
