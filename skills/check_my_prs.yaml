# Skill: Check My PRs for Feedback
# Review feedback on your own MRs and help respond

name: check_my_prs
description: |
  Check your open MRs for feedback from reviewers.
  
  Shows:
  - MRs with unaddressed feedback (need your response)
  - MRs awaiting review (no feedback yet)
  - MRs ready to merge (approved)
  
  Helps you respond to reviewer comments.
  
  Resolves project from repo_name or issue_key if not explicitly provided.

version: "1.1"

inputs:
  - name: project
    type: string
    required: false
    default: ""
    description: "GitLab project path (resolved from repo_name if not provided)"
  
  - name: repo_name
    type: string
    required: false
    description: "Repository name from config (e.g., 'automation-analytics-backend')"
  
  - name: show_approved
    type: boolean
    required: false
    default: true
    description: "Include approved MRs in output"
  
  - name: auto_merge
    type: boolean
    required: false
    default: false
    description: "Automatically merge approved MRs (asks first if false)"
  
  - name: auto_rebase
    type: boolean
    required: false
    default: false
    description: "Automatically rebase MRs with merge conflicts"

# No hardcoded constants - resolved dynamically

steps:
  # ==================== RESOLVE PROJECT ====================
  
  - name: resolve_project
    description: "Determine which GitLab project to check"
    compute: |
      import os
      from scripts.common.config_loader import load_config
      
      gitlab_project = None
      
      # Load config using shared loader
      config = load_config()
      repos = config.get("repositories", {})

      # Explicit project
      if inputs.project:
          gitlab_project = inputs.project
      # Repo name from config
      elif inputs.repo_name and inputs.repo_name in repos:
          gitlab_project = repos[inputs.repo_name].get("gitlab")
      # Fall back to cwd
      else:
          cwd = os.getcwd()
          for name, cfg in repos.items():
              if cfg.get("path") == cwd:
                  gitlab_project = cfg.get("gitlab")
                  break

      if not gitlab_project:
          gitlab_project = "automation-analytics/automation-analytics-backend"

      result = {"gitlab_project": gitlab_project}
    output: resolved
  # ==================== GET CURRENT USER ====================
  
  - name: get_username
    description: "Get current system username"
    compute: |
      import getpass
      import os
      
      username = os.getenv('USER') or os.getenv('USERNAME') or getpass.getuser()
      result = username
    output: my_username

  # ==================== GET MY MRs ====================
  
  - name: list_my_mrs
    description: "Fetch my open MRs from GitLab"
    tool: gitlab_mr_list
    args:
      project: "{{ resolved.gitlab_project }}"
      state: opened
      author: "{{ my_username }}"
    output: my_mrs_raw

  - name: parse_my_mrs
    description: "Parse MR list"
    compute: |
      import re
      
      mrs = []
      lines = my_mrs_raw.split('\n') if my_mrs_raw else []
      
      current_mr = {}
      for line in lines:
        iid_match = re.search(r'!(\d+)|IID[:\s]+(\d+)', line, re.IGNORECASE)
        if iid_match:
          if current_mr.get('iid'):
            mrs.append(current_mr)
          current_mr = {'iid': int(iid_match.group(1) or iid_match.group(2))}
        
        title_match = re.search(r'Title[:\s]+(.+)', line, re.IGNORECASE)
        if title_match and current_mr.get('iid'):
          current_mr['title'] = title_match.group(1).strip()[:60]
      
      if current_mr.get('iid'):
        mrs.append(current_mr)
      
      # Deduplicate
      seen = set()
      unique = []
      for mr in mrs:
        if mr['iid'] not in seen:
          seen.add(mr['iid'])
          unique.append(mr)
      
      result = unique
    output: my_mrs

  # ==================== CHECK EACH MR FOR FEEDBACK ====================
  
  - name: check_first_mr
    description: "Get details of first MR"
    condition: "len(my_mrs) > 0"
    tool: gitlab_mr_view
    args:
      project: "{{ resolved.gitlab_project }}"
      mr_id: "{{ my_mrs[0]['iid'] }}"
    output: first_mr_details
    on_error: continue

  - name: analyze_first_mr
    description: "Analyze feedback status of first MR"
    condition: "len(my_mrs) > 0 and first_mr_details"
    compute: |
      import re
      
      mr = my_mrs[0]
      details = first_mr_details or ""
      
      # Check approval status
      is_approved = bool(re.search(r'approved|LGTM|:white_check_mark:|âœ…', details, re.IGNORECASE))
      
      # Check for reviewer comments (not from me)
      my_user = my_username.lower()
      
      # Look for comments from others
      comment_patterns = [
        r'(\w+)\s+commented',
        r'Review by\s+(\w+)',
        r'@(\w+)\s+:',
        r'Feedback from\s+(\w+)',
      ]
      
      reviewers = set()
      for pattern in comment_patterns:
        matches = re.findall(pattern, details, re.IGNORECASE)
        for match in matches:
          if match.lower() != my_user:
            reviewers.add(match)
      
      has_feedback = len(reviewers) > 0
      
      # Check for unresolved discussions
      unresolved = bool(re.search(r'unresolved|open discussion|needs work|request.*change', details, re.IGNORECASE))
      
      # Check pipeline status
      pipeline_failed = bool(re.search(r'pipeline.*failed|CI.*failed|build.*failed', details, re.IGNORECASE))
      
      # Check for merge conflicts
      has_conflicts = bool(re.search(
        r'cannot be merged|has conflicts|merge conflicts?|needs rebase|unable to merge',
        details, re.IGNORECASE
      ))
      
      # Check for merge commits (should rebase)
      has_merge_commits = bool(re.search(r'merge branch|merge.*into|merge commit', details, re.IGNORECASE))
      needs_rebase = has_conflicts or has_merge_commits
      
      # Determine status
      if has_conflicts:
        status = "needs_rebase"
        action = "Has merge conflicts - needs rebase"
      elif is_approved and not unresolved:
        status = "approved"
        action = "Ready to merge!"
      elif unresolved or (has_feedback and not is_approved):
        status = "needs_response"
        action = "Reviewer feedback needs your response"
      elif pipeline_failed:
        status = "pipeline_failed"
        action = "Fix pipeline before review"
      elif has_merge_commits:
        status = "needs_rebase"
        action = "Has merge commits - consider rebasing"
      else:
        status = "awaiting_review"
        action = "Waiting for reviewers"
      
      result = {
        'iid': mr.get('iid'),
        'title': mr.get('title', ''),
        'status': status,
        'action': action,
        'is_approved': is_approved,
        'has_feedback': has_feedback,
        'reviewers': list(reviewers),
        'unresolved': unresolved,
        'pipeline_failed': pipeline_failed,
        'has_conflicts': has_conflicts,
        'needs_rebase': needs_rebase
      }
    output: first_mr_status

  # ==================== GET COMMENTS IF NEEDS RESPONSE ====================
  
  - name: get_feedback_details
    description: "Get detailed comments if MR needs response"
    condition: "first_mr_status and first_mr_status.get('status') == 'needs_response'"
    tool: gitlab_mr_view
    args:
      project: "{{ resolved.gitlab_project }}"
      mr_id: "{{ first_mr_status.get('iid') }}"
    output: feedback_details
    on_error: continue

  # ==================== AUTO-REBASE IF NEEDED ====================
  
  - name: auto_rebase_mr
    description: "Automatically rebase MR with conflicts"
    condition: "inputs.auto_rebase and first_mr_status and first_mr_status.get('needs_rebase')"
    tool: skill_run
    args:
      skill_name: rebase_pr
      inputs: '{"mr_id": {{ first_mr_status.get("iid", 0) }}, "force_push": false}'
    output: rebase_result
    on_error: continue

  # ==================== BUILD SUMMARY ====================
  
  - name: build_summary
    description: "Compile status of all my MRs"
    compute: |
      lines = ["## ğŸ“‹ Your Open MRs", ""]
      lines.append(f"**User:** {my_username}")
      lines.append(f"**Project:** {resolved['gitlab_project']}")
      lines.append(f"**Open MRs:** {len(my_mrs)}")
      lines.append("")
      
      if not my_mrs:
        lines.append("*No open MRs found.*")
        result = '\n'.join(lines)
      else:
        # Categorize
        needs_response = []
        awaiting = []
        approved = []
        failed = []
        needs_rebase = []
        
        if first_mr_status:
          status = first_mr_status.get('status', 'unknown')
          if status == 'needs_response':
            needs_response.append(first_mr_status)
          elif status == 'approved':
            approved.append(first_mr_status)
          elif status == 'pipeline_failed':
            failed.append(first_mr_status)
          elif status == 'needs_rebase':
            needs_rebase.append(first_mr_status)
          else:
            awaiting.append(first_mr_status)
        
        # Add remaining MRs as "awaiting" (not analyzed in detail)
        for mr in my_mrs[1:]:
          awaiting.append({'iid': mr.get('iid'), 'title': mr.get('title', ''), 'status': 'not_checked'})
        
        # Show MRs needing response first (most important)
        if needs_response:
          lines.append("### ğŸ”´ Needs Your Response")
          lines.append("*Reviewers have left feedback - please address*")
          lines.append("")
          for mr in needs_response:
            lines.append(f"**!{mr['iid']}**: {mr.get('title', '')}")
            if mr.get('reviewers'):
              lines.append(f"  - Feedback from: {', '.join(mr['reviewers'])}")
            if mr.get('unresolved'):
              lines.append(f"  - âš ï¸ Has unresolved discussions")
            lines.append("")
        
        if needs_rebase:
          lines.append("### ğŸ”„ Needs Rebase")
          for mr in needs_rebase:
            if rebase_result:
              lines.append(f"- !{mr['iid']}: {mr.get('title', '')} ğŸ”„ **Rebased!**")
              lines.append(f"  - *See rebase results below*")
            else:
              lines.append(f"- !{mr['iid']}: {mr.get('title', '')} âš ï¸ Has merge conflicts")
              lines.append(f"  - Run: `skill_run(\"rebase_pr\", '{{\"mr_id\": {mr[\"iid\"]}}}')`")
          lines.append("")
        
        if failed:
          lines.append("### ğŸ”´ Pipeline Failed")
          for mr in failed:
            lines.append(f"- !{mr['iid']}: {mr.get('title', '')} - Fix CI before review")
          lines.append("")
        
        if awaiting:
          lines.append("### ğŸŸ¡ Awaiting Review")
          for mr in awaiting:
            lines.append(f"- !{mr['iid']}: {mr.get('title', '')}")
          lines.append("")
        
        if approved and inputs.show_approved:
          lines.append("### ğŸŸ¢ Approved - Ready to Merge")
          for mr in approved:
            lines.append(f"- !{mr['iid']}: {mr.get('title', '')} âœ…")
          lines.append("")
        
        result = '\n'.join(lines)
    output: summary

  # ==================== MERGE APPROVED MRs ====================
  
  - name: merge_approved
    description: "Merge the first approved MR if auto_merge is enabled"
    condition: "inputs.auto_merge and first_mr_status and first_mr_status.get('status') == 'approved'"
    tool: gitlab_mr_merge
    args:
      project: "{{ resolved.gitlab_project }}"
      mr_id: "{{ first_mr_status.get('iid') }}"
    output: merge_result
    on_error: continue

  - name: update_summary_with_merge
    description: "Update summary if MR was merged"
    condition: "merge_result"
    compute: |
      merged_mr = first_mr_status.get('iid', '?')
      result = summary + f"\n\n### âœ… Merged\n- !{merged_mr} has been merged!"
    output: final_summary

# ==================== OUTPUT ====================

outputs:
  - name: summary
    value: |
      {{ final_summary if final_summary else summary }}
      
      ---
      
      ## Quick Actions
      
      {% if merge_result %}
      âœ… **MR !{{ first_mr_status.get('iid') }} has been merged!**
      
      {% elif first_mr_status and first_mr_status.get('status') == 'needs_response' %}
      **To respond to feedback on !{{ first_mr_status.get('iid') }}:**
      
      1. View the comments:
         ```
         gitlab_mr_view(project="{{ resolved.gitlab_project }}", mr_id={{ first_mr_status.get('iid') }})
         ```
      
      2. After making changes, push and comment:
         ```
         gitlab_mr_comment(project="{{ resolved.gitlab_project }}", mr_id={{ first_mr_status.get('iid') }}, comment="Addressed feedback: ...")
         ```
      {% elif first_mr_status and first_mr_status.get('status') == 'approved' %}
      ğŸ‰ **!{{ first_mr_status.get('iid') }} is approved!**
      
      Would you like me to merge it? Just say:
      - **"Yes, merge it"** or **"merge !{{ first_mr_status.get('iid') }}"**
      
      Or run:
      ```
      skill_run("check_my_prs", '{"auto_merge": true}')
      ```
      {% elif first_mr_status and first_mr_status.get('status') == 'needs_rebase' %}
      ğŸ”„ **!{{ first_mr_status.get('iid') }} has merge conflicts!**
      
      {% if rebase_result %}
      âœ… Rebase completed! Check the results above.
      {% else %}
      Would you like me to rebase it? Just say:
      - **"Yes, rebase it"** or **"rebase !{{ first_mr_status.get('iid') }}"**
      
      Or run:
      ```
      skill_run("rebase_pr", '{"mr_id": {{ first_mr_status.get('iid') }}}')
      ```
      
      Or auto-rebase when checking PRs:
      ```
      skill_run("check_my_prs", '{"auto_rebase": true}')
      ```
      {% endif %}
      {% else %}
      - View MR details: `gitlab_mr_view(project="...", mr_id=<id>)`
      - Check all MRs again: `skill_run("check_my_prs", '{}')`
      {% endif %}
  
  - name: context
    value:
      username: "{{ my_username }}"
      total_mrs: "{{ len(my_mrs) }}"
      first_mr_status: "{{ first_mr_status.get('status') if first_mr_status else 'none' }}"

