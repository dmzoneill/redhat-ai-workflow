# Skill: Check My PRs for Feedback
# Review feedback on your own MRs and help respond

name: check_my_prs
description: |
  Check your open MRs for feedback from reviewers.

  Shows:
  - MRs with unaddressed feedback (need your response)
  - MRs awaiting review (no feedback yet)
  - MRs ready to merge (approved)

  Helps you respond to reviewer comments.

  Resolves project from repo_name or issue_key if not explicitly provided.

version: "1.2"

inputs:
  - name: project
    type: string
    required: false
    default: ""
    description: "GitLab project path (resolved from repo_name if not provided)"

  - name: repo_name
    type: string
    required: false
    description: "Repository name from config (e.g., 'automation-analytics-backend')"

  - name: show_approved
    type: boolean
    required: false
    default: true
    description: "Include approved MRs in output"

  - name: auto_merge
    type: boolean
    required: false
    default: false
    description: "Automatically merge approved MRs (asks first if false)"

  - name: auto_rebase
    type: boolean
    required: false
    default: false
    description: "Automatically rebase MRs with merge conflicts"

# No hardcoded constants - resolved dynamically

steps:
  # ==================== AUTO-HEAL SETUP ====================

  - name: init_autoheal
    description: "Initialize failure tracking"
    compute: |
      result = {"gitlab_failures": []}
    output: autoheal_state
    on_error: continue

  # ==================== RESOLVE PROJECT ====================

  - name: resolve_project
    description: "Determine which GitLab project to check"
    compute: |
      import os
      from scripts.common.config_loader import load_config

      gitlab_project = None

      # Load config using shared loader
      config = load_config()
      repos = config.get("repositories", {})

      # Explicit project
      if inputs.project:
          gitlab_project = inputs.project
      # Repo name from config
      elif inputs.repo_name and inputs.repo_name in repos:
          gitlab_project = repos[inputs.repo_name].get("gitlab")
      # Fall back to cwd
      else:
          cwd = os.getcwd()
          for name, cfg in repos.items():
              if cfg.get("path") == cwd:
                  gitlab_project = cfg.get("gitlab")
                  break

      if not gitlab_project:
          gitlab_project = "automation-analytics/automation-analytics-backend"

      result = {"gitlab_project": gitlab_project}
    output: resolved
  # ==================== GET CURRENT USER ====================

  - name: get_username
    description: "Get current system username"
    compute: |
      import getpass
      import os

      username = os.getenv('USER') or os.getenv('USERNAME') or getpass.getuser()
      result = username
    output: my_username

  # ==================== GET MY MRs ====================

  - name: list_my_mrs
    description: "Fetch my open MRs from GitLab"
    tool: gitlab_mr_list
    args:
      project: "{{ resolved.gitlab_project }}"
      state: opened
      author: "{{ my_username }}"
    output: my_mrs_raw
    on_error: continue

  # ==================== AUTO-HEAL: list_my_mrs ====================

  - name: detect_failure_mrs
    description: "Detect if GitLab call failed"
    compute: |
      from scripts.common.auto_heal import detect_failure

      result_text = str(my_mrs_raw) if 'my_mrs_raw' in dir() and my_mrs_raw else ""
      failure = detect_failure(result_text, "gitlab_mr_list")
      result = failure
    output: failure_mrs
    on_error: continue

  - name: quick_fix_vpn_mrs
    description: "Auto-fix VPN issues for GitLab"
    condition: "failure_mrs and failure_mrs.get('error_type') == 'network'"
    tool: vpn_connect
    args: {}
    output: vpn_fix_mrs
    on_error: continue

  - name: retry_list_mrs
    description: "Retry GitLab call after VPN fix"
    condition: "vpn_fix_mrs and failure_mrs"
    tool: gitlab_mr_list
    args:
      project: "{{ resolved.gitlab_project }}"
      state: opened
      author: "{{ my_username }}"
    output: my_mrs_raw_retry
    on_error: continue

  - name: merge_mrs_result
    description: "Use retry result if available"
    condition: "my_mrs_raw_retry"
    compute: |
      result = my_mrs_raw_retry
    output: my_mrs_raw

  - name: parse_my_mrs
    description: "Parse MR list using shared parser"
    compute: |
      from scripts.common.parsers import parse_mr_list

      # Use shared parser - already handles deduplication and multi-format parsing
      result = parse_mr_list(my_mrs_raw or "")
    output: my_mrs

  # ==================== CHECK EACH MR FOR FEEDBACK ====================

  - name: check_first_mr
    description: "Get details of first MR"
    condition: "len(my_mrs) > 0"
    tool: gitlab_mr_view
    args:
      project: "{{ resolved.gitlab_project }}"
      mr_id: "{{ my_mrs[0]['iid'] }}"
    output: first_mr_details
    on_error: continue

  - name: analyze_first_mr
    description: "Analyze feedback status of first MR using shared parser"
    condition: "len(my_mrs) > 0 and first_mr_details"
    compute: |
      from scripts.common.parsers import analyze_mr_status

      mr = my_mrs[0]

      # Use shared MR status analyzer
      analysis = analyze_mr_status(first_mr_details or "", my_username)

      # Combine MR info with analysis
      result = {
        'iid': mr.get('iid'),
        'title': mr.get('title', ''),
        **analysis  # Spread all analysis fields (status, action, is_approved, etc.)
      }
    output: first_mr_status

  # ==================== GET COMMENTS IF NEEDS RESPONSE ====================

  - name: get_feedback_details
    description: "Get detailed comments if MR needs response"
    condition: "first_mr_status and first_mr_status.get('status') == 'needs_response'"
    tool: gitlab_mr_view
    args:
      project: "{{ resolved.gitlab_project }}"
      mr_id: "{{ first_mr_status.get('iid') }}"
    output: feedback_details
    on_error: continue

  # ==================== AUTO-REBASE IF NEEDED ====================

  - name: auto_rebase_mr
    description: "Automatically rebase MR with conflicts"
    condition: "inputs.auto_rebase and first_mr_status and first_mr_status.get('needs_rebase')"
    tool: skill_run
    args:
      skill_name: rebase_pr
      inputs: '{"mr_id": {{ first_mr_status.get("iid", 0) }}, "force_push": false}'
    output: rebase_result
    on_error: continue

  # ==================== BUILD SUMMARY ====================

  - name: build_summary
    description: "Compile status of all my MRs"
    compute: |
      lines = ["## ğŸ“‹ Your Open MRs", ""]
      lines.append(f"**User:** {my_username}")
      lines.append(f"**Project:** {resolved['gitlab_project']}")
      lines.append(f"**Open MRs:** {len(my_mrs)}")
      lines.append("")

      if not my_mrs:
        lines.append("*No open MRs found.*")
        result = '\n'.join(lines)
      else:
        # Categorize
        needs_response = []
        awaiting = []
        approved = []
        failed = []
        needs_rebase = []

        if first_mr_status:
          status = first_mr_status.get('status', 'unknown')
          if status == 'needs_response':
            needs_response.append(first_mr_status)
          elif status == 'approved':
            approved.append(first_mr_status)
          elif status == 'pipeline_failed':
            failed.append(first_mr_status)
          elif status == 'needs_rebase':
            needs_rebase.append(first_mr_status)
          else:
            awaiting.append(first_mr_status)

        # Add remaining MRs as "awaiting" (not analyzed in detail)
        for mr in my_mrs[1:]:
          awaiting.append({'iid': mr.get('iid'), 'title': mr.get('title', ''), 'status': 'not_checked'})

        # Show MRs needing response first (most important)
        if needs_response:
          lines.append("### ğŸ”´ Needs Your Response")
          lines.append("*Reviewers have left feedback - please address*")
          lines.append("")
          for mr in needs_response:
            lines.append(f"**!{mr['iid']}**: {mr.get('title', '')}")
            if mr.get('reviewers'):
              lines.append(f"  - Feedback from: {', '.join(mr['reviewers'])}")
            if mr.get('unresolved'):
              lines.append(f"  - âš ï¸ Has unresolved discussions")
            lines.append("")

        if needs_rebase:
          lines.append("### ğŸ”„ Needs Rebase")
          for mr in needs_rebase:
            if rebase_result:
              lines.append(f"- !{mr['iid']}: {mr.get('title', '')} ğŸ”„ **Rebased!**")
              lines.append(f"  - *See rebase results below*")
            else:
              lines.append(f"- !{mr['iid']}: {mr.get('title', '')} âš ï¸ Has merge conflicts")
              lines.append(f"  - Run: `skill_run(\"rebase_pr\", '{{\"mr_id\": {mr[\"iid\"]}}}')`")
          lines.append("")

        if failed:
          lines.append("### ğŸ”´ Pipeline Failed")
          for mr in failed:
            lines.append(f"- !{mr['iid']}: {mr.get('title', '')} - Fix CI before review")
          lines.append("")

        if awaiting:
          lines.append("### ğŸŸ¡ Awaiting Review")
          for mr in awaiting:
            lines.append(f"- !{mr['iid']}: {mr.get('title', '')}")
          lines.append("")

        if approved and inputs.show_approved:
          lines.append("### ğŸŸ¢ Approved - Ready to Merge")
          for mr in approved:
            lines.append(f"- !{mr['iid']}: {mr.get('title', '')} âœ…")
          lines.append("")

        result = '\n'.join(lines)
    output: summary

  # ==================== MERGE APPROVED MRs ====================

  - name: merge_approved
    description: "Merge the first approved MR if auto_merge is enabled"
    condition: "inputs.auto_merge and first_mr_status and first_mr_status.get('status') == 'approved'"
    tool: gitlab_mr_merge
    args:
      project: "{{ resolved.gitlab_project }}"
      mr_id: "{{ first_mr_status.get('iid') }}"
    output: merge_result
    on_error: continue

  - name: update_summary_with_merge
    description: "Update summary if MR was merged"
    condition: "merge_result"
    compute: |
      merged_mr = first_mr_status.get('iid', '?')
      result = summary + f"\n\n### âœ… Merged\n- !{merged_mr} has been merged!"
    output: final_summary

  # ==================== MEMORY INTEGRATION ====================

  - name: update_mr_status_in_memory
    description: "Update open MRs in memory with current status"
    condition: "mr_statuses"
    compute: |
      # Use shared memory helpers (available via skill engine)
      data = memory.read_memory("state/current_work")
      open_mrs = data.get("open_mrs", []) if isinstance(data.get("open_mrs"), list) else []
      now = memory.get_timestamp()

      # Update status for each checked MR
      for mr_status in (mr_statuses or []):
          mr_id = str(mr_status.get("iid", ""))
          status = mr_status.get("status", "unknown")
          pipeline = mr_status.get("pipeline_status", "unknown")

          # Find and update existing MR
          for mr in open_mrs:
              if str(mr.get("id", "")) == mr_id:
                  mr["pipeline_status"] = pipeline
                  mr["needs_review"] = status != "approved"
                  mr["last_checked"] = now
                  break

      data["open_mrs"] = open_mrs
      memory.write_memory("state/current_work", data)
      result = f"updated {len(mr_statuses or [])} MRs"
    output: memory_update_result
    on_error: continue

  - name: log_check_prs
    description: "Log PR check to session"
    tool: memory_session_log
    args:
      action: "Checked {{ mr_statuses|length if mr_statuses else 0 }} of my PRs"
      details: "{{ 'Merged one' if merge_result else 'No merges' }}"
    on_error: continue

# ==================== OUTPUT ====================

outputs:
  - name: summary
    value: |
      {{ final_summary if final_summary else summary }}

      ---

      ## Quick Actions

      {% if merge_result %}
      âœ… **MR !{{ first_mr_status.get('iid') }} has been merged!**

      {% elif first_mr_status and first_mr_status.get('status') == 'needs_response' %}
      **To respond to feedback on !{{ first_mr_status.get('iid') }}:**

      1. View the comments:
         ```
         gitlab_mr_view(project="{{ resolved.gitlab_project }}", mr_id={{ first_mr_status.get('iid') }})
         ```

      2. After making changes, push and comment:
         ```
         gitlab_mr_comment(project="{{ resolved.gitlab_project }}", mr_id={{ first_mr_status.get('iid') }}, comment="Addressed feedback: ...")
         ```
      {% elif first_mr_status and first_mr_status.get('status') == 'approved' %}
      ğŸ‰ **!{{ first_mr_status.get('iid') }} is approved!**

      Would you like me to merge it? Just say:
      - **"Yes, merge it"** or **"merge !{{ first_mr_status.get('iid') }}"**

      Or run:
      ```
      skill_run("check_my_prs", '{"auto_merge": true}')
      ```
      {% elif first_mr_status and first_mr_status.get('status') == 'needs_rebase' %}
      ğŸ”„ **!{{ first_mr_status.get('iid') }} has merge conflicts!**

      {% if rebase_result %}
      âœ… Rebase completed! Check the results above.
      {% else %}
      Would you like me to rebase it? Just say:
      - **"Yes, rebase it"** or **"rebase !{{ first_mr_status.get('iid') }}"**

      Or run:
      ```
      skill_run("rebase_pr", '{"mr_id": {{ first_mr_status.get('iid') }}}')
      ```

      Or auto-rebase when checking PRs:
      ```
      skill_run("check_my_prs", '{"auto_rebase": true}')
      ```
      {% endif %}
      {% else %}
      - View MR details: `gitlab_mr_view(project="...", mr_id=<id>)`
      - Check all MRs again: `skill_run("check_my_prs", '{}')`
      {% endif %}

  - name: context
    value:
      username: "{{ my_username }}"
      total_mrs: "{{ len(my_mrs) }}"
      first_mr_status: "{{ first_mr_status.get('status') if first_mr_status else 'none' }}"
