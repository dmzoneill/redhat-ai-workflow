# Skill: Deploy to Ephemeral
# Full ephemeral deployment from scratch

name: deploy_to_ephemeral
description: |
  Deploy application to an ephemeral environment.

  This skill handles the full deployment workflow:
  1. Check available pools and reserve namespace
  2. Verify app dependencies
  3. Deploy with specified image/parameters
  4. Monitor rollout and verify health

  Uses: bonfire_pool_list, bonfire_namespace_reserve, bonfire_apps_dependencies,
        bonfire_deploy, kubectl_rollout_status, kubectl_get_pods
version: "1.0"

inputs:
  - name: app
    type: string
    required: false
    default: "tower-analytics"
    description: "Application name to deploy"

  - name: image_tag
    type: string
    required: false
    default: ""
    description: "Image tag (git SHA) to deploy. If empty, uses latest."

  - name: duration
    type: string
    required: false
    default: "2h"
    description: "Namespace reservation duration"

  - name: pool
    type: string
    required: false
    default: "default"
    description: "Namespace pool to use"

  - name: component
    type: string
    required: false
    default: "main"
    description: "Component to deploy (main or billing)"

steps:
  # ==================== KNOWLEDGE INTEGRATION ====================

  - name: check_deployment_known_issues
    description: "Check for known deployment issues"
    compute: |
      # Check known issues for bonfire and deployment
      bonfire_issues = memory.check_known_issues("bonfire", "") or {}
      deploy_issues = memory.check_known_issues("deploy", "") or {}

      all_issues = []
      for issues in [bonfire_issues, deploy_issues]:
          if issues and issues.get("matches"):
              all_issues.extend(issues.get("matches", [])[:2])

      result = {
          "has_known_issues": len(all_issues) > 0,
          "issues": all_issues[:5],
      }
    output: deployment_known_issues
    on_error: continue

  - name: get_deployment_gotchas
    description: "Get deployment gotchas from knowledge"
    tool: knowledge_query
    args:
      project: "automation-analytics-backend"
      persona: "devops"
      section: "gotchas"
    output: deployment_gotchas_raw
    on_error: continue

  - name: parse_deployment_gotchas
    description: "Parse deployment-related gotchas"
    compute: |
      gotchas_result = deployment_gotchas_raw if 'deployment_gotchas_raw' in dir() and deployment_gotchas_raw else {}

      deploy_gotchas = []
      if isinstance(gotchas_result, dict) and gotchas_result.get('found'):
          content = gotchas_result.get('content', [])
          if isinstance(content, list):
              # Filter for deployment-related gotchas
              for g in content:
                  g_str = str(g).lower()
                  if any(kw in g_str for kw in ['deploy', 'ephemeral', 'bonfire', 'namespace', 'pod', 'k8s']):
                      deploy_gotchas.append(g)

      result = {
          'gotchas': deploy_gotchas[:5],
          'has_gotchas': len(deploy_gotchas) > 0,
      }
    output: deployment_gotchas
    on_error: continue

  # ==================== CHECK POOLS ====================

  - name: list_pools
    description: "List available namespace pools"
    tool: bonfire_pool_list
    args: {}
    output: pools_raw
    on_error: continue

  - name: parse_pools
    description: "Parse pool availability"
    compute: |
      pools_text = str(pools_raw) if 'pools_raw' in dir() and pools_raw else ""

      available = []
      for line in pools_text.split("\n"):
        if "available" in line.lower() or "ready" in line.lower():
          available.append(line.strip())

      result = {
        "pools": available[:5],
        "has_capacity": len(available) > 0,
        "raw": pools_text[:500] if pools_text else "",
      }
    output: pool_status

  # ==================== RESERVE NAMESPACE ====================

  - name: reserve_namespace
    description: "Reserve ephemeral namespace"
    tool: bonfire_namespace_reserve
    args:
      duration: "{{ inputs.duration }}"
      pool: "{{ inputs.pool }}"
    output: reserve_result
    on_error: auto_heal  # Ephemeral cluster - may need kube_login

  - name: parse_reservation
    description: "Extract namespace name from reservation"
    compute: |
      # Use retry result if available
      reserve_text = str(reserve_result_retry) if 'reserve_result_retry' in dir() and reserve_result_retry else ""
      if not reserve_text or "‚ùå" in reserve_text:
        reserve_text = str(reserve_result) if 'reserve_result' in dir() and reserve_result else ""

      import re
      namespace = None
      # Look for namespace pattern: ephemeral-xxxxx
      ns_match = re.search(r'(ephemeral-[a-z0-9]+)', reserve_text)
      if ns_match:
        namespace = ns_match.group(1)

      success = namespace is not None

      result = {
        "namespace": namespace,
        "success": success,
        "raw": reserve_text[:300] if reserve_text else "",
      }
    output: namespace_info

  # ==================== CHECK DEPENDENCIES ====================

  - name: check_dependencies
    description: "Check app dependencies"
    condition: "namespace_info.success"
    tool: bonfire_apps_dependencies
    args:
      app: "{{ inputs.app }}"
    output: deps_raw
    on_error: continue

  - name: parse_dependencies
    description: "Parse dependency list"
    compute: |
      deps_text = str(deps_raw) if 'deps_raw' in dir() and deps_raw else ""

      dependencies = []
      for line in deps_text.split("\n"):
        line = line.strip()
        if line and not line.startswith("#"):
          dependencies.append(line)

      result = {
        "dependencies": dependencies[:10],
        "count": len(dependencies),
      }
    output: deps_info

  # ==================== DEPLOY ====================

  - name: determine_image_param
    description: "Build image parameter if tag provided"
    compute: |
      if inputs.image_tag:
        # Use the provided image tag
        if inputs.component == "billing":
          clowdapp = "tower-analytics-billing-clowdapp"
        else:
          clowdapp = "tower-analytics-clowdapp"

        param = f"--set-parameter {clowdapp}/IMAGE_TAG={inputs.image_tag}"
      else:
        param = ""

      result = {"param": param, "has_custom_image": bool(inputs.image_tag)}
    output: image_config

  - name: deploy_app
    description: "Deploy application to namespace"
    condition: "namespace_info.success"
    tool: bonfire_deploy
    args:
      namespace: "{{ namespace_info.namespace }}"
      app: "{{ inputs.app }}"
      extra_args: "{{ image_config.param }}"
    output: deploy_result
    on_error: auto_heal  # Ephemeral cluster - may need kube_login

  - name: parse_deploy
    description: "Parse deployment result"
    compute: |
      deploy_text = str(deploy_result) if 'deploy_result' in dir() and deploy_result else ""

      success = "error" not in deploy_text.lower() and "failed" not in deploy_text.lower()
      if "deployed" in deploy_text.lower() or "success" in deploy_text.lower():
        success = True

      result = {
        "success": success,
        "output": deploy_text[:800] if deploy_text else "",
      }
    output: deploy_status

  # ==================== VERIFY DEPLOYMENT ====================

  - name: check_rollout
    description: "Check deployment rollout status"
    condition: "deploy_status.success and namespace_info.namespace"
    tool: kubectl_rollout_status
    args:
      deployment: "{{ inputs.app }}"
      namespace: "{{ namespace_info.namespace }}"
      environment: "ephemeral"
    output: rollout_raw
    on_error: continue

  - name: check_pods
    description: "Get pod status"
    condition: "namespace_info.namespace"
    tool: kubectl_get_pods
    args:
      namespace: "{{ namespace_info.namespace }}"
      environment: "ephemeral"
    output: pods_raw
    on_error: auto_heal  # K8s cluster - may need kube_login

  - name: parse_pod_health
    description: "Analyze pod health"
    compute: |
      pods_text = str(pods_raw) if 'pods_raw' in dir() and pods_raw else ""

      running = 0
      pending = 0
      failed = 0

      for line in pods_text.split("\n"):
        if "Running" in line:
          running += 1
        elif "Pending" in line or "ContainerCreating" in line:
          pending += 1
        elif "Error" in line or "CrashLoopBackOff" in line:
          failed += 1

      healthy = running > 0 and failed == 0

      result = {
        "running": running,
        "pending": pending,
        "failed": failed,
        "healthy": healthy,
        "preview": pods_text[:600] if pods_text else "",
      }
    output: pod_health

  # ==================== MEMORY & LEARNING ====================

  - name: load_recent_deployments
    description: "Load recent deployment history for context"
    tool: memory_read
    args:
      key: "state/ephemeral_deployments"
    output: recent_deployments_raw
    on_error: continue

  - name: parse_recent_deployments
    description: "Parse recent deployments for patterns"
    compute: |
      deployments = recent_deployments_raw if 'recent_deployments_raw' in dir() and recent_deployments_raw else {}

      recent = []
      if isinstance(deployments, dict):
          recent = deployments.get('deployments', [])[-5:]

      # Check for recent failures with same app
      recent_failures = [d for d in recent if d.get('app') == inputs.app and not d.get('success', True)]

      result = {
          "recent": recent,
          "recent_failures": recent_failures,
          "has_recent_failures": len(recent_failures) > 0,
      }
    output: deployment_history
    on_error: continue

  - name: search_deployment_configs
    description: "Search for deployment-related configuration"
    tool: code_search
    args:
      query: "{{ inputs.app }} deployment configuration clowdapp"
      repo: "automation-analytics-backend"
      limit: 5
    output: deployment_configs_raw
    on_error: continue

  - name: parse_deployment_configs
    description: "Parse deployment config search results"
    compute: |
      configs = deployment_configs_raw if 'deployment_configs_raw' in dir() and deployment_configs_raw else {}

      relevant_files = []
      if isinstance(configs, dict) and configs.get('results'):
          for r in configs.get('results', [])[:5]:
              relevant_files.append({
                  'file': r.get('file', ''),
                  'snippet': r.get('snippet', '')[:200],
              })

      result = {
          "config_files": relevant_files,
          "has_configs": len(relevant_files) > 0,
      }
    output: deployment_configs
    on_error: continue

  - name: log_deployment
    description: "Log deployment to session"
    tool: memory_session_log
    args:
      action: "Deployed {{ inputs.app }} to {{ namespace_info.namespace }}"
      details: "Duration: {{ inputs.duration }}, Image: {{ inputs.image_tag or 'latest' }}"
    on_error: continue

  - name: save_deployment_to_history
    description: "Save deployment to history for future reference"
    condition: "namespace_info.success"
    tool: memory_append
    args:
      key: "state/ephemeral_deployments"
      list_path: "deployments"
      item: |
        app: {{ inputs.app }}
        namespace: {{ namespace_info.namespace }}
        image_tag: {{ inputs.image_tag or 'latest' }}
        component: {{ inputs.component }}
        duration: {{ inputs.duration }}
        success: {{ deploy_status.success if deploy_status else false }}
        healthy: {{ pod_health.healthy if pod_health else false }}
        timestamp: {{ now().isoformat() }}
    on_error: continue

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_deploy_failures
    description: "Detect failure patterns from deployment"
    compute: |
      errors_detected = []

      # Check pool/reservation failures
      reserve_text = str(reserve_result) if 'reserve_result' in dir() and reserve_result else ""
      if "no pools available" in reserve_text.lower() or "no namespaces available" in reserve_text.lower():
          errors_detected.append({
              "tool": "bonfire_namespace_reserve",
              "pattern": "no pools available",
              "cause": "All ephemeral namespace pools are exhausted",
              "fix": "Wait for pools to free up or release unused namespaces"
          })
      if "unauthorized" in reserve_text.lower() or "forbidden" in reserve_text.lower():
          errors_detected.append({
              "tool": "bonfire_namespace_reserve",
              "pattern": "unauthorized",
              "cause": "Kubernetes auth expired for ephemeral cluster",
              "fix": "Run kube_login(cluster='ephemeral') to refresh credentials"
          })
      if "no route to host" in reserve_text.lower():
          errors_detected.append({
              "tool": "bonfire_namespace_reserve",
              "pattern": "no route to host",
              "cause": "VPN not connected - cannot reach ephemeral cluster",
              "fix": "Run vpn_connect() to connect to Red Hat VPN"
          })

      # Check deploy failures
      deploy_text = str(deploy_result) if 'deploy_result' in dir() and deploy_result else ""
      if "manifest unknown" in deploy_text.lower():
          errors_detected.append({
              "tool": "bonfire_deploy",
              "pattern": "manifest unknown",
              "cause": "Image tag not found in registry - wrong SHA or image not built",
              "fix": "Verify image exists in Quay with quay_get_tag() before deploying"
          })
      if "timeout" in deploy_text.lower():
          errors_detected.append({
              "tool": "bonfire_deploy",
              "pattern": "timeout",
              "cause": "Deployment timed out - pods may be failing to start",
              "fix": "Check pod status with kubectl_get_pods() and logs with kubectl_logs()"
          })

      result = errors_detected
    output: deploy_errors_detected
    on_error: continue

  - name: learn_pool_exhaustion
    description: "Learn from pool exhaustion failures"
    condition: "deploy_errors_detected and any(e.get('pattern') == 'no pools available' for e in deploy_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "bonfire_namespace_reserve"
      error_pattern: "no pools available"
      root_cause: "All ephemeral namespace pools are exhausted"
      fix_description: "Wait for pools to free up or release unused namespaces with bonfire_namespace_list(mine=True)"
    output: pool_fix_learned
    on_error: continue

  - name: learn_ephemeral_auth_failure
    description: "Learn from ephemeral cluster auth failures"
    condition: "deploy_errors_detected and any(e.get('pattern') == 'unauthorized' for e in deploy_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "bonfire_namespace_reserve"
      error_pattern: "unauthorized"
      root_cause: "Kubernetes auth expired for ephemeral cluster"
      fix_description: "Run kube_login(cluster='ephemeral') to refresh credentials"
    output: auth_fix_learned
    on_error: continue

  - name: learn_vpn_failure
    description: "Learn from VPN/network failures"
    condition: "deploy_errors_detected and any(e.get('pattern') == 'no route to host' for e in deploy_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "bonfire_namespace_reserve"
      error_pattern: "no route to host"
      root_cause: "VPN not connected - cannot reach ephemeral cluster"
      fix_description: "Run vpn_connect() to connect to Red Hat VPN"
    output: vpn_fix_learned
    on_error: continue

  - name: learn_manifest_failure
    description: "Learn from manifest unknown failures"
    condition: "deploy_errors_detected and any(e.get('pattern') == 'manifest unknown' for e in deploy_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "bonfire_deploy"
      error_pattern: "manifest unknown"
      root_cause: "Image tag not found in registry - wrong SHA or image not built"
      fix_description: "Verify image exists in Quay with quay_get_tag() before deploying"
    output: manifest_fix_learned
    on_error: continue

outputs:
  - name: report
    value: |
      ## üöÄ Ephemeral Deployment

      {% if not namespace_info.success %}
      ### ‚ùå Namespace Reservation Failed

      Could not reserve ephemeral namespace.

      {{ namespace_info.raw }}

      **Check:**
      - VPN connection
      - Ephemeral cluster credentials: `kube_login("ephemeral")`
      - Pool availability: `bonfire_pool_list()`

      {% else %}
      ### ‚úÖ Namespace Reserved

      **Namespace:** `{{ namespace_info.namespace }}`
      **Duration:** {{ inputs.duration }}
      **Pool:** {{ inputs.pool }}

      ---

      ### Dependencies
      {% if deps_info.count > 0 %}
      {{ inputs.app }} depends on {{ deps_info.count }} services:
      {% for dep in deps_info.dependencies[:5] %}
      - {{ dep }}
      {% endfor %}
      {% else %}
      No external dependencies found.
      {% endif %}

      ---

      ### Deployment Status

      {% if deploy_status.success %}
      ‚úÖ **Deployment initiated successfully**

      {% if image_config.has_custom_image %}
      **Custom Image:** `{{ inputs.image_tag }}`
      {% else %}
      **Image:** Latest from Konflux
      {% endif %}

      {% else %}
      ‚ùå **Deployment failed**

      ```
      {{ deploy_status.output }}
      ```
      {% endif %}

      ---

      ### Pod Health

      - üü¢ Running: {{ pod_health.running }}
      - üü° Pending: {{ pod_health.pending }}
      - üî¥ Failed: {{ pod_health.failed }}

      ```
      {{ pod_health.preview }}
      ```

      ---

      ### Quick Commands

      **Check pods:**
      ```
      kubectl_get_pods(namespace='{{ namespace_info.namespace }}', environment='ephemeral')
      ```

      **Get logs:**
      ```
      kubectl_logs(pod_name='<pod>', namespace='{{ namespace_info.namespace }}', environment='ephemeral')
      ```

      **Extend time:**
      ```
      bonfire_namespace_extend(namespace='{{ namespace_info.namespace }}', duration='1h')
      ```

      **Release when done:**
      ```
      bonfire_namespace_release(namespace='{{ namespace_info.namespace }}')
      ```

      {% if deployment_gotchas and deployment_gotchas.has_gotchas %}
      ---

      ### ‚ö†Ô∏è Deployment Gotchas

      {% for gotcha in deployment_gotchas.gotchas[:3] %}
      - {{ gotcha }}
      {% endfor %}
      {% endif %}

      {% if deployment_known_issues and deployment_known_issues.has_known_issues %}
      ---

      ### üí° Known Issues

      {% for issue in deployment_known_issues.issues[:3] %}
      - {{ issue.pattern if issue.pattern else issue }}
      {% endfor %}
      {% endif %}
      {% endif %}

  - name: context
    value:
      namespace: "{{ namespace_info.namespace }}"
      success: "{{ deploy_status.success if deploy_status else false }}"
      healthy: "{{ pod_health.healthy if pod_health else false }}"
