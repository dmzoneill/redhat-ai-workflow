# Skill: Environment Overview
# Full environment health check

name: environment_overview
description: |
  Get a comprehensive overview of an environment.

  This skill shows:
  - Namespace health
  - Service status
  - Ingress configuration
  - Pod summary

  Uses: k8s_environment_summary, k8s_namespace_health, kubectl_get_services,
        kubectl_get_ingress, kubectl_get_pods
version: "1.0"

inputs:
  - name: namespace
    type: string
    required: true
    description: "Kubernetes namespace"

  - name: environment
    type: string
    required: false
    default: "stage"
    description: "Environment (stage, production, ephemeral)"

steps:
  # ==================== KNOWLEDGE INTEGRATION ====================

  - name: get_devops_gotchas
    description: "Get DevOps gotchas from knowledge"
    tool: knowledge_query
    args:
      project: "automation-analytics-backend"
      persona: "devops"
      section: "gotchas"
    output: devops_gotchas_raw
    on_error: continue

  - name: parse_devops_gotchas
    description: "Parse DevOps gotchas"
    compute: |
      gotchas_result = devops_gotchas_raw if 'devops_gotchas_raw' in dir() and devops_gotchas_raw else {}

      devops_gotchas = []
      if isinstance(gotchas_result, dict) and gotchas_result.get('found'):
          content = gotchas_result.get('content', [])
          if isinstance(content, list):
              # Filter for environment-related gotchas
              for g in content:
                  g_str = str(g).lower()
                  if any(kw in g_str for kw in ['k8s', 'pod', 'deploy', 'namespace', 'service', 'ingress', 'stage', 'prod']):
                      devops_gotchas.append(g)

      result = {
          'gotchas': devops_gotchas[:5],
          'has_gotchas': len(devops_gotchas) > 0,
      }
    output: environment_gotchas
    on_error: continue

  - name: check_k8s_known_issues
    description: "Check for known k8s issues"
    compute: |
      # Check known issues for k8s operations
      k8s_issues = memory.check_known_issues("k8s", "") or {}
      kubectl_issues = memory.check_known_issues("kubectl", "") or {}

      all_issues = []
      for issues in [k8s_issues, kubectl_issues]:
          if issues and issues.get("matches"):
              all_issues.extend(issues.get("matches", [])[:2])

      result = {
          "has_known_issues": len(all_issues) > 0,
          "issues": all_issues[:5],
      }
    output: k8s_known_issues
    on_error: continue

  # ==================== K8S QUERIES ====================

  - name: get_environment_summary
    description: "Get environment summary"
    tool: k8s_environment_summary
    args:
      environment: "{{ inputs.environment }}"
    output: env_summary_raw
    on_error: continue

  - name: get_namespace_health
    description: "Get namespace health"
    tool: k8s_namespace_health
    args:
      namespace: "{{ inputs.namespace }}"
      environment: "{{ inputs.environment }}"
    output: ns_health_raw
    on_error: continue

  - name: parse_health
    description: "Parse namespace health"
    compute: |
      health_text = str(ns_health_raw) if 'ns_health_raw' in dir() and ns_health_raw else ""

      healthy = "healthy" in health_text.lower() or "ready" in health_text.lower()
      has_issues = "error" in health_text.lower() or "failed" in health_text.lower()

      result = {
        "healthy": healthy and not has_issues,
        "preview": health_text[:600] if health_text else "",
      }
    output: health_info

  - name: get_services
    description: "List services in namespace"
    tool: kubectl_get_services
    args:
      namespace: "{{ inputs.namespace }}"
      environment: "{{ inputs.environment }}"
    output: services_raw
    on_error: continue

  - name: parse_services
    description: "Parse services"
    compute: |
      services_text = str(services_raw) if 'services_raw' in dir() and services_raw else ""

      services = []
      for line in services_text.split("\n"):
        parts = line.split()
        if len(parts) >= 2 and parts[0] != "NAME":
          services.append({
            "name": parts[0],
            "type": parts[1] if len(parts) > 1 else "unknown",
            "ports": parts[4] if len(parts) > 4 else "",
          })

      result = {
        "services": services,
        "count": len(services),
      }
    output: services_info

  - name: get_ingress
    description: "Get ingress configuration"
    tool: kubectl_get_ingress
    args:
      namespace: "{{ inputs.namespace }}"
      environment: "{{ inputs.environment }}"
    output: ingress_raw
    on_error: continue

  - name: parse_ingress
    description: "Parse ingress"
    compute: |
      ingress_text = str(ingress_raw) if 'ingress_raw' in dir() and ingress_raw else ""

      import re
      hosts = re.findall(r'([a-zA-Z0-9.-]+\.(?:com|io|dev|redhat\.com))', ingress_text)

      result = {
        "hosts": list(set(hosts))[:10],
        "count": len(set(hosts)),
        "preview": ingress_text[:400] if ingress_text else "",
      }
    output: ingress_info

  - name: get_pods
    description: "Get pod summary"
    tool: kubectl_get_pods
    args:
      namespace: "{{ inputs.namespace }}"
      environment: "{{ inputs.environment }}"
    output: pods_raw
    on_error: auto_heal  # K8s cluster - may need kube_login

  - name: analyze_pods
    description: "Analyze pod health"
    compute: |
      pods_text = str(pods_raw) if 'pods_raw' in dir() and pods_raw else ""

      running = 0
      pending = 0
      failed = 0

      for line in pods_text.split("\n"):
        if "Running" in line:
          running += 1
        elif "Pending" in line or "ContainerCreating" in line:
          pending += 1
        elif "Error" in line or "CrashLoopBackOff" in line:
          failed += 1

      result = {
        "running": running,
        "pending": pending,
        "failed": failed,
        "healthy": running > 0 and failed == 0,
      }
    output: pod_analysis

  # ==================== SEMANTIC SEARCH ====================

  - name: search_environment_code
    description: "Search for code related to this environment"
    tool: code_search
    args:
      query: "Kubernetes environment {{ inputs.environment }} namespace {{ inputs.namespace }}"
      project: "automation-analytics-backend"
      limit: 3
    output: environment_code_raw
    on_error: continue

  - name: parse_environment_code
    description: "Parse environment code search results"
    condition: "environment_code_raw"
    compute: |
      code_result = environment_code_raw if environment_code_raw else {}

      related_code = []
      if isinstance(code_result, dict) and code_result.get('found'):
          for item in code_result.get('content', []):
              related_code.append(item.get('path', '') + ":" + str(item.get('line_number', '')))

      result = {
          "has_code": len(related_code) > 0,
          "code_snippets": related_code[:5],
      }
    output: environment_code_search
    on_error: continue

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_env_overview_failures
    description: "Detect failure patterns from environment overview"
    compute: |
      errors_detected = []

      # Check kubectl failures
      ns_text = str(ns_health_raw) if 'ns_health_raw' in dir() and ns_health_raw else ""
      pods_text = str(pods_raw) if 'pods_raw' in dir() and pods_raw else ""
      combined = ns_text + pods_text

      if "unauthorized" in combined.lower() or "forbidden" in combined.lower():
          errors_detected.append({
              "tool": "kubectl_get_pods",
              "pattern": "unauthorized",
              "cause": "Kubernetes auth expired",
              "fix": "Run kube_login(cluster='stage' or 'prod') to refresh credentials"
          })
      if "no route to host" in combined.lower():
          errors_detected.append({
              "tool": "kubectl_get_pods",
              "pattern": "no route to host",
              "cause": "VPN not connected - cannot reach cluster",
              "fix": "Run vpn_connect() to connect to Red Hat VPN"
          })

      result = errors_detected
    output: env_overview_errors_detected
    on_error: continue

  - name: learn_env_overview_auth_failure
    description: "Learn from k8s auth failures"
    condition: "env_overview_errors_detected and any(e.get('pattern') == 'unauthorized' for e in env_overview_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "kubectl_get_pods"
      error_pattern: "unauthorized"
      root_cause: "Kubernetes auth expired"
      fix_description: "Run kube_login(cluster='stage' or 'prod') to refresh credentials"
    output: env_overview_auth_fix_learned
    on_error: continue

  - name: log_session
    description: "Log skill execution to session"
    tool: memory_session_log
    args:
      action: "Checked environment overview"
      details: "namespace={{ inputs.namespace }}, environment={{ inputs.environment }}, healthy={{ health_info.healthy if health_info is defined else 'unknown' }}"
    on_error: continue

  - name: track_environment_checks
    description: "Track environment checks for patterns"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "environment_checks" not in patterns:
          patterns["environment_checks"] = []

      # Record this check
      check_record = {
          "namespace": inputs.namespace,
          "environment": inputs.environment,
          "healthy": health_info.healthy if health_info else False,
          "services_count": services_info.count if services_info else 0,
          "pods_running": pod_analysis.running if pod_analysis else 0,
          "pods_failed": pod_analysis.failed if pod_analysis else 0,
          "ingress_hosts": ingress_info.count if ingress_info else 0,
          "timestamp": datetime.now().isoformat(),
      }

      patterns["environment_checks"].append(check_record)

      # Keep last 100 checks
      patterns["environment_checks"] = patterns["environment_checks"][-100:]

      memory.write_memory("learned/patterns", patterns)
      result = "environment check tracked"
    output: env_tracking_result
    on_error: continue

  - name: update_environment_state
    description: "Update environment state in memory"
    compute: |
      from datetime import datetime

      # Update environment state
      env_data = memory.read_memory("state/environments") or {}
      if "environments" not in env_data:
          env_data["environments"] = {}

      env_key = inputs.environment
      if env_key not in env_data["environments"]:
          env_data["environments"][env_key] = {}

      env_data["environments"][env_key][inputs.namespace] = {
          "last_check": datetime.now().isoformat(),
          "healthy": health_info.healthy if health_info else False,
          "services": services_info.count if services_info else 0,
          "pods_running": pod_analysis.running if pod_analysis else 0,
          "pods_failed": pod_analysis.failed if pod_analysis else 0,
      }

      memory.write_memory("state/environments", env_data)
      result = "environment state updated"
    output: env_state_result
    on_error: continue

  - name: track_unhealthy_environments
    description: "Track unhealthy environments for alerting"
    condition: "health_info and not health_info.healthy"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "unhealthy_environments" not in patterns:
          patterns["unhealthy_environments"] = []

      # Track this unhealthy state
      key = f"{inputs.environment}/{inputs.namespace}"
      existing = [e for e in patterns["unhealthy_environments"] if e.get("key") == key]

      if existing:
          existing[0]["unhealthy_count"] = existing[0].get("unhealthy_count", 1) + 1
          existing[0]["last_unhealthy"] = datetime.now().isoformat()
          existing[0]["pods_failed"] = pod_analysis.failed if pod_analysis else 0
      else:
          patterns["unhealthy_environments"].append({
              "key": key,
              "namespace": inputs.namespace,
              "environment": inputs.environment,
              "unhealthy_count": 1,
              "first_unhealthy": datetime.now().isoformat(),
              "last_unhealthy": datetime.now().isoformat(),
              "pods_failed": pod_analysis.failed if pod_analysis else 0,
          })

      # Keep top 30 by unhealthy count
      patterns["unhealthy_environments"] = sorted(
          patterns["unhealthy_environments"],
          key=lambda x: x.get("unhealthy_count", 0),
          reverse=True
      )[:30]

      memory.write_memory("learned/patterns", patterns)
      result = "unhealthy environment tracked"
    output: unhealthy_tracking_result
    on_error: continue

outputs:
  - name: report
    value: |
      ## üåê Environment Overview: {{ inputs.namespace }}

      **Environment:** {{ inputs.environment }}
      **Overall Health:** {{ "‚úÖ Healthy" if health_info.healthy else "‚ö†Ô∏è Issues Detected" }}

      ---

      ### üè• Namespace Health

      {{ health_info.preview }}

      ---

      ### üöÄ Services ({{ services_info.count }})

      | Name | Type | Ports |
      |------|------|-------|
      {% for svc in services_info.services[:10] %}
      | `{{ svc.name }}` | {{ svc.type }} | {{ svc.ports }} |
      {% endfor %}

      ---

      ### üåç Ingress ({{ ingress_info.count }} hosts)

      {% for host in ingress_info.hosts %}
      - `{{ host }}`
      {% endfor %}

      {% if not ingress_info.hosts %}
      No ingress configured
      {% endif %}

      ---

      ### üì¶ Pods

      | Status | Count |
      |--------|-------|
      | üü¢ Running | {{ pod_analysis.running }} |
      | üü° Pending | {{ pod_analysis.pending }} |
      | üî¥ Failed | {{ pod_analysis.failed }} |

      {% if not pod_analysis.healthy %}
      ‚ö†Ô∏è Some pods are unhealthy. Check:
      ```
      kubectl_get_pods(namespace='{{ inputs.namespace }}', environment='{{ inputs.environment }}')
      ```
      {% endif %}

      ---

      ### üõ†Ô∏è Commands

      **List deployments:**
      ```
      k8s_list_deployments(namespace='{{ inputs.namespace }}', environment='{{ inputs.environment }}')
      ```

      **Check pod logs:**
      ```
      kubectl_logs(pod_name='<pod>', namespace='{{ inputs.namespace }}', environment='{{ inputs.environment }}')
      ```

      {% if environment_gotchas and environment_gotchas.has_gotchas %}
      ---

      ### ‚ö†Ô∏è Environment Gotchas

      {% for gotcha in environment_gotchas.gotchas[:3] %}
      - {{ gotcha }}
      {% endfor %}
      {% endif %}

      {% if k8s_known_issues and k8s_known_issues.has_known_issues %}
      ---

      ### üí° Known Issues

      {% for issue in k8s_known_issues.issues[:3] %}
      - {{ issue.pattern if issue.pattern else issue }}
      {% endfor %}
      {% endif %}
