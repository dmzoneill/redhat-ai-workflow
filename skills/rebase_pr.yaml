# Skill: Rebase PR Branch
# Rebase a PR branch onto main, handling merge commits and conflicts

name: rebase_pr
description: |
  Rebase a PR branch onto main to clean up merge commits.
  
  If 'repo_path' is not provided, resolves from issue_key or repo_name via config.
  
  Steps:
  1. Check for merge commits on the PR
  2. Checkout the branch locally
  3. Pull latest from remote
  4. Rebase onto main
  5. If conflicts: guide user through resolution
  6. Force push rebased branch
  
  Handles merge conflicts by pausing and showing what needs to be fixed.

version: "1.1"

inputs:
  - name: mr_id
    type: integer
    required: false
    description: "GitLab MR ID - will find the branch"
  
  - name: issue_key
    type: string
    required: false
    description: "Jira issue key - will find the branch and resolve repo"
  
  - name: branch
    type: string
    required: false
    description: "Branch name directly (if known)"
  
  - name: repo_path
    type: string
    required: false
    default: ""
    description: "Path to repository - if not provided, resolved from issue_key or repo_name"
  
  - name: repo_name
    type: string
    required: false
    description: "Repository name from config (e.g., 'automation-analytics-backend')"
  
  - name: base_branch
    type: string
    required: false
    default: ""
    description: "Branch to rebase onto (default: repo's default_branch from config)"
  
  - name: force_push
    type: boolean
    required: false
    default: false
    description: "Auto force-push after successful rebase (asks if false)"

# No hardcoded constants - resolved dynamically

steps:
  # ==================== RESOLVE REPOSITORY ====================
  
  - name: resolve_repo
    description: "Determine which repo and GitLab project to use"
    compute: |
      import json
      import os
      from pathlib import Path

      repo_path = None
      gitlab_project = None
      default_branch = "main"

      # Load config
      config_paths = [
          Path.cwd() / "config.json",
          Path.home() / "src/redhat-ai-workflow/config.json",
      ]
      config = {}
      for p in config_paths:
          if p.exists():
              with open(p) as f:
                  config = json.load(f)
              break

      repos = config.get("repositories", {})

      # Explicit repo path
      if inputs.repo_path and inputs.repo_path != "" and inputs.repo_path != ".":
          repo_path = inputs.repo_path
          for name, cfg in repos.items():
              if cfg.get("path") == repo_path:
                  gitlab_project = cfg.get("gitlab")
                  default_branch = cfg.get("default_branch", "main")
                  break
      # Repo name from config
      elif inputs.repo_name and inputs.repo_name in repos:
          cfg = repos[inputs.repo_name]
          repo_path = cfg.get("path")
          gitlab_project = cfg.get("gitlab")
          default_branch = cfg.get("default_branch", "main")
      # Resolve from issue key
      elif inputs.issue_key:
          project_prefix = inputs.issue_key.split("-")[0].upper()
          for name, cfg in repos.items():
              if cfg.get("jira_project") == project_prefix:
                  repo_path = cfg.get("path")
                  gitlab_project = cfg.get("gitlab")
                  default_branch = cfg.get("default_branch", "main")
                  break
      # Fall back to cwd
      else:
          cwd = os.getcwd()
          if os.path.exists(os.path.join(cwd, ".git")):
              repo_path = cwd
              for name, cfg in repos.items():
                  if cfg.get("path") == cwd:
                      gitlab_project = cfg.get("gitlab")
                      default_branch = cfg.get("default_branch", "main")
                      break

      if not repo_path:
          raise ValueError("Repository not specified. Provide 'repo_path', 'repo_name', or 'issue_key'.")

      # Override default_branch if explicitly specified
      if inputs.base_branch:
          default_branch = inputs.base_branch

      result = {
          "path": repo_path,
          "gitlab_project": gitlab_project or "automation-analytics/automation-analytics-backend",
          "default_branch": default_branch,
      }
    output: resolved_repo

  # ==================== RESOLVE BRANCH NAME ====================
  
  - name: validate_input
    description: "Ensure we have a way to identify the branch"
    compute: |
      if not inputs.get('mr_id') and not inputs.get('issue_key') and not inputs.get('branch'):
        raise ValueError("Must provide one of: mr_id, issue_key, or branch")
      result = "OK"
    output: input_valid

  - name: get_branch_from_mr
    description: "Get branch name from MR"
    condition: "inputs.get('mr_id') and not inputs.get('branch')"
    tool: gitlab_mr_view
    args:
      project: "{{ resolved_repo.gitlab_project }}"
      mr_id: "{{ inputs.mr_id }}"
    output: mr_details
    on_error: continue

  - name: list_branches
    description: "List all branches for issue key lookup"
    condition: "inputs.get('issue_key') and not inputs.get('branch')"
    tool: git_branch_list
    args:
      repo: "{{ resolved_repo.path }}"
      all_branches: true
    output: branches_raw
    on_error: continue

  - name: extract_branch
    description: "Extract branch name from MR or issue key"
    compute: |
      import re
      
      branch = inputs.get('branch')
      
      if not branch and mr_details:
        # Extract from MR details
        match = re.search(r'[Ss]ource[_ ]?[Bb]ranch[:\s]+(\S+)', mr_details)
        if match:
          branch = match.group(1)
      
      if not branch and inputs.get('issue_key'):
        # Find branch by issue key - use branches_raw from earlier step
        issue_key = inputs.issue_key.upper()
        if branches_raw:
          all_branches = [b.strip().replace('* ', '').replace('remotes/origin/', '') 
                         for b in str(branches_raw).split('\n') if b.strip()]
          matching = [b for b in all_branches if issue_key in b.upper()]
          if matching:
            branch = matching[0]
      
      if not branch:
        raise ValueError("Could not determine branch name. Please provide 'branch' input directly.")
      
      result = branch
    output: target_branch

  # ==================== CHECK FOR MERGE COMMITS ====================
  
  - name: fetch_all
    description: "Fetch latest from all remotes"
    tool: git_fetch
    args:
      repo: "{{ resolved_repo.path }}"
      prune: true
    output: fetch_result
    on_error: continue

  - name: check_merge_commits
    description: "Check if branch has merge commits"
    compute: |
      import subprocess
      
      base = resolved_repo["default_branch"]
      branch = target_branch
      
      # Get merge commits on the branch
      result = subprocess.run(
        ['git', 'log', '--merges', '--oneline', f'origin/{base}..origin/{branch}'],
        capture_output=True, text=True,
        cwd=resolved_repo["path"]
      )
      
      merge_commits = [l for l in result.stdout.strip().split('\n') if l.strip()]
      
      # Get total commits
      total_result = subprocess.run(
        ['git', 'log', '--oneline', f'origin/{base}..origin/{branch}'],
        capture_output=True, text=True,
        cwd=resolved_repo["path"]
      )
      total_commits = len([l for l in total_result.stdout.strip().split('\n') if l.strip()])
      
      result = {
        'has_merge_commits': len(merge_commits) > 0,
        'merge_count': len(merge_commits),
        'total_commits': total_commits,
        'merge_commits': merge_commits[:5]  # First 5
      }
    output: merge_check

  # ==================== CHECKOUT AND PREPARE (using MCP tools) ====================
  
  - name: check_status
    description: "Check for uncommitted changes"
    tool: git_status
    args:
      repo: "{{ resolved_repo.path }}"
    output: git_status_raw
    on_error: continue

  - name: stash_changes
    description: "Stash any local changes"
    condition: "git_status_raw and ('Changes not staged' in str(git_status_raw) or 'Changes to be committed' in str(git_status_raw))"
    tool: git_stash
    args:
      repo: "{{ resolved_repo.path }}"
      action: "push"
      message: "rebase_pr: auto-stash before rebase"
    output: stash_result
    on_error: continue

  - name: checkout_branch
    description: "Checkout the target branch"
    tool: git_checkout
    args:
      repo: "{{ resolved_repo.path }}"
      target: "{{ target_branch }}"
    output: checkout_result
    on_error: continue

  - name: checkout_fallback
    description: "Fallback: checkout from remote if local failed"
    condition: "checkout_result and 'error' in str(checkout_result).lower()"
    compute: |
      import subprocess
      
      branch = target_branch
      result = subprocess.run(
        ['git', 'checkout', '-B', branch, f'origin/{branch}'],
        capture_output=True, text=True,
        cwd=resolved_repo["path"]
      )
      if result.returncode != 0:
        raise ValueError(f"Failed to checkout {branch}: {result.stderr}")
      result = f"Checked out from remote: {branch}"
    output: checkout_fallback_result
    on_error: continue

  - name: pull_latest
    description: "Pull latest from remote"
    tool: git_pull
    args:
      repo: "{{ resolved_repo.path }}"
    output: pull_result_raw
    on_error: continue

  - name: sync_with_remote
    description: "Ensure branch is synced with remote"
    compute: |
      import subprocess
      
      # If pull failed, try reset to remote
      pull_ok = pull_result_raw and 'error' not in str(pull_result_raw).lower()
      
      if not pull_ok:
        result = subprocess.run(
          ['git', 'reset', '--hard', f'origin/{target_branch}'],
          capture_output=True, text=True,
          cwd=resolved_repo["path"]
        )
      
      result = "Branch synced with remote"
    output: pull_result
    on_error: continue

  # ==================== PERFORM REBASE ====================
  
  - name: update_base
    description: "Ensure base branch is up to date"
    compute: |
      import subprocess
      
      base = resolved_repo["default_branch"]
      
      # Fetch and update local base branch
      subprocess.run(['git', 'fetch', 'origin', base], 
                    capture_output=True, cwd=resolved_repo["path"])
      
      result = f"Updated origin/{base}"
    output: base_updated

  - name: start_rebase
    description: "Start the rebase onto base branch"
    compute: |
      import subprocess
      
      base = resolved_repo["default_branch"]
      
      # Start rebase
      result = subprocess.run(
        ['git', 'rebase', f'origin/{base}'],
        capture_output=True, text=True,
        cwd=resolved_repo["path"]
      )
      
      if result.returncode == 0:
        rebase_status = {
          'success': True,
          'conflicts': False,
          'message': 'Rebase completed successfully!'
        }
      else:
        # Check if there are conflicts
        status = subprocess.run(
          ['git', 'status', '--porcelain'],
          capture_output=True, text=True,
          cwd=resolved_repo["path"]
        )
        
        # UU = both modified (conflict)
        conflict_files = [l[3:] for l in status.stdout.split('\n') 
                         if l.startswith('UU') or l.startswith('AA') or l.startswith('DU')]
        
        if conflict_files:
          rebase_status = {
            'success': False,
            'conflicts': True,
            'conflict_files': conflict_files,
            'message': f'Rebase paused - {len(conflict_files)} file(s) have conflicts'
          }
        else:
          rebase_status = {
            'success': False,
            'conflicts': False,
            'message': f'Rebase failed: {result.stderr[:200]}'
          }
      
      result = rebase_status
    output: rebase_result

  # ==================== HANDLE CONFLICTS (AUTO-RESOLVE IF POSSIBLE) ====================
  
  - name: analyze_and_resolve_conflicts
    description: "Analyze conflicts and auto-resolve obvious ones"
    condition: "rebase_result.get('conflicts')"
    compute: |
      import subprocess
      import re
      import os
      
      conflict_files = rebase_result.get('conflict_files', [])
      repo = resolved_repo["path"]
      
      auto_resolved = []
      needs_human = []
      
      for filepath in conflict_files:
        full_path = os.path.join(repo, filepath)
        
        try:
          with open(full_path, 'r') as f:
            content = f.read()
          
          # Find all conflict blocks
          # Pattern: <<<<<<< ... ======= ... >>>>>>> 
          conflict_pattern = r'<<<<<<<[^\n]*\n(.*?)=======\n(.*?)>>>>>>>[^\n]*\n'
          conflicts = re.findall(conflict_pattern, content, re.DOTALL)
          
          if not conflicts:
            # No conflicts found, might be resolved already
            auto_resolved.append({'file': filepath, 'action': 'no_conflicts_found'})
            continue
          
          can_auto_resolve = True
          resolution_strategy = None
          
          for ours, theirs in conflicts:
            ours_stripped = ours.strip()
            theirs_stripped = theirs.strip()
            
            # Case 1: Identical (shouldn't happen but handle it)
            if ours_stripped == theirs_stripped:
              resolution_strategy = 'identical'
              continue
            
            # Case 2: Ours is empty - accept theirs (new addition)
            if not ours_stripped and theirs_stripped:
              resolution_strategy = 'accept_theirs'
              continue
            
            # Case 3: Theirs is empty - keep ours (they deleted, we modified)
            if ours_stripped and not theirs_stripped:
              resolution_strategy = 'accept_ours'
              continue
            
            # Case 4: Simple whitespace/formatting difference
            if ours_stripped.replace(' ', '').replace('\t', '') == theirs_stripped.replace(' ', '').replace('\t', ''):
              resolution_strategy = 'whitespace_only'
              continue
            
            # Case 5: One side just adds lines (non-overlapping)
            ours_lines = set(ours_stripped.split('\n'))
            theirs_lines = set(theirs_stripped.split('\n'))
            if ours_lines.issubset(theirs_lines) or theirs_lines.issubset(ours_lines):
              resolution_strategy = 'subset_merge'
              continue
            
            # Complex conflict - needs human
            can_auto_resolve = False
            break
          
          if can_auto_resolve and resolution_strategy:
            # Apply auto-resolution
            new_content = content
            
            for ours, theirs in conflicts:
              full_conflict = f'<<<<<<< HEAD\n{ours}=======\n{theirs}>>>>>>> '
              # Find and get the full marker including commit ref
              match = re.search(r'(<<<<<<<[^\n]*\n' + re.escape(ours) + r'=======\n' + re.escape(theirs) + r'>>>>>>>[^\n]*\n?)', content, re.DOTALL)
              
              if match:
                full_marker = match.group(1)
                
                if resolution_strategy in ['accept_theirs', 'subset_merge']:
                  # Keep theirs
                  new_content = new_content.replace(full_marker, theirs)
                elif resolution_strategy == 'accept_ours':
                  # Keep ours
                  new_content = new_content.replace(full_marker, ours)
                elif resolution_strategy in ['identical', 'whitespace_only']:
                  # Keep theirs (more recent)
                  new_content = new_content.replace(full_marker, theirs)
            
            # Write resolved file
            with open(full_path, 'w') as f:
              f.write(new_content)
            
            # Stage the file
            subprocess.run(['git', 'add', filepath], cwd=repo, capture_output=True)
            
            auto_resolved.append({
              'file': filepath,
              'action': f'auto_resolved ({resolution_strategy})',
              'strategy': resolution_strategy
            })
          else:
            # Count conflicts for human
            conflict_count = len(conflicts)
            needs_human.append({
              'file': filepath,
              'conflicts': conflict_count,
              'reason': 'Complex changes on both sides'
            })
            
        except Exception as e:
          needs_human.append({
            'file': filepath,
            'conflicts': '?',
            'reason': f'Error reading file: {str(e)[:50]}'
          })
      
      result = {
        'auto_resolved': auto_resolved,
        'needs_human': needs_human,
        'all_resolved': len(needs_human) == 0
      }
    output: conflict_resolution

  - name: continue_rebase_if_resolved
    description: "Continue rebase if all conflicts auto-resolved"
    condition: "conflict_resolution and conflict_resolution.get('all_resolved')"
    compute: |
      import subprocess
      
      # Try to continue the rebase
      result = subprocess.run(
        ['git', 'rebase', '--continue'],
        capture_output=True, text=True,
        cwd=resolved_repo["path"],
        env={**dict(subprocess.os.environ), 'GIT_EDITOR': 'true'}  # Skip commit message editor
      )
      
      if result.returncode == 0:
        continue_status = {
          'success': True,
          'message': 'Rebase continued successfully after auto-resolving conflicts'
        }
      else:
        # Check if more conflicts
        status = subprocess.run(
          ['git', 'status', '--porcelain'],
          capture_output=True, text=True,
          cwd=resolved_repo["path"]
        )
        new_conflicts = [l[3:] for l in status.stdout.split('\n') if l.startswith('UU')]
        
        if new_conflicts:
          continue_status = {
            'success': False,
            'message': f'More conflicts emerged: {len(new_conflicts)} files',
            'new_conflicts': new_conflicts
          }
        else:
          continue_status = {
            'success': False,
            'message': f'Rebase continue failed: {result.stderr[:100]}'
          }
      
      result = continue_status
    output: continue_result

  - name: update_rebase_result
    description: "Update rebase result after auto-resolution"
    condition: "continue_result"
    compute: |
      if continue_result.get('success'):
        # Rebase is now complete
        result = {
          'success': True,
          'conflicts': False,
          'auto_resolved': True,
          'message': 'Rebase completed (conflicts auto-resolved)'
        }
      else:
        result = rebase_result  # Keep original status
    output: final_rebase_result

  # ==================== FORCE PUSH (if successful) ====================
  
  - name: check_branch_protection
    description: "Check if force push is allowed"
    condition: "(rebase_result.get('success') or (final_rebase_result and final_rebase_result.get('success'))) and inputs.force_push"
    compute: |
      import subprocess
      
      # Dry-run to check if push would be allowed
      result = subprocess.run(
        ['git', 'push', '--dry-run', '--force-with-lease', 'origin', target_branch],
        capture_output=True, text=True,
        cwd=resolved_repo["path"]
      )
      
      stderr = result.stderr.lower()
      
      if 'protected branch' in stderr:
        protection_check = {
          'allowed': False,
          'reason': f"Branch '{target_branch}' is protected. Cannot force push."
        }
      elif 'permission denied' in stderr or '403' in stderr:
        protection_check = {
          'allowed': False,
          'reason': "Permission denied - you may not have push access."
        }
      elif 'remote rejected' in stderr:
        protection_check = {
          'allowed': False,
          'reason': "Remote rejected push - check branch rules."
        }
      else:
        protection_check = {'allowed': True, 'reason': 'OK'}
      
      result = protection_check
    output: protection_check
  
  - name: force_push
    description: "Force push rebased branch"
    condition: "(rebase_result.get('success') or (final_rebase_result and final_rebase_result.get('success'))) and inputs.force_push and (not protection_check or protection_check.get('allowed', True))"
    compute: |
      import subprocess
      
      result = subprocess.run(
        ['git', 'push', '--force-with-lease', 'origin', target_branch],
        capture_output=True, text=True,
        cwd=resolved_repo["path"]
      )
      
      if result.returncode != 0:
        stderr = result.stderr
        if 'protected' in stderr.lower():
          raise ValueError(f"Branch is protected: {target_branch}")
        raise ValueError(f"Force push failed: {stderr[:200]}")
      
      result = f"Force pushed {target_branch} to origin"
    output: push_result

  # ==================== BUILD SUMMARY ====================
  
  - name: build_summary
    description: "Build result summary"
    compute: |
      lines = ["## üîÑ Rebase PR Summary", ""]
      lines.append(f"**Branch:** `{target_branch}`")
      lines.append(f"**Base:** `{resolved_repo['default_branch']}`")
      lines.append(f"**Repository:** `{resolved_repo['path']}`")
      lines.append("")
      
      # Merge commits info
      if merge_check.get('has_merge_commits'):
        lines.append(f"### ‚ö†Ô∏è Merge Commits Found: {merge_check['merge_count']}")
        for mc in merge_check.get('merge_commits', [])[:3]:
          lines.append(f"- `{mc}`")
        lines.append("")
      
      # Use final_rebase_result if available (after auto-resolution)
      effective_result = final_rebase_result if final_rebase_result else rebase_result
      
      # Show auto-resolution results
      if conflict_resolution:
        auto_resolved = conflict_resolution.get('auto_resolved', [])
        needs_human = conflict_resolution.get('needs_human', [])
        
        if auto_resolved:
          lines.append(f"### ü§ñ Auto-Resolved: {len(auto_resolved)} file(s)")
          for ar in auto_resolved:
            lines.append(f"- ‚úÖ `{ar['file']}` ({ar.get('strategy', 'resolved')})")
          lines.append("")
        
        if needs_human:
          lines.append(f"### üôã Needs Your Help: {len(needs_human)} file(s)")
          for nh in needs_human:
            lines.append(f"- ‚ö†Ô∏è `{nh['file']}` ({nh['conflicts']} conflict(s)) - {nh.get('reason', '')}")
          lines.append("")
      
      # Final rebase result
      if effective_result.get('success'):
        lines.append("### ‚úÖ Rebase Successful!")
        if effective_result.get('auto_resolved'):
          lines.append("*Conflicts were automatically resolved*")
        lines.append("")
        if push_result:
          lines.append(f"‚úÖ {push_result}")
        else:
          lines.append("Branch is rebased locally. Ready to force push.")
      elif effective_result.get('conflicts') and conflict_resolution and conflict_resolution.get('needs_human'):
        lines.append("### ‚ö†Ô∏è Manual Resolution Required")
        lines.append("")
        lines.append("Some conflicts couldn't be auto-resolved. Please fix the files above.")
      elif effective_result.get('conflicts'):
        lines.append("### ‚ö†Ô∏è Merge Conflicts Detected")
        lines.append("")
        lines.append("Conflicts need manual resolution.")
      else:
        lines.append("### ‚ùå Rebase Failed")
        lines.append(effective_result.get('message', 'Unknown error'))
      
      result = '\n'.join(lines)
    output: summary

  # Emit rebase hooks
  - name: emit_rebase_hook
    description: "Notify author about rebase result"
    compute: |
      import asyncio
      import sys
      from pathlib import Path
      sys.path.insert(0, str(Path.home() / "src/redhat-ai-workflow"))
      
      try:
          from scripts.skill_hooks import emit_event
          
          effective_result = final_rebase_result if final_rebase_result else rebase_result
          
          if effective_result.get('success'):
              asyncio.run(emit_event("rebase_completed", {
                  "mr_id": str(inputs.get('mr_id', '')),
                  "branch": target_branch,
                  "base_branch": resolved_repo.get("default_branch", "main"),
                  "author": "",  # self - no DM needed
              }))
              result = "rebase_completed hook sent"
          elif effective_result.get('conflicts') and conflict_resolution and conflict_resolution.get('needs_human'):
              asyncio.run(emit_event("rebase_conflict", {
                  "mr_id": str(inputs.get('mr_id', '')),
                  "branch": target_branch,
                  "author": "",  # self - no DM needed
              }))
              result = "rebase_conflict hook sent"
          else:
              result = "no hook needed"
      except Exception as e:
          result = f"hook skipped: {e}"
    output: rebase_hook_result
    on_error: continue

# ==================== OUTPUT ====================

outputs:
  - name: summary
    value: |
      {{ summary }}
      
      ---
      
      {% if conflict_resolution and conflict_resolution.get('needs_human') %}
      ## üõ†Ô∏è Resolve Remaining Conflicts
      
      I auto-resolved what I could, but some conflicts need your judgment:
      
      **Step 1:** Open each file marked with ‚ö†Ô∏è above and resolve the conflicts
      Look for markers like:
      ```
      <<<<<<< HEAD
      your changes
      =======
      incoming changes
      >>>>>>> commit
      ```
      
      **Step 2:** After resolving each file, stage it:
      ```bash
      git add <filename>
      ```
      
      **Step 3:** Continue the rebase:
      ```bash
      git rebase --continue
      ```
      
      **Step 4:** If more conflicts, repeat steps 1-3
      
      **Step 5:** When complete, force push:
      ```bash
      git push --force-with-lease origin {{ target_branch }}
      ```
      
      **To abort:** `git rebase --abort`
      
      ---
      
      When you're done, tell me and I can verify and push.
      
      {% elif (final_rebase_result and final_rebase_result.get('success') and not push_result) or (rebase_result.get('success') and not push_result) %}
      ## üöÄ Ready to Push
      
      {% if conflict_resolution and conflict_resolution.get('auto_resolved') %}
      All conflicts were auto-resolved! ü§ñ
      {% endif %}
      
      The rebase completed successfully! Would you like me to force push?
      
      Say **"yes, push it"** or run:
      ```
      skill_run("rebase_pr", '{"branch": "{{ target_branch }}", "force_push": true}')
      ```
      
      Or manually:
      ```bash
      git push --force-with-lease origin {{ target_branch }}
      ```
      
      {% elif push_result %}
      ## ‚úÖ Complete!
      
      {% if conflict_resolution and conflict_resolution.get('auto_resolved') %}
      Conflicts were auto-resolved and the branch has been pushed! ü§ñ
      {% else %}
      The branch has been rebased and pushed.
      {% endif %}
      
      The MR should now show a clean history.
      
      {% elif rebase_result.get('conflicts') and not conflict_resolution %}
      ## üõ†Ô∏è Resolve Conflicts
      
      **Step 1:** Open each conflicted file and resolve the conflicts
      **Step 2:** `git add <filename>`
      **Step 3:** `git rebase --continue`
      **Step 4:** Repeat if more conflicts
      **Step 5:** `git push --force-with-lease origin {{ target_branch }}`
      
      {% else %}
      ## ‚ùå Action Required
      
      Please check the error above and try again.
      {% endif %}
  
  - name: context
    value:
      branch: "{{ target_branch }}"
      rebase_success: "{{ rebase_result.get('success', False) }}"
      has_conflicts: "{{ rebase_result.get('conflicts', False) }}"
      pushed: "{{ push_result is defined }}"

