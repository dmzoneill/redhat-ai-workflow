# Skill: Check MR Feedback
# Reviews your open MRs for comments awaiting your response

name: check_mr_feedback
description: |
  Check your open Merge Requests for feedback that needs your attention.

  Scans for:
  - Human reviewer comments (filters out bot/CI comments)
  - Meeting requests (can trigger Google Calendar invite)
  - Code change requests
  - Questions requiring answers
  - Approval status

  Optionally creates Google Meet invitations when meetings are requested.

  Uses MCP tools: gitlab_mr_list, gitlab_mr_comments
version: "1.2"

inputs:
  - name: project
    type: string
    required: false
    default: "automation-analytics/automation-analytics-backend"
    description: "GitLab project path"

  - name: create_meetings
    type: boolean
    required: false
    default: false
    description: "Automatically create Google Meet invites for meeting requests"

  - name: mr_ids
    type: array
    required: false
    description: "Specific MR IDs to check (optional - defaults to all open MRs)"

  - name: slack_format
    type: boolean
    required: false
    default: false
    description: "Use Slack link format in summary"

steps:
  # Step 1: Get list of user's open MRs using MCP tool
  - name: get_my_mrs
    description: "Fetch all open MRs authored by the current user"
    tool: gitlab_mr_list
    args:
      project: "{{ inputs.project }}"
      author: "@me"
    output: open_mrs_raw
    on_error: continue

  - name: parse_open_mrs
    description: "Parse MR list output"
    compute: |
      from scripts.common.parsers import parse_mr_list

      mrs = parse_mr_list(open_mrs_raw) if open_mrs_raw else []

      # Filter to specific MRs if provided
      if inputs.get('mr_ids'):
        mr_ids = inputs.mr_ids
        mrs = [mr for mr in mrs if mr['id'] in mr_ids]

      result = mrs
    output: open_mrs

  # Step 2: Extract MR IDs to check
  - name: prepare_mr_ids
    description: "Prepare MR IDs for individual tool calls"
    compute: |
      mr_ids = [mr['id'] for mr in (open_mrs or [])[:5]]
      mr_info = {mr['id']: mr for mr in (open_mrs or [])}
      result = {"ids": mr_ids, "info": mr_info}
    output: mr_data

  # Step 3: Get comments for each MR (up to 5)
  - name: get_mr1_comments
    description: "Get comments for first MR"
    condition: "{{ mr_data.ids|length > 0 }}"
    tool: gitlab_mr_comments
    args:
      project: "{{ inputs.project }}"
      mr_id: "{{ mr_data.ids[0] }}"
    output: mr1_comments
    on_error: continue

  - name: get_mr2_comments
    description: "Get comments for second MR"
    condition: "{{ mr_data.ids|length > 1 }}"
    tool: gitlab_mr_comments
    args:
      project: "{{ inputs.project }}"
      mr_id: "{{ mr_data.ids[1] }}"
    output: mr2_comments
    on_error: continue

  - name: get_mr3_comments
    description: "Get comments for third MR"
    condition: "{{ mr_data.ids|length > 2 }}"
    tool: gitlab_mr_comments
    args:
      project: "{{ inputs.project }}"
      mr_id: "{{ mr_data.ids[2] }}"
    output: mr3_comments
    on_error: continue

  - name: get_mr4_comments
    description: "Get comments for fourth MR"
    condition: "{{ mr_data.ids|length > 3 }}"
    tool: gitlab_mr_comments
    args:
      project: "{{ inputs.project }}"
      mr_id: "{{ mr_data.ids[3] }}"
    output: mr4_comments
    on_error: continue

  - name: get_mr5_comments
    description: "Get comments for fifth MR"
    condition: "{{ mr_data.ids|length > 4 }}"
    tool: gitlab_mr_comments
    args:
      project: "{{ inputs.project }}"
      mr_id: "{{ mr_data.ids[4] }}"
    output: mr5_comments
    on_error: continue

  # Step 4: Analyze all comments
  - name: check_comments
    description: "Analyze comments from all MRs using shared parsers"
    compute: |
      import os
      from datetime import datetime
      from scripts.common.config_loader import load_config
      from scripts.common.parsers import is_bot_comment, split_mr_comments

      # Load config using shared loader
      cfg = load_config()
      current_user = cfg.get("user", {}).get("username") or os.getenv("USER", "unknown")

      # Meeting keywords
      meeting_keywords = [
        'meeting', 'meet', 'call', 'discuss', 'sync', 'chat',
        'walk through', 'walkthrough', 'talk about', 'prepared to talk',
        'let\'s discuss', 'schedule a', 'set up a call'
      ]

      # Feedback requiring response
      feedback_keywords = [
        'please', 'could you', 'can you', 'would be better',
        'consider', 'suggest', 'recommend', 'instead of',
        'why not', 'what about', 'have you considered',
        '?'  # Questions
      ]

      feedback_results = []

      # Build list of (mr_id, comments_text) pairs from tool outputs
      all_comments = []
      for i, var_name in enumerate(['mr1_comments', 'mr2_comments', 'mr3_comments', 'mr4_comments', 'mr5_comments']):
        if i >= len(mr_data.get('ids', [])):
          break
        mr_id = mr_data['ids'][i]
        comments = eval(var_name) if var_name in dir() else None
        if comments:
          all_comments.append((mr_id, str(comments)))

      for mr_id, comments_text in all_comments:
        # Get MR info from our data
        mr_info = mr_data.get('info', {}).get(mr_id, {})

        # Parse comments using shared parser
        parsed_comments = split_mr_comments(comments_text)

        human_comments = []

        for author, timestamp_str, comment_text in parsed_comments:
          # Skip bot comments using shared utility
          if not is_bot_comment(comment_text, author) and author.lower() != current_user.lower():
            # Check for meeting request
            is_meeting_request = any(kw in comment_text.lower() for kw in meeting_keywords)

            # Check for feedback requiring response
            needs_response = any(kw in comment_text.lower() for kw in feedback_keywords)

            # Extract email
            author_email = f"{author}@redhat.com"

            human_comments.append({
              "author": author,
              "author_email": author_email,
              "timestamp": timestamp_str,
              "text": comment_text[:500],  # Truncate long comments
              "is_meeting_request": is_meeting_request,
              "needs_response": needs_response,
            })

          idx += 3

        if human_comments:
          feedback_results.append({
            "mr_id": mr_id,
            "title": mr_info.get('title', ''),
            "comments": human_comments,
            "meeting_requests": [c for c in human_comments if c['is_meeting_request']],
            "needs_response": [c for c in human_comments if c['needs_response']],
          })

      result = feedback_results
    output: feedback_analysis

  # Step 4: Check for existing meetings to avoid duplicates
  - name: check_existing_meetings
    description: "Check if meetings already exist for meeting requests"
    condition: "{{ feedback_analysis }}"
    compute: |
      # For each MR with meeting requests, mark for calendar check
      for mr_feedback in feedback_analysis:
        mr_id = mr_feedback['mr_id']

        # Mark meeting requests as already_scheduled if meeting exists
        for meeting_req in mr_feedback.get('meeting_requests', []):
          # Default to not scheduled
          meeting_req['already_scheduled'] = False
          meeting_req['existing_meeting'] = None

        # Flag for the format_summary step to remind about checking
        mr_feedback['needs_calendar_check'] = len(mr_feedback.get('meeting_requests', [])) > 0

      result = feedback_analysis
    output: feedback_with_calendar_check

  # Step 5: Create meeting invites if requested
  - name: create_meeting_invites
    description: "Create Google Meet invitations for meeting requests"
    condition: "{{ inputs.create_meetings and feedback_with_calendar_check }}"
    compute: |
      from datetime import datetime, timedelta
      from scripts.common.config_loader import load_config

      # Load config using shared loader
      config = load_config()
      google_config = config.get("google_calendar", {})

      if not google_config.get("enabled"):
        result = {
          "created": [],
          "skipped": "Google Calendar not configured. Add google_calendar config to config.json"
        }
      else:
        created_meetings = []
        skipped_meetings = []

        for mr_feedback in feedback_with_calendar_check:
          for meeting_req in mr_feedback.get('meeting_requests', []):
            # Skip if already scheduled
            if meeting_req.get('already_scheduled'):
              skipped_meetings.append({
                "mr_id": mr_feedback['mr_id'],
                "requester": meeting_req['author'],
                "reason": "Meeting already exists",
                "existing": meeting_req.get('existing_meeting')
              })
              continue

            # Meeting details
            meeting_info = {
              "mr_id": mr_feedback['mr_id'],
              "title": f"MR !{mr_feedback['mr_id']} Review Discussion",
              "requester": meeting_req['author'],
              "requester_email": meeting_req.get('author_email'),
              "context": meeting_req['text'][:200],
              "status": "pending_google_calendar_tool"
            }
            created_meetings.append(meeting_info)

        result = {
          "created": created_meetings,
          "skipped": skipped_meetings,
          "note": "Use google_calendar_quick_meeting tool to create meetings"
        }
    output: meeting_results
    on_error: continue

  # Step 6: Format summary
  - name: format_summary
    description: "Create human-readable summary"
    compute: |
      from scripts.common.parsers import linkify_mr_ids
      is_slack = inputs.get('slack_format', True)

      lines = []
      lines.append("# MR Feedback Summary")
      lines.append("")

      # Use feedback_with_calendar_check if available, otherwise feedback_analysis
      analysis = feedback_with_calendar_check if feedback_with_calendar_check else feedback_analysis

      if not analysis:
        lines.append("‚úÖ **No pending feedback found!** All your MRs are clear.")
      else:
        # Count totals
        total_mrs = len(analysis)
        total_comments = sum(len(f['comments']) for f in analysis)
        meeting_requests = sum(len(f['meeting_requests']) for f in analysis)
        needs_response = sum(len(f['needs_response']) for f in analysis)

        lines.append(f"Found feedback on **{total_mrs}** MRs ({total_comments} comments)")
        lines.append("")

        if meeting_requests > 0:
          lines.append(f"üìÖ **{meeting_requests} meeting request(s)** detected")
        if needs_response > 0:
          lines.append(f"üìù **{needs_response} comment(s)** may need your response")
        lines.append("")

        # Details per MR
        for mr_feedback in analysis:
          mr_id = mr_feedback['mr_id']
          mr_str = linkify_mr_ids(f"!{mr_id}", slack_format=is_slack)
          title = mr_feedback['title'][:60]

          lines.append(f"## MR {mr_str}")
          lines.append(f"*{title}*")
          lines.append("")

          for comment in mr_feedback['comments']:
            author = comment['author']
            text = comment['text'][:300]
            author_email = comment.get('author_email', f"{author}@redhat.com")

            # Icons based on type
            icon = "üí¨"
            if comment['is_meeting_request']:
              icon = "üìÖ"
            elif comment['needs_response']:
              icon = "‚ùì"

            lines.append(f"| {icon} | **{author}** |")
            lines.append(f"| | {text} |")

            # Add meeting scheduling suggestion for meeting requests
            if comment['is_meeting_request']:
              lines.append("")
              lines.append(f"**‚ö†Ô∏è Before scheduling, check if meeting already exists:**")
              lines.append(f"```")
              lines.append(f'google_calendar_find_meeting(mr_id="{mr_id}", attendee_email="{author_email}")')
              lines.append(f"```")
              lines.append("")
              lines.append(f"**To schedule (if no meeting exists):**")
              lines.append(f"```")
              lines.append(f'google_calendar_quick_meeting(')
              lines.append(f'    title="MR !{mr_id} Discussion",')
              lines.append(f'    attendee_email="{author_email}",')
              lines.append(f'    when="auto"')
              lines.append(f')')
              lines.append(f"```")

            lines.append("")

          lines.append("---")
          lines.append("")

      # Meeting creation results
      if meeting_results:
        if meeting_results.get('skipped'):
          lines.append("## ‚è≠Ô∏è Skipped Meeting Requests (already scheduled)")
          for m in meeting_results['skipped']:
            mr_id_str = linkify_mr_ids(f"!{m['mr_id']}", slack_format=is_slack)
            lines.append(f"- MR {mr_id_str} with {m['requester']}: {m['reason']}")
          lines.append("")

        if meeting_results.get('created'):
          lines.append("## üìÖ Meeting Invites to Create")
          for m in meeting_results['created']:
            lines.append(f"- **{m['title']}** with {m['requester']}")
          lines.append("")

      result = '\n'.join(lines)
    output: summary

  # ==================== MEMORY INTEGRATION ====================

  - name: build_memory_context
    description: "Build context for memory updates"
    compute: |
      from datetime import datetime
      result = {"timestamp": datetime.now().isoformat()}
    output: memory_context

  - name: log_session_feedback_check
    description: "Log feedback check to session"
    tool: memory_session_log
    args:
      action: "Checked MR feedback"
      details: "{{ (feedback_with_calendar_check or feedback_analysis) | length if (feedback_with_calendar_check or feedback_analysis) else 0 }} MRs with feedback"
    on_error: continue

  - name: create_followups_for_feedback
    description: "Create follow-up tasks for MRs needing response"
    condition: "feedback_analysis"
    compute: |
      # Use shared memory helpers
      followups = memory.get_follow_ups()
      existing_tasks = [fu.get("task", "") for fu in followups]

      # Add follow-ups for MRs needing response
      analysis = feedback_analysis or []
      added = 0

      for mr_feedback in analysis:
          mr_id = mr_feedback.get("mr_id")
          needs_response = mr_feedback.get("needs_response", [])
          meeting_requests = mr_feedback.get("meeting_requests", [])

          # Create follow-up for response needed
          if needs_response:
              task = f"Respond to feedback on MR !{mr_id}"
              if task not in existing_tasks:
                  memory.add_follow_up(task=task, priority="high", mr_id=mr_id)
                  added += 1

          # Create follow-up for meeting requests
          if meeting_requests:
              authors = [m.get("author", "someone") for m in meeting_requests]
              task = f"Schedule meeting for MR !{mr_id} with {', '.join(authors[:2])}"
              if task not in existing_tasks:
                  memory.add_follow_up(task=task, priority="medium", mr_id=mr_id)
                  added += 1

      result = f"Added {added} follow-ups"
    output: followup_result
    on_error: continue

outputs:
  - name: summary
    value: "{{ summary }}"

  - name: context
    value:
      total_mrs_with_feedback: "{{ (feedback_with_calendar_check or feedback_analysis) | length if (feedback_with_calendar_check or feedback_analysis) else 0 }}"
      meeting_requests: "{{ (feedback_with_calendar_check or feedback_analysis) | sum(attribute='meeting_requests') | list | length if (feedback_with_calendar_check or feedback_analysis) else 0 }}"
      needs_response: "{{ feedback_analysis | sum(attribute='needs_response') | list | length if feedback_analysis else 0 }}"
      details: "{{ feedback_analysis }}"
