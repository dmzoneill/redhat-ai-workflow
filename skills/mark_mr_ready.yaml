# Skill: Mark MR as Ready for Review
# Removes draft status and notifies team on Slack

name: mark_mr_ready
description: |
  Mark a draft merge request as ready for review.
  - Removes draft status from the MR
  - Posts to team Slack channel asking for review
  - Optionally updates Jira status to "In Review"

version: "1.0"

inputs:
  - name: mr_id
    type: string
    required: true
    description: "MR ID (e.g., '1459' or '!1459')"

  - name: project
    type: string
    required: false
    default: "automation-analytics/automation-analytics-backend"
    description: "GitLab project path"

  - name: issue_key
    type: string
    required: false
    description: "Jira issue key to update status (e.g., AAP-12345)"

  - name: update_jira
    type: boolean
    required: false
    default: true
    description: "Update Jira status to In Review"

  - name: run_linting
    type: boolean
    required: false
    default: true
    description: "Run linting checks before marking MR ready"

  - name: repo
    type: string
    required: false
    default: ""
    description: "Repository path for linting (auto-detected if not provided)"

  - name: check_docs
    type: boolean
    required: false
    default: true
    description: "Check documentation before marking ready (if docs.check_on_mr=true in config)"

steps:

  # ==================== KNOWLEDGE INTEGRATION ====================

  - name: get_mr_readiness_patterns
    description: "Get MR readiness patterns from knowledge base"
    tool: knowledge_query
    args:
      project: "automation-analytics-backend"
      persona: "developer"
      query: "gotchas"
    output: mr_ready_knowledge_raw
    on_error: continue

  - name: parse_mr_ready_knowledge
    description: "Parse MR readiness knowledge"
    compute: |
      knowledge_text = str(mr_ready_knowledge_raw) if mr_ready_knowledge_raw else ""

      gotchas = []
      checklist = []

      # Extract gotchas related to MR readiness
      if knowledge_text:
          for line in knowledge_text.split("\n"):
              line_lower = line.lower()
              if any(kw in line_lower for kw in ["mr", "merge", "review", "ready", "draft", "lint", "test"]):
                  gotchas.append(line.strip()[:150])
              if any(kw in line_lower for kw in ["check", "ensure", "verify", "must", "should"]):
                  checklist.append(line.strip()[:150])

      result = {
          "has_knowledge": len(gotchas) > 0,
          "gotchas": gotchas[:5],
          "checklist": checklist[:5],
      }
    output: mr_ready_knowledge
    on_error: continue

  # ==================== PROACTIVE ISSUE DETECTION ====================

  - name: check_gitlab_known_issues
    description: "Check for known GitLab issues before starting"
    tool: check_known_issues
    args:
      tool_name: "gitlab_mr_update"
      error_text: ""
    output: gitlab_known_issues
    on_error: continue

  - name: init_autoheal
    description: "Initialize failure tracking"
    compute: |
      result = {"failures": []}
    output: autoheal_state
    on_error: continue

  # Step 1: Load config
  - name: load_config
    compute: |
      from scripts.common.config_loader import load_config

      config = load_config()
      jira_url = config.get("jira", {}).get("url", "https://issues.redhat.com")
      gitlab_url = config.get("gitlab", {}).get("url", "https://gitlab.cee.redhat.com")

      # Get team group info for @mentions
      team_channel = config.get("slack", {}).get("channels", {}).get("team", {})
      team_group_id = team_channel.get("group_id", "")
      team_group_handle = team_channel.get("group_handle", "aa-api-team")

      # Clean MR ID
      mr_id = str(inputs.get("mr_id", "")).lstrip("!").strip()

      result = {
          "jira_url": jira_url,
          "gitlab_url": gitlab_url,
          "mr_id": mr_id,
          "team_group_id": team_group_id,
          "team_group_handle": team_group_handle,
      }
    output: cfg

  # Step 2: Get MR details first
  - name: get_mr_details
    description: "Get current MR details"
    tool: gitlab_mr_view
    args:
      project: "{{ inputs.project }}"
      mr_id: "{{ cfg.mr_id }}"
    output: mr_details
    on_error: auto_heal  # GitLab API - may need auth refresh

  # Step 3: Parse MR info
  - name: parse_mr
    compute: |
      from scripts.common.parsers import extract_jira_key

      from scripts.common.parsers import extract_mr_url

      details = str(mr_details) if mr_details else ""

      # Extract title
      title = ""
      for line in details.split("\n"):
          if line.strip() and not line.startswith("!"):
              title = line.strip()[:80]
              break

      # Try to find Jira key in title or branch
      jira_key = inputs.issue_key if inputs.issue_key else extract_jira_key(details)

      # Extract web URL using shared parser
      web_url = extract_mr_url(details)

      if not web_url:
          web_url = f"{cfg['gitlab_url']}/{inputs.project}/-/merge_requests/{cfg['mr_id']}"

      result = {
          "title": title,
          "jira_key": jira_key,
          "web_url": web_url,
      }
    output: mr_info

  # ==================== LINTING BEFORE MARKING READY ====================

  - name: resolve_repo_for_lint
    description: "Resolve repo path for linting"
    condition: "inputs.run_linting"
    compute: |
      import os
      from scripts.common.config_loader import load_config

      repo_path = None

      if inputs.repo and inputs.repo != "":
        repo_path = inputs.repo
      else:
        # Try to resolve from project name
        config = load_config()
        repos = config.get("repositories", {})
        project = inputs.project

        for name, cfg in repos.items():
          gitlab = cfg.get("gitlab", "")
          if gitlab and project in gitlab:
            repo_path = cfg.get("path")
            break

        # Fall back to cwd
        if not repo_path:
          cwd = os.getcwd()
          if os.path.exists(os.path.join(cwd, ".git")):
            repo_path = cwd

      result = {"path": repo_path}
    output: lint_repo

  - name: run_black_check
    description: "Check code formatting before marking ready"
    condition: "inputs.run_linting and lint_repo and lint_repo.get('path')"
    tool: code_format
    args:
      repo: "{{ lint_repo.path }}"
      tool: "black"
      check_only: true
    output: black_raw
    on_error: continue

  - name: run_flake8_check
    description: "Run flake8 linting before marking ready"
    condition: "inputs.run_linting and lint_repo and lint_repo.get('path')"
    tool: code_lint
    args:
      repo: "{{ lint_repo.path }}"
      tool: "flake8"
      max_line_length: 100
      ignore: "E501,W503,E203"
    output: flake8_raw
    on_error: continue

  - name: parse_lint_results
    description: "Parse lint results"
    condition: "inputs.run_linting and lint_repo and lint_repo.get('path')"
    compute: |
      black_output = str(black_raw) if 'black_raw' in dir() and black_raw else ""
      flake8_output = str(flake8_raw) if 'flake8_raw' in dir() and flake8_raw else ""

      black_ok = "‚úÖ" in black_output or "check passed" in black_output.lower() or not black_output.strip()
      flake8_ok = "‚úÖ" in flake8_output or "passed" in flake8_output.lower() or not flake8_output.strip()

      issues = []
      if not black_ok and black_output.strip():
        issues.append("Black: Code needs formatting (run 'black .')")
      if not flake8_ok and flake8_output.strip():
        issue_lines = [l for l in flake8_output.split('\n') if ':' in l and ('E' in l or 'F' in l or 'W' in l)]
        # Skip ignored codes
        issue_lines = [l for l in issue_lines if not any(skip in l for skip in ['E501', 'W503', 'E203'])]
        if issue_lines:
          issues.append(f"Flake8: {len(issue_lines)} issue(s) found")

      result = {
        "passed": len(issues) == 0,
        "issues": issues,
        "message": "Lint passed" if not issues else "; ".join(issues),
      }
    output: lint_result

  - name: block_on_lint_before_ready
    description: "Block marking ready if lint fails"
    condition: "inputs.run_linting and lint_result and not lint_result.get('passed', True)"
    compute: |
      issues = lint_result.get("issues", [])
      raise ValueError(
        f"‚ùå Lint errors found. Fix before marking MR ready:\n" +
        "\n".join(f"  - {i}" for i in issues) +
        "\n\nRun 'black . && flake8' to check locally, then push fixes."
      )
    output: lint_block

  # ==================== DOCUMENTATION CHECK ====================

  - name: run_docs_check
    description: "Check documentation before marking ready"
    condition: "inputs.check_docs and lint_repo and lint_repo.get('path')"
    tool: skill_run
    args:
      skill_name: update_docs
      inputs: '{"repo": "{{ lint_repo.path }}", "check_only": true}'
      execute: true
    output: docs_check_result
    on_error: continue

  - name: parse_docs_result
    description: "Parse documentation check results"
    condition: "inputs.check_docs"
    compute: |
      result_text = str(docs_check_result) if 'docs_check_result' in dir() and docs_check_result else ""

      needs_attention = "Issues Found" in result_text or "Suggestions" in result_text
      skipped = "Skipped" in result_text or "not enabled" in result_text.lower()

      result = {
          "needs_attention": needs_attention and not skipped,
          "skipped": skipped,
      }
    output: docs_result

  # Step 4: Mark as ready (remove draft)
  - name: mark_ready
    description: "Remove draft status from MR"
    tool: gitlab_mr_update
    args:
      project: "{{ inputs.project }}"
      mr_id: "{{ cfg.mr_id }}"
      draft: false
    output: update_result
    on_error: auto_heal  # GitLab API - may need auth refresh

  # Step 5: Build Slack message with team mention
  - name: build_slack_message
    description: "Build Slack message with proper team mention"
    condition: "'Updated' in str(update_result) or 'success' in str(update_result).lower()"
    compute: |
      # Build team mention
      team_group_id = cfg.get("team_group_id", "")
      team_group_handle = cfg.get("team_group_handle", "aa-api-team")
      team_mention = slack_utils.build_team_mention(team_group_id, team_group_handle)

      jira_url = cfg.get("jira_url", "https://issues.redhat.com")
      jira_key = mr_info.get("jira_key", "")
      mr_id = cfg.get("mr_id", "")
      web_url = mr_info.get("web_url", "")
      title = mr_info.get("title", "")
      project = inputs.get("project", "")
      repo_name = project.split("/")[-1] if "/" in project else project

      lines = [team_mention, "üîÄ *MR Ready for Review*", ""]

      if jira_key:
          lines.append(f"‚Ä¢ <{jira_url}/browse/{jira_key}|{jira_key}>")

      lines.append(f"‚Ä¢ <{web_url}|!{mr_id}: {title}>")

      result = "\n".join(lines)
    output: slack_message

  # Step 6: Post to Slack
  - name: notify_team_slack
    description: "Post to team channel asking for review"
    condition: "slack_message"
    tool: slack_post_team
    args:
      text: "{{ slack_message }}"
    output: slack_result
    on_error: auto_heal  # Slack API - may need auth refresh

  # Step 7: Update Jira status
  - name: update_jira_status
    description: "Move Jira to In Review"
    condition: "inputs.update_jira and mr_info.jira_key"
    tool: jira_set_status
    args:
      issue_key: "{{ mr_info.jira_key }}"
      status: "In Review"
    output: jira_result
    on_error: auto_heal  # Jira API - may need auth refresh

  # ==================== SEMANTIC SEARCH ====================

  - name: search_mr_code
    description: "Search for code related to the MR being marked ready"
    condition: "mr_info and mr_info.title"
    tool: code_search
    args:
      query: "GitLab MR !{{ cfg.mr_id }} {{ mr_info.title or '' }}"
      project: "automation-analytics-backend"
      limit: 3
    output: mr_code_raw
    on_error: continue

  - name: parse_mr_code
    description: "Parse MR code search results"
    condition: "mr_code_raw"
    compute: |
      code_result = mr_code_raw if mr_code_raw else {}

      related_code = []
      if isinstance(code_result, dict) and code_result.get('found'):
          for item in code_result.get('content', []):
              related_code.append(item.get('path', '') + ":" + str(item.get('line_number', '')))

      result = {
          "has_code": len(related_code) > 0,
          "code_snippets": related_code[:5],
      }
    output: mr_code_search
    on_error: continue

  # ==================== MEMORY INTEGRATION ====================

  - name: build_memory_context
    description: "Build timestamp for memory"
    compute: |
      from datetime import datetime
      result = {"timestamp": datetime.now().isoformat()}
    output: memory_context

  - name: log_session_mr_ready
    description: "Log MR ready to session log"
    condition: "'Updated' in str(update_result)"
    tool: memory_session_log
    args:
      action: "Marked MR !{{ cfg.mr_id }} ready for review"
      details: "{{ mr_info.web_url }}"
    on_error: continue

  - name: update_mr_in_memory
    description: "Update MR status in memory to needs_review"
    condition: "'Updated' in str(update_result)"
    tool: memory_update
    args:
      key: "state/current_work"
      path: "last_updated"
      value: "{{ memory_context.timestamp }}"
    on_error: continue

  - name: track_mr_ready_actions
    description: "Track MR ready actions for patterns"
    condition: "'Updated' in str(update_result)"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "mr_ready_actions" not in patterns:
          patterns["mr_ready_actions"] = []

      # Record this action
      ready_record = {
          "mr_id": cfg.mr_id if cfg else "unknown",
          "project": inputs.project,
          "jira_key": mr_info.jira_key if mr_info else None,
          "lint_passed": lint_result.passed if lint_result else True,
          "docs_checked": inputs.check_docs,
          "slack_notified": bool(slack_result) if 'slack_result' in dir() else False,
          "jira_updated": bool(jira_result) if 'jira_result' in dir() else False,
          "timestamp": datetime.now().isoformat(),
      }

      patterns["mr_ready_actions"].append(ready_record)

      # Keep last 100 actions
      patterns["mr_ready_actions"] = patterns["mr_ready_actions"][-100:]

      memory.write_memory("learned/patterns", patterns)
      result = "mr ready action tracked"
    output: ready_tracking_result
    on_error: continue

  - name: update_open_mrs_state
    description: "Update open MRs state with ready status"
    condition: "'Updated' in str(update_result)"
    compute: |
      from datetime import datetime

      # Update current work state
      current_work = memory.read_memory("state/current_work") or {}
      if "open_mrs" not in current_work:
          current_work["open_mrs"] = []

      # Find and update this MR
      mr_id = cfg.mr_id if cfg else None
      for mr in current_work["open_mrs"]:
          if str(mr.get("id")) == str(mr_id):
              mr["is_draft"] = False
              mr["marked_ready"] = datetime.now().isoformat()
              mr["needs_review"] = True
              break
      else:
          # Add if not found
          current_work["open_mrs"].append({
              "id": mr_id,
              "project": inputs.project,
              "jira_key": mr_info.jira_key if mr_info else None,
              "is_draft": False,
              "marked_ready": datetime.now().isoformat(),
              "needs_review": True,
          })

      memory.write_memory("state/current_work", current_work)
      result = "open MRs state updated"
    output: mrs_state_result
    on_error: continue

outputs:
  - name: summary
    value: |
      ## {{ "‚úÖ" if "Updated" in str(update_result) else "‚ùå" }} MR !{{ cfg.mr_id }} Marked Ready

      | Step | Result |
      |------|--------|
      {% if inputs.run_linting %}| Linting | {{ "‚úÖ Passed" if lint_result and lint_result.passed else "‚è≠Ô∏è Skipped" }} |{% endif %}
      {% if inputs.check_docs %}| Docs check | {{ "‚ö†Ô∏è Needs attention" if docs_result and docs_result.needs_attention else "‚úÖ OK" if not docs_result.skipped else "‚è≠Ô∏è Skipped" }} |{% endif %}
      | Remove draft | {{ "‚úÖ Done" if "Updated" in str(update_result) else "‚ùå Failed" }} |
      | Slack notification | {{ "‚úÖ Posted" if slack_result else "‚è≠Ô∏è Skipped" }} |
      {% if mr_info.jira_key %}| Jira status | {{ "‚úÖ Updated" if jira_result else "‚è≠Ô∏è Skipped" }} |{% endif %}

      **MR:** {{ mr_info.web_url }}
      {% if mr_info.jira_key %}**Jira:** {{ cfg.jira_url }}/browse/{{ mr_info.jira_key }}{% endif %}

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_ready_failures
    description: "Detect failure patterns from marking MR ready"
    compute: |
      errors_detected = []

      # Check GitLab failures
      mr_text = str(mr_details_raw) if 'mr_details_raw' in dir() and mr_details_raw else ""
      update_text = str(update_result) if 'update_result' in dir() and update_result else ""
      combined = mr_text + update_text

      if "no such host" in combined.lower():
          errors_detected.append({
              "tool": "gitlab_mr_update",
              "pattern": "no such host",
              "cause": "VPN not connected - internal GitLab not reachable",
              "fix": "Run vpn_connect() to connect to Red Hat VPN"
          })
      if "not found" in combined.lower() and "merge request" in combined.lower():
          errors_detected.append({
              "tool": "gitlab_mr_update",
              "pattern": "merge request not found",
              "cause": "MR ID doesn't exist or wrong project",
              "fix": "Check MR ID and project path"
          })

      # Check Slack failures
      slack_text = str(slack_result) if 'slack_result' in dir() and slack_result else ""
      if "not_in_channel" in slack_text.lower():
          errors_detected.append({
              "tool": "slack_post_team",
              "pattern": "not_in_channel",
              "cause": "Bot not added to Slack channel",
              "fix": "Invite the bot to the team channel"
          })

      result = errors_detected
    output: ready_errors_detected
    on_error: continue

  - name: learn_ready_vpn_failure
    description: "Learn from VPN failures"
    condition: "ready_errors_detected and any(e.get('pattern') == 'no such host' for e in ready_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "gitlab_mr_update"
      error_pattern: "no such host"
      root_cause: "VPN not connected - internal GitLab not reachable"
      fix_description: "Run vpn_connect() to connect to Red Hat VPN"
    output: ready_vpn_fix_learned
    on_error: continue

  - name: context
    value:
      mr_id: "{{ cfg.mr_id }}"
      mr_url: "{{ mr_info.web_url }}"
      jira_key: "{{ mr_info.jira_key }}"
      slack_posted: "{{ true if slack_result else false }}"
