# Skill: Close MR
# Close a merge request (abandoned or replaced)

name: close_mr
description: |
  Close a GitLab merge request.

  Use when:
  - MR is abandoned
  - MR is replaced by another
  - Work is no longer needed

  Uses: gitlab_mr_view, gitlab_mr_close, jira_transition, jira_add_comment
version: "1.0"

inputs:
  - name: mr_id
    type: integer
    required: true
    description: "GitLab MR ID"

  - name: project
    type: string
    required: false
    default: "automation-analytics/automation-analytics-backend"
    description: "GitLab project path"

  - name: reason
    type: string
    required: false
    default: "Closing - no longer needed"
    description: "Reason for closing"

  - name: update_jira
    type: boolean
    required: false
    default: true
    description: "Update linked Jira issue"

steps:
  # ==================== PROACTIVE ISSUE DETECTION ====================

  - name: check_gitlab_known_issues
    description: "Check for known GitLab issues before starting"
    tool: check_known_issues
    args:
      tool_name: "gitlab_mr_close"
      error_text: ""
    output: gitlab_known_issues
    on_error: continue

  - name: get_mr_details
    description: "Get MR details before closing"
    tool: gitlab_mr_view
    args:
      project: "{{ inputs.project }}"
      mr_id: "{{ inputs.mr_id }}"
    output: mr_details_raw
    on_error: auto_heal  # GitLab API - may need auth refresh

  - name: extract_jira_key
    description: "Extract Jira key from MR"
    compute: |
      mr_text = str(mr_details_raw) if 'mr_details_raw' in dir() and mr_details_raw else ""

      import re
      jira_match = re.search(r'(AAP-\d+)', mr_text)
      jira_key = jira_match.group(1) if jira_match else None

      # Extract title
      title_match = re.search(r'title[:\s]+([^\n]+)', mr_text, re.I)
      title = title_match.group(1).strip()[:80] if title_match else f"MR !{inputs.mr_id}"

      # Extract author
      author_match = re.search(r'author[:\s]+([^\n]+)', mr_text, re.I)
      author = author_match.group(1).strip() if author_match else "unknown"

      result = {
        "jira_key": jira_key,
        "title": title,
        "author": author,
      }
    output: mr_info

  - name: close_mr
    description: "Close the merge request"
    tool: gitlab_mr_close
    args:
      project: "{{ inputs.project }}"
      mr_id: "{{ inputs.mr_id }}"
    output: close_result
    on_error: continue

  - name: parse_close_result
    description: "Parse close result"
    compute: |
      close_text = str(close_result) if 'close_result' in dir() and close_result else ""

      success = "closed" in close_text.lower() or "success" in close_text.lower()
      if "error" in close_text.lower() or "failed" in close_text.lower():
        success = False

      result = {
        "success": success,
        "message": close_text[:200] if close_text else "",
      }
    output: close_status

  - name: add_jira_comment
    description: "Add comment to Jira issue"
    condition: "close_status.success and mr_info.jira_key and inputs.update_jira"
    tool: jira_add_comment
    args:
      issue_key: "{{ mr_info.jira_key }}"
      comment: |
        MR !{{ inputs.mr_id }} was closed.

        Reason: {{ inputs.reason }}
    output: jira_comment_result
    on_error: auto_heal  # Jira API - may need auth refresh

  - name: log_closure
    description: "Log MR closure"
    tool: memory_session_log
    args:
      action: "Closed MR !{{ inputs.mr_id }}"
      details: "{{ mr_info.title }} - {{ inputs.reason }}"
    on_error: continue

  - name: track_mr_closures
    description: "Track MR closures for patterns"
    condition: "close_status and close_status.success"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "mr_closures" not in patterns:
          patterns["mr_closures"] = []

      # Record this closure
      closure_record = {
          "mr_id": inputs.mr_id,
          "project": inputs.project,
          "title": mr_info.title if mr_info else "unknown",
          "jira_key": mr_info.jira_key if mr_info else None,
          "reason": inputs.reason,
          "timestamp": datetime.now().isoformat(),
      }

      patterns["mr_closures"].append(closure_record)

      # Keep last 50 closures
      patterns["mr_closures"] = patterns["mr_closures"][-50:]

      memory.write_memory("learned/patterns", patterns)
      result = "closure tracked"
    output: closure_tracking_result
    on_error: continue

  - name: remove_from_open_mrs
    description: "Remove closed MR from open_mrs in memory"
    condition: "close_status and close_status.success"
    compute: |
      # Remove from open_mrs
      current_work = memory.read_memory("state/current_work") or {}
      open_mrs = current_work.get("open_mrs", [])

      # Filter out this MR
      current_work["open_mrs"] = [
          m for m in open_mrs
          if str(m.get("id")) != str(inputs.mr_id)
      ]

      memory.write_memory("state/current_work", current_work)
      result = "MR removed from open_mrs"
    output: mr_removal_result
    on_error: continue

  # ==================== SEMANTIC SEARCH ====================

  - name: search_mr_code
    description: "Search for code related to the closed MR"
    tool: code_search
    args:
      query: "{{ mr_info.title if mr_info else '' }} {{ mr_info.jira_key if mr_info else '' }}"
      project: "automation-analytics-backend"
      limit: 3
    output: mr_code_raw
    on_error: continue

  - name: parse_mr_code
    description: "Parse MR code search results"
    condition: "mr_code_raw"
    compute: |
      code_result = mr_code_raw if mr_code_raw else {}

      related_code = []
      if isinstance(code_result, dict) and code_result.get('results'):
          for r in code_result.get('results', [])[:3]:
              related_code.append({
                  'file': r.get('file_path', ''),
                  'score': r.get('score', 0),
              })

      result = {
          'code': related_code,
          'count': len(related_code),
      }
    output: mr_code_analysis
    on_error: continue

outputs:
  - name: report
    value: |
      ## üö´ Close MR !{{ inputs.mr_id }}

      **Title:** {{ mr_info.title }}
      **Author:** {{ mr_info.author }}
      {% if mr_info.jira_key %}
      **Jira:** {{ mr_info.jira_key }}
      {% endif %}

      ---

      {% if close_status.success %}
      ‚úÖ **MR Closed Successfully**

      Reason: {{ inputs.reason }}

      {% if mr_info.jira_key and inputs.update_jira %}
      üìã Comment added to {{ mr_info.jira_key }}
      {% endif %}

      ---

      ### Need to Reopen?

      ```
      gitlab_mr_reopen(project='{{ inputs.project }}', mr_id={{ inputs.mr_id }})
      ```
      {% else %}
      ‚ùå **Failed to close MR**

      {{ close_status.message }}
      {% endif %}

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_close_failures
    description: "Detect failure patterns from MR closure"
    compute: |
      errors_detected = []

      # Check GitLab failures
      mr_text = str(mr_details_raw) if 'mr_details_raw' in dir() and mr_details_raw else ""
      close_text = str(close_result_raw) if 'close_result_raw' in dir() and close_result_raw else ""
      combined = mr_text + close_text

      if "no such host" in combined.lower():
          errors_detected.append({
              "tool": "gitlab_mr_close",
              "pattern": "no such host",
              "cause": "VPN not connected - internal GitLab not reachable",
              "fix": "Run vpn_connect() to connect to Red Hat VPN"
          })
      if "not found" in combined.lower() and "merge request" in combined.lower():
          errors_detected.append({
              "tool": "gitlab_mr_close",
              "pattern": "merge request not found",
              "cause": "MR ID doesn't exist or wrong project",
              "fix": "Check MR ID and project path"
          })
      if "already closed" in combined.lower():
          errors_detected.append({
              "tool": "gitlab_mr_close",
              "pattern": "already closed",
              "cause": "MR is already closed",
              "fix": "No action needed - MR was already closed"
          })

      result = errors_detected
    output: close_errors_detected
    on_error: continue

  - name: learn_close_vpn_failure
    description: "Learn from VPN failures"
    condition: "close_errors_detected and any(e.get('pattern') == 'no such host' for e in close_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "gitlab_mr_close"
      error_pattern: "no such host"
      root_cause: "VPN not connected - internal GitLab not reachable"
      fix_description: "Run vpn_connect() to connect to Red Hat VPN"
    output: close_vpn_fix_learned
    on_error: continue
