# Skill: Create Merge Request
# Creates a properly formatted MR with Jira link, validation, and quality checks

name: create_mr
description: |
  Create a merge request with full validation:
  - Automatically resolves repo and GitLab project from issue key if not provided
  - Checks for uncommitted changes
  - Validates commit message format (AAP-XXXXX)
  - Runs black/flake8 linting
  - Checks if branch can merge cleanly
  - Optionally runs jira_hygiene first
  - Creates MR with proper description
  - Links to Jira and updates status

  Uses MCP tools: git_status, git_fetch, git_log, git_push, gitlab_mr_list,
                  gitlab_mr_create, jira_view_issue, jira_add_comment, jira_set_status
version: "2.3"

inputs:
  - name: issue_key
    type: string
    required: true
    description: "Jira issue key for linking (e.g., AAP-12345)"

  - name: repo
    type: string
    required: false
    default: ""
    description: "Repository path - if not provided, resolved from issue key via config"

  - name: repo_name
    type: string
    required: false
    description: "Repository name from config (e.g., 'automation-analytics-backend')"

  - name: draft
    type: boolean
    required: false
    default: true
    description: "Create as draft MR"

  - name: target_branch
    type: string
    required: false
    default: ""
    description: "Target branch for MR (defaults to repo's default_branch from config)"

  - name: run_linting
    type: boolean
    required: false
    default: true
    description: "Run black/flake8 before creating MR"

  - name: check_jira
    type: boolean
    required: false
    default: true
    description: "Run jira_hygiene check before creating MR"

  - name: auto_fix_lint
    type: boolean
    required: false
    default: false
    description: "Auto-fix linting issues with black"

  - name: slack_format
    type: boolean
    required: false
    default: false
    description: "Use Slack link format"

  - name: check_docs
    type: boolean
    required: false
    default: true
    description: "Check documentation for staleness (if docs.check_on_mr=true in config)"

  - name: skip_docs_warning
    type: boolean
    required: false
    default: false
    description: "Skip documentation warnings (proceed even if docs need updating)"

# jira_url loaded from config.json in load_config step

steps:
  # ==================== RESOLVE REPOSITORY ====================

  - name: resolve_repo
    description: "Determine which repo and GitLab project to use"
    compute: |
      from scripts.common.repo_utils import resolve_repo
      from scripts.common.config_loader import load_config, get_team_config

      # Use centralized repository resolution
      # inputs is a dict in compute context, so use dict access
      resolved = resolve_repo(
          repo_path=inputs.get("repo") if inputs.get("repo") and inputs.get("repo") not in ("", ".") else None,
          repo_name=inputs.get("repo_name") if inputs.get("repo_name") else None,
          issue_key=inputs.get("issue_key"),
          target_branch=inputs.get("target_branch") if inputs.get("target_branch") else None,
      )

      # Get team config for mentions
      config = load_config()
      team_config = get_team_config()
      jira_url = config.get("jira", {}).get("url", "https://issues.redhat.com")

      result = {
          "path": resolved.path,
          "gitlab_project": resolved.gitlab_project or "automation-analytics/automation-analytics-backend",
          "default_branch": resolved.default_branch,
          "jira_url": jira_url,
          "team_group_id": team_config.get("team_group_id", ""),
          "team_group_handle": team_config.get("team_group_handle", "aa-api-team"),
      }
    output: resolved_repo

  # ==================== PRE-FLIGHT CHECKS ====================

  # Step 1: Check git status using MCP tool
  - name: check_git_status
    description: "Check for uncommitted changes and git state"
    tool: git_status
    args:
      repo: "{{ resolved_repo.path }}"
    output: git_status_raw
    on_error: continue

  - name: validate_git_status
    description: "Parse git status for issues"
    compute: |
      import os
      from scripts.common.parsers import extract_current_branch

      repo = resolved_repo["path"]
      status_output = str(git_status_raw) if git_status_raw else ""

      # Check for rebase/merge in progress
      git_dir = os.path.join(repo, ".git")
      if os.path.exists(os.path.join(git_dir, "rebase-merge")):
          raise ValueError("Rebase in progress. Run 'git rebase --continue' or '--abort'")
      if os.path.exists(os.path.join(git_dir, "MERGE_HEAD")):
          raise ValueError("Merge in progress. Run 'git merge --continue' or '--abort'")

      # Check for uncommitted changes
      if "Changes not staged" in status_output or "Changes to be committed" in status_output:
          raise ValueError("Uncommitted changes detected. Please commit or stash before creating MR.")

      # Extract current branch using shared parser
      branch = extract_current_branch(status_output)

      if not branch or branch == "HEAD":
          raise ValueError("Detached HEAD state. Checkout a branch first.")

      if branch in ["main", "master"]:
          raise ValueError("Cannot create MR from main/master. Create a feature branch first.")

      issue_key = inputs.get("issue_key", "").upper()

      # Validate branch name format per .gitlab-ci.yml validate-mr job
      # Required pattern: ^aap-[0-9]{3,6} at start of branch name (case insensitive)
      import re
      branch_pattern = r"^aap-\d{3,6}"
      if not re.match(branch_pattern, branch, re.IGNORECASE):
          raise ValueError(
              f"Branch name '{branch}' does not match required CI pattern.\n"
              f"Branch must start with 'AAP-XXXXX' (e.g., 'AAP-61699-description').\n"
              f"Use 'git branch -m {issue_key}-description' to rename."
          )

      result = {
          "name": branch,
          "has_issue_key": issue_key in branch.upper(),
          "issue_key": issue_key,
      }
    output: current_branch

  # Step 2: Fetch latest using MCP tool
  - name: fetch_origin
    description: "Fetch latest from origin"
    tool: git_fetch
    args:
      repo: "{{ resolved_repo.path }}"
      prune: true
    output: fetch_result
    on_error: continue

  # Step 3: Validate commits using MCP tool
  - name: get_commit_log
    description: "Get commits ahead of target branch"
    tool: git_log
    args:
      repo: "{{ resolved_repo.path }}"
      limit: 20
      oneline: true
    output: commit_log_raw
    on_error: continue

  - name: validate_commits
    description: "Check commit messages follow config.json commit_format pattern"
    compute: |
      from scripts.common.config_loader import get_commit_format, validate_commit_message
      from scripts.common.parsers import extract_jira_key

      issue_key = inputs.get("issue_key", "").upper()
      commit_cfg = get_commit_format()

      commits = []
      bad_commits = []
      format_issues = []

      if commit_log_raw:
        for line in str(commit_log_raw).split('\n'):
          if line.strip():
            commits.append(line.strip())
            # Check if commit message follows the config pattern
            is_valid, issues = validate_commit_message(line)
            if not is_valid:
              bad_commits.append(line)
              format_issues.extend(issues[:1])  # Only first issue per commit

      if not commits:
          raise ValueError(
              f"No commits found. Make some commits first."
          )

      warnings = []
      if bad_commits:
          warnings.append(f"‚ö†Ô∏è {len(bad_commits)} commit(s) don't match format: {commit_cfg['pattern']}")

      result = {
          "count": len(commits),
          "commits": commits[:10],
          "bad_commits": bad_commits[:5],
          "warnings": warnings,
          "format_issues": format_issues[:5],
      }
    output: commit_validation

  # Step 4: Test merge to check for conflicts
  - name: test_merge
    description: "Test if branch can merge cleanly"
    tool: git_merge
    args:
      repo: "{{ resolved_repo.path }}"
      target: "origin/{{ resolved_repo.default_branch }}"
      no_commit: true
      no_ff: true
    output: merge_test_raw
    on_error: continue

  # Abort the test merge
  - name: abort_test_merge
    description: "Abort the test merge"
    tool: git_merge_abort
    args:
      repo: "{{ resolved_repo.path }}"
    output: abort_result
    on_error: continue

  # Parse merge result
  - name: parse_merge_result
    description: "Determine if branch is mergeable"
    compute: |
      merge_text = str(merge_test_raw) if 'merge_test_raw' in dir() and merge_test_raw else ""
      target = resolved_repo.get("default_branch", "main")

      has_conflicts = "conflict" in merge_text.lower() or "‚ùå" in merge_text

      if has_conflicts:
        result = {
          "mergeable": False,
          "message": f"Branch has conflicts with {target}. Rebase needed.",
        }
      else:
        result = {"mergeable": True, "message": "Branch can merge cleanly"}
    output: merge_check

  # Step 4b: Read .gitlab-ci.yml to understand CI configuration
  - name: read_ci_config
    description: "Read GitLab CI configuration to understand pipeline"
    tool: gitlab_file_read
    args:
      project: "{{ resolved_repo.gitlab_project }}"
      file_path: ".gitlab-ci.yml"
      ref: "{{ resolved_repo.default_branch }}"
    output: ci_config_raw
    on_error: continue

  - name: parse_ci_config
    description: "Parse CI config for key jobs"
    compute: |
      ci_text = str(ci_config_raw) if 'ci_config_raw' in dir() and ci_config_raw else ""

      # Skip if error or not found
      if "error" in ci_text.lower() or "not found" in ci_text.lower():
          result = {"found": False, "jobs": [], "stages": []}
      else:
          # Extract stages and jobs
          import re

          stages = []
          stage_match = re.search(r'stages:\s*\n((?:\s+-\s+\w+\n?)+)', ci_text)
          if stage_match:
              stages = re.findall(r'-\s+(\w+)', stage_match.group(1))

          # Find job names (lines ending with :)
          jobs = []
          for line in ci_text.split("\n"):
              if line and not line.startswith(" ") and line.endswith(":") and not line.startswith("."):
                  job_name = line.rstrip(":")
                  if job_name not in ["stages", "variables", "include", "default", "workflow"]:
                      jobs.append(job_name)

          result = {
              "found": True,
              "jobs": jobs[:10],
              "stages": stages[:8],
              "has_tests": any("test" in j.lower() for j in jobs),
              "has_lint": any("lint" in j.lower() for j in jobs),
          }
    output: ci_config
    on_error: continue

  # Step 5: Check for existing MR using MCP tool
  - name: check_existing_mr
    description: "Check if MR already exists for this branch"
    tool: gitlab_mr_list
    args:
      project: "{{ resolved_repo.gitlab_project }}"
    output: existing_mrs_raw
    on_error: continue

  - name: detect_duplicate_mr
    description: "Parse MRs to find duplicate using shared parser"
    compute: |
      from scripts.common.parsers import extract_mr_id_from_text

      branch = current_branch["name"]
      existing_mrs_text = str(existing_mrs_raw) if existing_mrs_raw else ""

      duplicate = None
      for line in existing_mrs_text.split("\n"):
          if branch.lower() in line.lower():
              mr_id = extract_mr_id_from_text(line)
              if mr_id:
                  duplicate = {"iid": mr_id, "line": line.strip()[:80]}
                  break

      if duplicate:
          result = {
              "exists": True,
              "mr_iid": duplicate["iid"],
              "message": f"MR !{duplicate['iid']} already exists for branch '{branch}'.",
          }
      else:
          result = {"exists": False, "message": "No existing MR found"}
    output: duplicate_check

  # ==================== LINTING ====================

  - name: check_lint_tools
    description: "Check if black and flake8 are installed"
    condition: "inputs.run_linting"
    compute: |
      import shutil

      missing = []
      if not shutil.which("black"):
          missing.append("black")
      if not shutil.which("flake8"):
          missing.append("flake8")

      result = {
          "available": not missing,
          "missing": missing,
          "message": f"Missing: {missing}" if missing else "OK",
      }
    output: lint_tools_check

  - name: run_black
    description: "Run black formatter check"
    condition: "inputs.run_linting and (not lint_tools_check or lint_tools_check.get('available', True))"
    tool: code_format
    args:
      repo: "{{ resolved_repo.path }}"
      tool: "black"
      check_only: "{{ not inputs.auto_fix_lint }}"
    output: black_raw
    on_error: continue

  - name: parse_black_result
    description: "Parse black result"
    condition: "inputs.run_linting"
    compute: |
      output = str(black_raw) if black_raw else ""

      if "‚úÖ" in output:
        if "check passed" in output.lower():
          black_result = {"passed": True, "message": "Black check passed", "blocking": False}
        else:
          black_result = {"passed": True, "fixed": True, "message": "Black applied fixes", "blocking": False}
      else:
        black_result = {"passed": False, "message": "Files need formatting. Run 'black .'", "blocking": True}

      result = black_result
    output: black_result

  - name: block_on_black_errors
    description: "Block MR creation if black formatting needed"
    condition: "inputs.run_linting and black_result and black_result.get('blocking', False)"
    compute: |
      raise ValueError(
        "‚ùå Code formatting issues detected.\n\n"
        "Run 'black .' to fix formatting, then commit the changes.\n"
        "Or use: skill_run('create_mr', '{\"auto_fix_lint\": true, ...}') to auto-fix."
      )
    output: black_block

  - name: get_changed_files
    description: "Get list of Python files changed in this branch"
    condition: "inputs.run_linting"
    compute: |
      import subprocess

      repo = resolved_repo["path"]
      target = resolved_repo.get("default_branch", "main")

      # Get list of changed Python files compared to target branch
      cmd = ["git", "-C", repo, "diff", "--name-only", f"origin/{target}...HEAD", "--", "*.py"]
      try:
          output = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
          files = [f.strip() for f in output.stdout.strip().split('\n') if f.strip()]
          result = {"files": files, "count": len(files)}
      except Exception as e:
          result = {"files": [], "count": 0, "error": str(e)}
    output: changed_files

  - name: run_flake8
    description: "Run flake8 linting on changed files only"
    condition: "inputs.run_linting and changed_files and changed_files.get('count', 0) > 0"
    tool: code_lint
    args:
      repo: "{{ resolved_repo.path }}"
      tool: "flake8"
      files: "{{ ' '.join(changed_files.files) }}"
      max_line_length: 100
      ignore: "E501,W503,E203"
    output: flake8_raw
    on_error: continue

  - name: parse_flake8
    description: "Parse flake8 result and block if issues found"
    condition: "inputs.run_linting"
    compute: |
      raw = str(flake8_raw) if 'flake8_raw' in dir() and flake8_raw else ""
      file_count = changed_files.get("count", 0) if 'changed_files' in dir() else 0

      if file_count == 0:
        flake8_result = {"passed": True, "message": "No Python files changed", "issues": [], "blocking": False}
      elif 'passed' in raw.lower() or 'no issues' in raw.lower() or '‚úÖ' in raw or not raw.strip():
        flake8_result = {"passed": True, "message": f"Flake8 passed ({file_count} files)", "issues": [], "blocking": False}
      else:
        # Extract issues from output - look for typical flake8 format
        # Common error/warning codes that indicate real issues
        error_codes = ['F', 'E', 'W', 'C']  # All flake8 codes
        issues = []
        for line in raw.split('\n'):
          line = line.strip()
          if ':' in line and any(code in line for code in error_codes):
            # Skip ignored codes (E501=line length, W503=line break, E203=whitespace)
            if not any(skip in line for skip in ['E501', 'W503', 'E203']):
              issues.append(line)
        issues = issues[:15]

        # Block on ANY remaining issues (after ignoring the allowed ones)
        flake8_result = {
          "passed": len(issues) == 0,
          "message": f"{len(issues)} flake8 issue(s) in changed files" if issues else "Flake8 passed",
          "issues": issues,
          "blocking": len(issues) > 0,
        }

      result = flake8_result
    output: flake8_result

  - name: block_on_lint_errors
    description: "Block MR creation if there are lint errors"
    condition: "inputs.run_linting and flake8_result and flake8_result.get('blocking', False)"
    compute: |
      issues = flake8_result.get("issues", [])
      issue_text = "\n".join(f"  - {i}" for i in issues[:10])

      raise ValueError(
        f"‚ùå Lint errors found. Fix before creating MR:\n{issue_text}\n\n"
        "Run: pipenv run flake8 <files> to see all issues\n"
        "Or: black . && isort . to auto-format"
      )
    output: lint_block

  # ==================== DOCUMENTATION CHECK ====================

  - name: check_docs_config
    description: "Check if docs should be checked for this repo"
    condition: "inputs.check_docs"
    compute: |
      from scripts.common.config_loader import load_config

      config = load_config()
      repos = config.get("repositories", {})

      # Find repo config by path
      docs_config = None
      for key, cfg in repos.items():
          if cfg.get("path") == resolved_repo["path"]:
              docs_config = cfg.get("docs", {})
              break

      should_check = docs_config and docs_config.get("enabled", False) and docs_config.get("check_on_mr", True)

      result = {
          "should_check": should_check,
          "docs_config": docs_config or {},
      }
    output: docs_config_check

  - name: run_docs_check
    description: "Run documentation check skill"
    condition: "inputs.check_docs and docs_config_check and docs_config_check.should_check"
    tool: skill_run
    args:
      skill_name: update_docs
      inputs: '{"repo": "{{ resolved_repo.path }}", "issue_key": "{{ inputs.issue_key }}", "check_only": true}'
      execute: true
    output: docs_check_result
    on_error: continue

  - name: parse_docs_result
    description: "Parse documentation check results"
    condition: "inputs.check_docs and docs_config_check and docs_config_check.should_check"
    compute: |
      result_text = str(docs_check_result) if 'docs_check_result' in dir() and docs_check_result else ""

      needs_attention = "Issues Found" in result_text or "Suggestions" in result_text
      has_issues = "‚ùå" in result_text

      result = {
          "needs_attention": needs_attention,
          "has_issues": has_issues,
          "warning_shown": needs_attention,
      }
    output: docs_result

  - name: warn_about_docs
    description: "Warn about documentation issues (non-blocking)"
    condition: "inputs.check_docs and docs_result and docs_result.needs_attention and not inputs.skip_docs_warning"
    compute: |
      # This is a warning, not a blocker
      # The user can proceed but should be aware
      result = {
          "warning": "üìö Documentation may need updating. Review the docs check output above.",
          "action": "Consider updating docs before marking MR as ready for review.",
      }
    output: docs_warning

  # ==================== JIRA INTEGRATION ====================

  - name: get_issue
    description: "Fetch Jira issue details"
    tool: jira_view_issue
    args:
      issue_key: "{{ inputs.issue_key }}"
    output: issue
    on_error: continue

  - name: jira_hygiene_check
    description: "Check Jira issue quality"
    condition: "inputs.check_jira and issue"
    tool: skill_run
    args:
      skill_name: jira_hygiene
      inputs: '{"issue_key": "{{ inputs.issue_key }}", "auto_fix": true}'
    output: jira_check
    on_error: continue

  # ==================== VALIDATE CI CONFIG ====================

  - name: lint_ci_config
    description: "Validate .gitlab-ci.yml before creating MR"
    tool: gitlab_ci_lint
    args:
      project: "{{ resolved_repo.gitlab_project }}"
    output: ci_lint_raw
    on_error: continue

  - name: parse_ci_lint
    description: "Parse CI lint result"
    compute: |
      lint_text = str(ci_lint_raw) if 'ci_lint_raw' in dir() and ci_lint_raw else ""

      valid = "valid" in lint_text.lower() and "invalid" not in lint_text.lower()
      has_errors = "error" in lint_text.lower()

      result = {
        "valid": valid,
        "has_errors": has_errors,
        "message": lint_text[:200] if lint_text else "",
      }
    output: ci_lint_result
    on_error: continue

  # ==================== CREATE MR ====================

  - name: push_branch
    description: "Push branch to origin"
    tool: git_push
    args:
      repo: "{{ resolved_repo.path }}"
      branch: "{{ current_branch.name }}"
      set_upstream: true
    output: push_result
    on_error: continue
    # NOTE: Auto-heal is now handled by @auto_heal() decorator on the tool

  - name: detect_commit_type
    description: "Detect predominant commit type from commits"
    compute: |
      from scripts.common.config_loader import get_commit_format
      import re

      commit_cfg = get_commit_format()
      valid_types = commit_cfg["types"]

      # Count commit types from the validated commits
      type_counts = {t: 0 for t in valid_types}

      for commit in commit_validation.get("commits", []):
        # Extract type from commit message: AAP-12345 - type: or AAP-12345 - type(scope):
        match = re.search(r'-\s*(\w+)(?:\([^)]+\))?\s*:', commit)
        if match:
          ctype = match.group(1).lower()
          if ctype in type_counts:
            type_counts[ctype] += 1

      # Find the most common type, default to feat
      predominant_type = max(type_counts, key=type_counts.get) if any(type_counts.values()) else "feat"

      # If no types detected from commits, infer from issue summary
      if not any(type_counts.values()):
        issue_text = (str(issue) if issue else "").lower()
        if any(w in issue_text for w in ["fix", "bug", "error", "issue"]):
          predominant_type = "fix"
        elif any(w in issue_text for w in ["refactor", "clean", "improve"]):
          predominant_type = "refactor"
        elif any(w in issue_text for w in ["doc", "documentation"]):
          predominant_type = "docs"
        elif any(w in issue_text for w in ["test"]):
          predominant_type = "test"

      result = predominant_type
    output: mr_commit_type

  - name: build_description
    description: "Build MR description with Jira link"
    compute: |
      import textwrap

      jira_url = resolved_repo.get("jira_url", "https://issues.redhat.com")
      issue_key = inputs.get("issue_key", "").upper()
      issue_text = str(issue) if issue else ""
      summary_match = issue_text[:100] if issue_text else "No description"

      description = textwrap.dedent(f"""
          ## Summary
          {summary_match}

          ## Jira
          [{issue_key}]({jira_url}/browse/{issue_key})

          ## Changes
          - Commits: {commit_validation.get("count", 0)}

          ## Testing
          - [ ] Unit tests pass
          - [ ] Integration tests pass
          - [ ] Manual testing completed

          ## Checklist
          - [ ] Code follows project conventions
          - [ ] Documentation updated if needed
          - [ ] No secrets or sensitive data
      """).strip()

      result = description
    output: mr_description

  - name: build_mr_title
    description: "Build MR title following commit format from config.json"
    compute: |
      from scripts.common.config_loader import format_commit_message

      issue_key = inputs.get("issue_key", "").upper()
      issue_summary = str(issue.get("summary", "Update") if issue and isinstance(issue, dict) else issue)[:50] if issue else "Update"
      commit_type = mr_commit_type if mr_commit_type else "feat"

      # Use the centralized formatter (scope is optional for MR titles)
      title = format_commit_message(
        description=issue_summary,
        issue_key=issue_key,
        commit_type=commit_type,
        scope="",  # MR titles typically don't have scope
      )
      result = title
    output: mr_title

  - name: create_mr
    description: "Create GitLab merge request"
    tool: gitlab_mr_create
    args:
      project: "{{ resolved_repo.gitlab_project }}"
      title: "{{ mr_title }}"
      description: "{{ mr_description }}"
      target_branch: "{{ resolved_repo.default_branch }}"
      source_branch: "{{ current_branch.name }}"
      draft: "{{ inputs.draft }}"
    output: mr

  - name: update_jira
    description: "Add MR link to Jira issue"
    condition: "mr"
    tool: jira_add_comment
    args:
      issue_key: "{{ inputs.issue_key }}"
      comment: |
        MR created: {{ mr.web_url }}
        Branch: {{ current_branch.name }}
        Status: {{ "Draft" if inputs.draft else "Ready for Review" }}
    on_error: continue

  - name: update_status
    description: "Move Jira to In Review (if not draft)"
    condition: "not inputs.draft and mr"
    tool: jira_set_status
    args:
      issue_key: "{{ inputs.issue_key }}"
      status: "In Review"
    on_error: continue

  # ==================== SLACK NOTIFICATION ====================

  - name: notify_team_about_mr
    description: "Use notify_mr skill to post to team channel"
    condition: "mr and not inputs.draft"
    tool: skill_run
    args:
      skill_name: notify_mr
      inputs: '{"mr_id": "{{ mr.iid }}", "issue_key": "{{ inputs.issue_key }}"}'
      execute: true
    output: slack_notification
    on_error: continue

  - name: emit_mr_created_hook
    description: "Notify team channel about new MR"
    condition: "mr and not inputs.draft"
    compute: |
      # emit_event is available from skill engine safe_globals
      if emit_event:
          emit_event("mr_created", {
              "mr_id": str(mr.get('iid', '')),
              "issue_key": inputs.issue_key,
              "project": resolved_repo.get("gitlab_project", ""),
          })
          result = "hook sent"
      else:
          result = "hook skipped: emit_event not available"
    output: mr_hook_result
    on_error: continue

  # ==================== MEMORY INTEGRATION ====================

  - name: build_memory_context
    description: "Build context for memory update"
    condition: "mr"
    compute: |
      from datetime import datetime

      result = {
        "timestamp": datetime.now().isoformat(),
        "mr_iid": mr.get("iid", ""),
        "mr_title": mr.get("title", "")[:60],
        "mr_url": mr.get("web_url", ""),
      }
    output: memory_context

  - name: log_session_mr_created
    description: "Log MR creation to session log"
    condition: "mr"
    tool: memory_session_log
    args:
      action: "Created MR !{{ memory_context.mr_iid }} for {{ inputs.issue_key }}"
      details: "{{ memory_context.mr_url }}"
    on_error: continue

  - name: add_mr_to_memory
    description: "Add MR to open_mrs in memory"
    condition: "mr"
    tool: memory_append
    args:
      key: "state/current_work"
      list_path: "open_mrs"
      item: |
        id: {{ memory_context.mr_iid }}
        project: "{{ resolved_repo.gitlab_project }}"
        title: "{{ memory_context.mr_title }}"
        url: "{{ memory_context.mr_url }}"
        issue_key: "{{ inputs.issue_key }}"
        pipeline_status: pending
        needs_review: {{ 'false' if inputs.draft else 'true' }}
        is_draft: {{ 'true' if inputs.draft else 'false' }}
        created: "{{ memory_context.timestamp }}"
    on_error: continue

  - name: update_active_issue_status
    description: "Update active issue status if MR is not draft"
    condition: "mr and not inputs.draft"
    tool: memory_update
    args:
      key: "state/current_work"
      path: "last_updated"
      value: "{{ memory_context.timestamp }}"
    on_error: continue

outputs:
  - name: summary
    value: |
      {% set is_slack = inputs.slack_format | default(true) %}
      ## {{ "‚úÖ" if mr else "‚ùå" }} Merge Request {{ "Created" if mr else "Failed" }}

      {% if mr %}
      {% if is_slack %}
      **MR:** <{{ mr.web_url }}|{{ mr.title }}>
      {% else %}
      **MR:** [{{ mr.title }}]({{ mr.web_url }})
      {% endif %}
      **URL:** {{ mr.web_url }}
      **Status:** {{ "Draft" if inputs.draft else "Ready for Review" }}
      **Branch:** `{{ current_branch.name }}` ‚Üí `{{ resolved_repo.default_branch }}`
      {% endif %}

      ---

      ### Pre-flight Checks

      | Check | Status |
      |-------|--------|
      | Commits | {{ commit_validation.count }} commit(s) |
      | Commit format | {{ "‚ö†Ô∏è " + commit_validation.warnings[0] if commit_validation.warnings else "‚úÖ OK" }} |
      | Merge conflicts | {{ "‚ùå Has conflicts" if not merge_check.mergeable else "‚úÖ Mergeable" }} |
      {% if inputs.run_linting %}
      | Black | {{ "‚úÖ Passed" if black_result and black_result.passed else "‚ö†Ô∏è " + (black_result.message if black_result else "Skipped") }} |
      | Flake8 | {{ "‚úÖ Passed" if flake8_result and flake8_result.passed else "‚ö†Ô∏è " + (flake8_result.message if flake8_result else "Skipped") }} |
      {% endif %}
      {% if inputs.check_docs and docs_config_check and docs_config_check.should_check %}
      | Docs | {{ "‚ö†Ô∏è Needs attention" if docs_result and docs_result.needs_attention else "‚úÖ OK" }} |
      {% endif %}

      {% if not merge_check.mergeable %}
      ---
      ### ‚ö†Ô∏è Action Required
      {{ merge_check.message }}
      {% endif %}

      {% if docs_warning and docs_warning.warning %}
      ---
      ### üìö Documentation
      {{ docs_warning.warning }}
      {{ docs_warning.action }}
      {% endif %}

      {% if mr %}
      ---
      ### Next Steps
      {% if inputs.draft %}
      1. Complete your changes
      2. Push updates: `git push`
      3. Mark as ready when done
      {% else %}
      1. Wait for pipeline to complete
      2. Request review from teammates
      {% endif %}
      {% endif %}

  - name: context
    value:
      mr_url: "{{ mr.web_url if mr else none }}"
      mr_id: "{{ mr.iid if mr else none }}"
      branch: "{{ current_branch.name }}"
      repo: "{{ resolved_repo.path }}"
      gitlab_project: "{{ resolved_repo.gitlab_project }}"
      mergeable: "{{ merge_check.mergeable }}"
