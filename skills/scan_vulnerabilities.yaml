# Skill: Scan Container Image Vulnerabilities
# Security scan before release or deployment

name: scan_vulnerabilities
description: |
  Scan a container image for security vulnerabilities before deployment.

  Uses Quay.io vulnerability scanning and optional local security tools.

  Steps:
  1. Verify image exists in Quay
  2. Get vulnerability report from Quay
  3. Analyze severity and count
  4. Provide recommendations

  Useful before:
  - Releasing to production
  - Deploying to ephemeral
  - Approving MRs with image changes
version: "1.0"

inputs:
  - name: image_tag
    type: string
    required: true
    description: "Image tag (commit SHA or version) to scan"

  - name: repository
    type: string
    required: false
    default: "aap-aa-tenant/aap-aa-main/automation-analytics-backend-main"
    description: "Quay repository path"

  - name: namespace
    type: string
    required: false
    default: "redhat-user-workloads"
    description: "Quay namespace (redhat-user-workloads for PR, redhat-services-prod for releases)"

  - name: fail_on_critical
    type: boolean
    required: false
    default: true
    description: "Return error if critical vulnerabilities found"

  - name: fail_on_high
    type: boolean
    required: false
    default: false
    description: "Return error if high severity vulnerabilities found"

steps:
  # ==================== KNOWLEDGE INTEGRATION ====================

  - name: check_security_known_issues
    description: "Check for known security/vulnerability issues"
    compute: |
      # Check known issues for security operations
      security_issues = memory.check_known_issues("security", "") or {}
      quay_issues = memory.check_known_issues("quay", "") or {}
      vuln_issues = memory.check_known_issues("vulnerability", "") or {}

      all_issues = []
      for issues in [security_issues, quay_issues, vuln_issues]:
          if issues and issues.get("matches"):
              all_issues.extend(issues.get("matches", [])[:2])

      result = {
          "has_known_issues": len(all_issues) > 0,
          "issues": all_issues[:5],
      }
    output: security_known_issues
    on_error: continue

  - name: get_security_gotchas
    description: "Get security-related gotchas from knowledge"
    tool: knowledge_query
    args:
      project: "automation-analytics-backend"
      persona: "devops"
      section: "gotchas"
    output: security_gotchas_raw
    on_error: continue

  - name: parse_security_gotchas
    description: "Parse security-related gotchas"
    compute: |
      gotchas_result = security_gotchas_raw if 'security_gotchas_raw' in dir() and security_gotchas_raw else {}

      security_gotchas = []
      if isinstance(gotchas_result, dict) and gotchas_result.get('found'):
          content = gotchas_result.get('content', [])
          if isinstance(content, list):
              # Filter for security-related gotchas
              for g in content:
                  g_str = str(g).lower()
                  if any(kw in g_str for kw in ['security', 'cve', 'vulnerability', 'scan', 'image', 'quay']):
                      security_gotchas.append(g)

      result = {
          'gotchas': security_gotchas[:5],
          'has_gotchas': len(security_gotchas) > 0,
      }
    output: scan_gotchas
    on_error: continue

  # ==================== VERIFY IMAGE ====================

  - name: check_image_exists
    description: "Verify the image exists in Quay"
    tool: quay_check_image_exists
    args:
      repository: "{{ inputs.repository }}"
      tag: "{{ inputs.image_tag }}"
    on_error: auto_heal  # Quay API - may need auth

  - name: validate_image
    description: "Stop if image doesn't exist"
    compute: |
      check_text = str(image_check) if image_check else ""

      if "not found" in check_text.lower() or "error" in check_text.lower():
          result = {
              "exists": False,
              "error": f"Image not found: {inputs.namespace}/{inputs.repository}:{inputs.image_tag}"
          }
      else:
          result = {"exists": True, "error": None}
    output: image_status

  # ==================== GET VULNERABILITIES ====================

  - name: get_vulnerabilities
    description: "Fetch vulnerability report from Quay"
    condition: "image_status.exists"
    tool: quay_get_vulnerabilities
    args:
      repository: "{{ inputs.repository }}"
      tag: "{{ inputs.image_tag }}"
      namespace: "{{ inputs.namespace }}"
    output: vuln_raw
    on_error: auto_heal  # Quay API - may need auth

  - name: get_manifest
    description: "Get image manifest for metadata"
    condition: "image_status.exists"
    tool: quay_get_manifest
    args:
      repository: "{{ inputs.repository }}"
      tag: "{{ inputs.image_tag }}"
      namespace: "{{ inputs.namespace }}"
    output: manifest_raw
    on_error: auto_heal  # Quay API - may need auth

  # ==================== ANALYZE RESULTS ====================

  - name: parse_vulnerabilities
    description: "Parse and categorize vulnerabilities"
    condition: "image_status.exists"
    compute: |
      vuln_text = str(vuln_raw) if vuln_raw else ""

      # Count by severity
      critical = vuln_text.lower().count("critical")
      high = vuln_text.lower().count("high")
      medium = vuln_text.lower().count("medium")
      low = vuln_text.lower().count("low")

      # Extract CVE IDs
      import re
      cves = re.findall(r'CVE-\d{4}-\d+', vuln_text)
      unique_cves = list(set(cves))[:20]

      # Determine overall status
      if critical > 0:
          status = "critical"
          icon = "üî¥"
      elif high > 0:
          status = "high"
          icon = "üü†"
      elif medium > 0:
          status = "medium"
          icon = "üü°"
      elif low > 0:
          status = "low"
          icon = "üü¢"
      else:
          status = "clean"
          icon = "‚úÖ"

      total = critical + high + medium + low

      result = {
          "critical": critical,
          "high": high,
          "medium": medium,
          "low": low,
          "total": total,
          "status": status,
          "icon": icon,
          "cves": unique_cves,
          "raw_sample": vuln_text[:1000] if vuln_text else "No data",
      }
    output: vuln_analysis

  - name: parse_manifest
    description: "Extract manifest metadata"
    condition: "image_status.exists"
    compute: |
      manifest_text = str(manifest_raw) if manifest_raw else ""

      # Try to extract digest
      import re
      digest_match = re.search(r'sha256:[a-f0-9]{64}', manifest_text)
      digest = digest_match.group(0) if digest_match else None

      # Try to extract size
      size_match = re.search(r'(\d+)\s*(MB|GB|bytes)', manifest_text, re.I)
      size = size_match.group(0) if size_match else "unknown"

      result = {
          "digest": digest,
          "size": size,
      }
    output: manifest_info
    on_error: continue

  # ==================== DETERMINE ACTION ====================

  - name: evaluate_policy
    description: "Check against security policy"
    condition: "image_status.exists"
    compute: |
      blocked = False
      block_reason = None

      if inputs.fail_on_critical and vuln_analysis.get("critical", 0) > 0:
          blocked = True
          block_reason = f"Found {vuln_analysis['critical']} critical vulnerabilities"
      elif inputs.fail_on_high and vuln_analysis.get("high", 0) > 0:
          blocked = True
          block_reason = f"Found {vuln_analysis['high']} high severity vulnerabilities"

      result = {
          "blocked": blocked,
          "block_reason": block_reason,
          "safe_to_deploy": not blocked and vuln_analysis.get("critical", 0) == 0,
      }
    output: policy_result

  # ==================== SEMANTIC SEARCH ====================

  - name: search_security_code
    description: "Search for security-related code if vulnerabilities found"
    condition: "vuln_analysis and vuln_analysis.critical > 0 and vuln_analysis.cves"
    tool: code_search
    args:
      query: "security vulnerability CVE dependency {{ vuln_analysis.cves[0] if vuln_analysis.cves else '' }}"
      project: "automation-analytics-backend"
      limit: 5
    output: security_code_raw
    on_error: continue

  - name: parse_security_code
    description: "Parse security code search results"
    condition: "security_code_raw"
    compute: |
      code_result = security_code_raw if security_code_raw else {}

      related_code = []
      if isinstance(code_result, dict) and code_result.get('results'):
          for r in code_result.get('results', [])[:5]:
              related_code.append({
                  'file': r.get('file_path', ''),
                  'score': r.get('score', 0),
                  'preview': r.get('code_chunk', '')[:100] if r.get('code_chunk') else '',
              })

      result = {
          'code': related_code,
          'count': len(related_code),
          'has_related_code': len(related_code) > 0,
      }
    output: security_code_analysis
    on_error: continue

  # ==================== MEMORY ====================

  - name: log_scan
    description: "Log security scan to session"
    tool: memory_session_log
    args:
      action: "Security scan: {{ inputs.image_tag[:12] }}"
      details: "{{ vuln_analysis.icon }} {{ vuln_analysis.status }} - {{ vuln_analysis.total }} vulns ({{ vuln_analysis.critical }} critical)"
    on_error: continue

  - name: track_vulnerability_scans
    description: "Track vulnerability scans for patterns"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "vulnerability_scans" not in patterns:
          patterns["vulnerability_scans"] = []

      # Record this scan
      scan_record = {
          "image_tag": inputs.image_tag[:40],
          "repository": inputs.repository,
          "namespace": inputs.namespace,
          "critical": vuln_analysis.critical if vuln_analysis else 0,
          "high": vuln_analysis.high if vuln_analysis else 0,
          "total": vuln_analysis.total if vuln_analysis else 0,
          "status": vuln_analysis.status if vuln_analysis else "unknown",
          "blocked": policy_result.blocked if policy_result else False,
          "cves": vuln_analysis.cves[:5] if vuln_analysis and vuln_analysis.cves else [],
          "timestamp": datetime.now().isoformat(),
      }

      patterns["vulnerability_scans"].append(scan_record)

      # Keep last 100 scans
      patterns["vulnerability_scans"] = patterns["vulnerability_scans"][-100:]

      memory.write_memory("learned/patterns", patterns)
      result = "scan tracked"
    output: scan_tracking_result
    on_error: continue

  - name: track_recurring_cves
    description: "Track CVEs that appear frequently"
    condition: "vuln_analysis and vuln_analysis.cves"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "recurring_cves" not in patterns:
          patterns["recurring_cves"] = {}

      # Track each CVE
      for cve in (vuln_analysis.cves or [])[:10]:
          if cve not in patterns["recurring_cves"]:
              patterns["recurring_cves"][cve] = {
                  "count": 0,
                  "first_seen": datetime.now().isoformat(),
                  "last_seen": datetime.now().isoformat(),
                  "images": [],
              }

          patterns["recurring_cves"][cve]["count"] += 1
          patterns["recurring_cves"][cve]["last_seen"] = datetime.now().isoformat()

          # Track which images have this CVE
          image_key = f"{inputs.repository}:{inputs.image_tag[:12]}"
          if image_key not in patterns["recurring_cves"][cve]["images"]:
              patterns["recurring_cves"][cve]["images"].append(image_key)
              patterns["recurring_cves"][cve]["images"] = patterns["recurring_cves"][cve]["images"][-10:]

      memory.write_memory("learned/patterns", patterns)
      result = "recurring CVEs tracked"
    output: cve_tracking_result
    on_error: continue

  - name: update_security_state
    description: "Update security state in memory"
    compute: |
      from datetime import datetime

      # Update security state
      state_data = memory.read_memory("state/security") or {}
      if "recent_scans" not in state_data:
          state_data["recent_scans"] = []

      state_data["recent_scans"].append({
          "image": f"{inputs.repository}:{inputs.image_tag[:12]}",
          "status": vuln_analysis.status if vuln_analysis else "unknown",
          "critical": vuln_analysis.critical if vuln_analysis else 0,
          "blocked": policy_result.blocked if policy_result else False,
          "timestamp": datetime.now().isoformat(),
      })

      # Keep last 50 scans
      state_data["recent_scans"] = state_data["recent_scans"][-50:]

      # Track if we have any blocked images
      state_data["has_blocked_images"] = any(s.get("blocked") for s in state_data["recent_scans"][-10:])

      memory.write_memory("state/security", state_data)
      result = "security state updated"
    output: security_state_result
    on_error: continue

outputs:
  - name: report
    value: |
      ## üîí Security Scan Report

      **Image:** `{{ inputs.namespace }}/{{ inputs.repository }}:{{ inputs.image_tag[:12] }}`
      {% if manifest_info and manifest_info.digest %}
      **Digest:** `{{ manifest_info.digest[:20] }}...`
      {% endif %}

      ---

      {% if not image_status.exists %}
      ### ‚ùå Image Not Found

      {{ image_status.error }}

      Check the image exists:
      ```python
      quay_check_image_exists(repository='{{ inputs.repository }}', tag='{{ inputs.image_tag }}', namespace='{{ inputs.namespace }}')
      ```

      {% else %}
      ### {{ vuln_analysis.icon }} Vulnerability Summary

      | Severity | Count |
      |----------|-------|
      | üî¥ Critical | {{ vuln_analysis.critical }} |
      | üü† High | {{ vuln_analysis.high }} |
      | üü° Medium | {{ vuln_analysis.medium }} |
      | üü¢ Low | {{ vuln_analysis.low }} |
      | **Total** | **{{ vuln_analysis.total }}** |

      {% if vuln_analysis.cves %}
      ### CVEs Found
      {% for cve in vuln_analysis.cves[:10] %}
      - [{{ cve }}](https://nvd.nist.gov/vuln/detail/{{ cve }})
      {% endfor %}
      {% if vuln_analysis.cves|length > 10 %}
      ... and {{ vuln_analysis.cves|length - 10 }} more
      {% endif %}
      {% endif %}

      ---

      ### üìã Recommendation

      {% if policy_result.blocked %}
      ‚ùå **BLOCKED:** {{ policy_result.block_reason }}

      Do not deploy this image until vulnerabilities are addressed.
      {% elif vuln_analysis.critical > 0 %}
      ‚ö†Ô∏è **Warning:** Critical vulnerabilities found. Review before deploying.
      {% elif policy_result.safe_to_deploy %}
      ‚úÖ **Safe to deploy** - No critical vulnerabilities.
      {% else %}
      ‚ö†Ô∏è Review vulnerabilities before deploying.
      {% endif %}

      ### Commands
      ```python
      # Get full vulnerability details
      quay_get_vulnerabilities(repository='{{ inputs.repository }}', tag='{{ inputs.image_tag }}', namespace='{{ inputs.namespace }}')

      # Check specific CVE
      # web_search("CVE-XXXX-XXXXX mitigation")
      ```

      {% if scan_gotchas and scan_gotchas.has_gotchas %}
      ---

      ### ‚ö†Ô∏è Security Gotchas

      {% for gotcha in scan_gotchas.gotchas[:3] %}
      - {{ gotcha }}
      {% endfor %}
      {% endif %}

      {% if security_known_issues and security_known_issues.has_known_issues %}
      ---

      ### üí° Known Issues

      {% for issue in security_known_issues.issues[:3] %}
      - {{ issue.pattern if issue.pattern else issue }}
      {% endfor %}
      {% endif %}
      {% endif %}

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_scan_failures
    description: "Detect failure patterns from vulnerability scanning"
    compute: |
      errors_detected = []

      # Check Quay failures
      image_text = str(image_check_raw) if 'image_check_raw' in dir() and image_check_raw else ""
      vuln_text = str(vuln_report_raw) if 'vuln_report_raw' in dir() and vuln_report_raw else ""
      combined = image_text + vuln_text

      if "manifest unknown" in combined.lower() or "not found" in combined.lower():
          errors_detected.append({
              "tool": "quay_get_vulnerabilities",
              "pattern": "manifest unknown",
              "cause": "Image tag doesn't exist in Quay - build may not be complete",
              "fix": "Wait for Konflux build to complete or check tag format"
          })
      if "unauthorized" in combined.lower() or "401" in combined:
          errors_detected.append({
              "tool": "quay_get_vulnerabilities",
              "pattern": "unauthorized",
              "cause": "Quay authentication failed",
              "fix": "Check Quay credentials in config.json"
          })
      if "rate limit" in combined.lower():
          errors_detected.append({
              "tool": "quay_get_vulnerabilities",
              "pattern": "rate limit",
              "cause": "Quay API rate limit exceeded",
              "fix": "Wait a few minutes and retry"
          })

      result = errors_detected
    output: scan_errors_detected
    on_error: continue

  - name: learn_scan_manifest_failure
    description: "Learn from manifest not found failures"
    condition: "scan_errors_detected and any(e.get('pattern') == 'manifest unknown' for e in scan_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "quay_get_vulnerabilities"
      error_pattern: "manifest unknown"
      root_cause: "Image tag doesn't exist in Quay - build may not be complete"
      fix_description: "Wait for Konflux build to complete or check tag format"
    output: scan_manifest_fix_learned
    on_error: continue

  - name: learn_scan_auth_failure
    description: "Learn from Quay auth failures"
    condition: "scan_errors_detected and any(e.get('pattern') == 'unauthorized' for e in scan_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "quay_get_vulnerabilities"
      error_pattern: "unauthorized"
      root_cause: "Quay authentication failed"
      fix_description: "Check Quay credentials in config.json"
    output: scan_auth_fix_learned
    on_error: continue

  - name: log_scan_session
    description: "Log vulnerability scan to session"
    tool: memory_session_log
    args:
      action: "Scanned image {{ inputs.image_tag }} for vulnerabilities"
      details: "Critical: {{ vuln_analysis.critical if vuln_analysis else 0 }}, Total: {{ vuln_analysis.total if vuln_analysis else 0 }}"
    on_error: continue

  - name: context
    value:
      image_exists: "{{ image_status.exists }}"
      status: "{{ vuln_analysis.status if vuln_analysis else 'unknown' }}"
      critical_count: "{{ vuln_analysis.critical if vuln_analysis else 0 }}"
      total_count: "{{ vuln_analysis.total if vuln_analysis else 0 }}"
      blocked: "{{ policy_result.blocked if policy_result else false }}"
      safe_to_deploy: "{{ policy_result.safe_to_deploy if policy_result else false }}"
