# Skill: Jira Issue Hygiene
# Validates and fixes Jira issues for quality and completeness

name: jira_hygiene
description: |
  Check and fix Jira issue hygiene - ensures issues have proper details,
  acceptance criteria, priority, labels, epic links, and formatting.
  Transitions New issues to Refinement when complete.

  Resolves project and component from issue_key prefix or repo_name.
version: "1.2"

inputs:
  - name: issue_key
    type: string
    required: true
    description: "Jira issue key to check (e.g., AAP-12345)"

  - name: repo_name
    type: string
    required: false
    description: "Repository name from config to determine component"

  - name: auto_fix
    type: boolean
    required: false
    default: true
    description: "Automatically fix issues where possible"

  - name: auto_transition
    type: boolean
    required: false
    default: true
    description: "Auto-transition New ‚Üí Refinement when ready"

  - name: epic_key
    type: string
    required: false
    description: "Epic key to link issue to (e.g., AAP-50000). If provided with auto_fix, will set epic."

  - name: story_points
    type: integer
    required: false
    description: "Story points to set (e.g., 3). If provided with auto_fix, will set points."

  - name: priority
    type: string
    required: false
    description: "Priority to set (e.g., 'Major'). If provided with auto_fix, will set priority."

# No hardcoded constants - resolved dynamically

steps:

  - name: init_autoheal
    description: "Initialize failure tracking"
    compute: |
      result = {"jira_failures": []}
    output: autoheal_state
    on_error: continue

  # ==================== RESOLVE PROJECT/COMPONENT ====================

  - name: resolve_context
    description: "Determine Jira project and default component from issue key"
    compute: |
      import os
      from scripts.common.config_loader import load_config

      # Default values
      jira_project = "AAP"
      component = "Automation Analytics"

      # Load config using shared loader
      config = load_config()
      repos = config.get("repositories", {})

      # Extract project prefix from issue key (inputs is a dict)
      issue_key = inputs.get("issue_key", "") if isinstance(inputs, dict) else getattr(inputs, "issue_key", "")
      project_prefix = issue_key.split("-")[0].upper() if issue_key else ""

      # Set jira_project from issue key
      if project_prefix:
          jira_project = project_prefix

      # Try to find component from repo config
      repo_name = inputs.get("repo_name", "") if isinstance(inputs, dict) else getattr(inputs, "repo_name", "")
      if repo_name and repo_name in repos:
          cfg = repos[repo_name]
          if cfg.get("jira_component"):
              component = cfg["jira_component"]
      else:
          # Look for repo matching jira_project
          for name, cfg in repos.items():
              if cfg.get("jira_project") == jira_project:
                  if cfg.get("jira_component"):
                      component = cfg["jira_component"]
                  break

      result = {
          "jira_project": jira_project,
          "component": component,
          "status_new": "New",
          "status_refinement": "Refinement",
          "status_in_progress": "In Progress",
      }
    output: resolved
  # ==================== GET ISSUE DETAILS ====================

  # Step 1: Get full issue details
  - name: get_issue
    description: "Fetch issue details from Jira"
    tool: jira_view_issue_json
    args:
      issue_key: "{{ inputs.issue_key }}"
    output: issue_raw
    on_error: continue
    # NOTE: Auto-heal now handled by @auto_heal() decorator on the tool

  # Step 2: Parse issue data
  - name: parse_issue
    description: "Parse issue fields for validation using shared parser"
    compute: |
      import json

      # issue_raw is JSON string from jira_view_issue_json
      issue_data = {}

      try:
        if isinstance(issue_raw, str):
          # Try to parse as JSON first
          issue_data = json.loads(issue_raw)
        elif isinstance(issue_raw, dict):
          issue_data = issue_raw
        else:
          issue_data = {"raw": str(issue_raw)}
      except json.JSONDecodeError:
        # If not valid JSON, try shared parser
        try:
          from scripts.common.parsers import extract_json_from_output
          issue_data = extract_json_from_output(issue_raw) or {"raw": issue_raw}
        except:
          issue_data = {"raw": str(issue_raw)}
      except Exception as e:
        issue_data = {"raw": str(issue_raw), "error": str(e)}

      # Get issue_key from inputs (handle both dict and attribute access)
      issue_key = inputs.get("issue_key", "") if isinstance(inputs, dict) else getattr(inputs, "issue_key", "")

      # Extract key fields (handle the key names from our parsed output)
      # Handle both string and list types for labels/components
      labels_raw = issue_data.get("labels", [])
      if isinstance(labels_raw, str):
        labels = [labels_raw] if labels_raw and labels_raw != "None" else []
      else:
        labels = labels_raw or []

      comps_raw = issue_data.get("components", issue_data.get("component_s", []))
      if isinstance(comps_raw, str):
        components = [comps_raw] if comps_raw and comps_raw != "None" else []
      else:
        components = comps_raw or []

      result = {
        "key": issue_key,
        "summary": issue_data.get("summary", ""),
        "status": issue_data.get("status", "Unknown"),
        "issue_type": issue_data.get("issue_type", issue_data.get("issuetype", issue_data.get("type", "Story"))),
        "description": issue_data.get("description", ""),
        "acceptance_criteria": issue_data.get("acceptance_criteria", issue_data.get("customfield_12313440", "")),
        "priority": issue_data.get("priority", ""),
        "labels": labels,
        "components": components,
        "epic_link": issue_data.get("epic_link", issue_data.get("epic", issue_data.get("customfield_12311140", issue_data.get("parent", "")))),
        "fix_version": issue_data.get("fixVersions", issue_data.get("fix_version", [])),
        "story_points": issue_data.get("story_points", issue_data.get("customfield_12310243", None)),
        "assignee": issue_data.get("assignee", ""),
        "reporter": issue_data.get("reporter", ""),
      }
    output: issue

  # ==================== VALIDATE ISSUE ====================

  # Step 3: Run validation checks
  - name: validate_issue
    description: "Check issue against hygiene rules"
    compute: |
      issues_found = []
      can_fix = []
      needs_input = []

      status = issue.get("status", "").lower()
      issue_type = issue.get("issue_type", "").lower()

      # === DESCRIPTION ===
      desc = issue.get("description", "")
      desc_str = str(desc) if desc else ""
      if not desc_str or len(desc_str.strip()) < 20:
        issues_found.append("‚ùå Missing or too short description")
        needs_input.append({
          "field": "description",
          "issue": "Description is missing or too short (< 20 chars)",
          "action": "Please provide a description for this issue"
        })
      elif not any(marker in desc_str for marker in ['h1.', 'h2.', 'h3.', '*', '-', '#']):
        # Check formatting
        issues_found.append("‚ö†Ô∏è Description lacks proper formatting (headers, bullets)")
        can_fix.append({
          "field": "description_format",
          "issue": "Description could use better Jira markup",
          "suggestion": "Add headers (h2.), bullets (*), code blocks ({code})"
        })

      # === ACCEPTANCE CRITERIA ===
      ac = issue.get("acceptance_criteria", "")
      if not ac or len(str(ac).strip()) < 10:
        issues_found.append("‚ùå Missing acceptance criteria")
        needs_input.append({
          "field": "acceptance_criteria",
          "issue": "Acceptance criteria not defined",
          "action": "Please provide acceptance criteria"
        })

      # === PRIORITY ===
      priority = issue.get("priority", "")
      if not priority:
        issues_found.append("‚ùå Priority not set")
        can_fix.append({
          "field": "priority",
          "issue": "Priority is not set",
          "suggestion": "Set to 'Normal' as default",
          "value": "Normal"
        })

      # === LABELS/COMPONENTS ===
      labels = issue.get("labels", [])
      components = issue.get("components", [])
      if not labels and not components:
        issues_found.append("‚ùå No labels or components set")
        can_fix.append({
          "field": "component",
          "issue": "No component assigned",
          "suggestion": "Add 'Automation Analytics' component",
          "value": "Automation Analytics"
        })

      # === EPIC LINK (for stories) ===
      if 'story' in issue_type or 'task' in issue_type:
        epic = issue.get("epic_link", "")
        if not epic:
          issues_found.append("‚ùå Story not linked to an Epic")
          needs_input.append({
            "field": "epic_link",
            "issue": "Story should be linked to an Epic",
            "action": "Please specify which Epic this belongs to"
          })

      # === FIX VERSION ===
      fix_ver = issue.get("fix_version", [])
      if not fix_ver:
        issues_found.append("‚ö†Ô∏è No fix version set")
        can_fix.append({
          "field": "fix_version",
          "issue": "Fix version not specified",
          "suggestion": "Set fix version when known"
        })

      # === STORY POINTS (only if In Progress) ===
      if 'in progress' in status or 'review' in status:
        sp = issue.get("story_points")
        if sp is None or sp == "":
          issues_found.append("‚ùå In Progress without story points")
          needs_input.append({
            "field": "story_points",
            "issue": "Story points required for In Progress issues",
            "action": "Please estimate story points"
          })

      # === STATUS TRANSITION CHECK ===
      transition_ready = False
      if status == "new":
        # Check if ready for Refinement
        has_desc = bool(issue.get("description", "")) and len(str(issue.get("description", ""))) >= 20
        has_ac = bool(issue.get("acceptance_criteria", ""))
        has_priority = bool(issue.get("priority", ""))

        if has_desc and has_ac and has_priority:
          transition_ready = True
          can_fix.append({
            "field": "status",
            "issue": "Issue is ready for Refinement",
            "suggestion": "Transition from New ‚Üí Refinement",
            "value": "Refinement"
          })

      # Calculate health score
      total_checks = 7  # desc, ac, priority, labels, epic, fix_ver, formatting
      passed = total_checks - len([i for i in issues_found if '‚ùå' in i])
      health_score = int((passed / total_checks) * 100)

      result = {
        "issues": issues_found,
        "can_fix": can_fix,
        "needs_input": needs_input,
        "health_score": health_score,
        "transition_ready": transition_ready,
        "current_status": issue.get("status", "Unknown"),
        "is_healthy": len(issues_found) == 0
      }
    output: validation

  # ==================== AUTO-FIX WHERE POSSIBLE ====================

  # Step 4: Prepare fixes - determine what can be auto-fixed
  - name: prepare_fixes
    description: "Determine which fixes to apply automatically"
    condition: "{{ inputs.auto_fix }}"
    compute: |
      auto_fix = inputs.get('auto_fix', False) if isinstance(inputs, dict) else getattr(inputs, 'auto_fix', False)
      auto_transition = inputs.get('auto_transition', True) if isinstance(inputs, dict) else getattr(inputs, 'auto_transition', True)

      fixes_to_apply = {
        "status": False,
        "priority": None,
        "story_points": None,
        "epic": None,
      }

      for fix in validation.get('can_fix', []):
        field = fix.get('field')
        value = fix.get('value')

        if field == 'status' and auto_transition:
          fixes_to_apply["status"] = True
        elif field == 'priority' and value:
          fixes_to_apply["priority"] = value

      # Check inputs for user-provided values (override detected fixes)
      epic_key = inputs.get('epic_key', '') if isinstance(inputs, dict) else getattr(inputs, 'epic_key', '')
      story_points = inputs.get('story_points', None) if isinstance(inputs, dict) else getattr(inputs, 'story_points', None)
      priority_input = inputs.get('priority', '') if isinstance(inputs, dict) else getattr(inputs, 'priority', '')

      if epic_key:
        fixes_to_apply["epic"] = epic_key
      if story_points:
        fixes_to_apply["story_points"] = story_points
      if priority_input:
        fixes_to_apply["priority"] = priority_input

      result = fixes_to_apply
    output: fixes_to_apply

  # Apply status transition
  - name: apply_status_transition
    description: "Transition issue status to Refinement"
    condition: "{{ fixes_to_apply.status }}"
    tool: jira_set_status
    args:
      issue_key: "{{ inputs.issue_key }}"
      status: "Refinement"
    output: status_result
    on_error: continue

  # Apply priority fix
  - name: apply_priority_fix
    description: "Set missing priority"
    condition: "{{ fixes_to_apply.priority }}"
    tool: jira_set_priority
    args:
      issue_key: "{{ inputs.issue_key }}"
      priority: "{{ fixes_to_apply.priority }}"
    output: priority_result
    on_error: continue

  # Apply epic link fix
  - name: apply_epic_fix
    description: "Link issue to epic"
    condition: "{{ fixes_to_apply.epic }}"
    tool: jira_set_epic
    args:
      issue_key: "{{ inputs.issue_key }}"
      epic_key: "{{ fixes_to_apply.epic }}"
    output: epic_result
    on_error: continue

  # Apply story points fix
  - name: apply_story_points_fix
    description: "Set story points"
    condition: "{{ fixes_to_apply.story_points }}"
    tool: jira_set_story_points
    args:
      issue_key: "{{ inputs.issue_key }}"
      points: "{{ fixes_to_apply.story_points }}"
    output: points_result
    on_error: continue

  # Collect fix results
  - name: collect_fix_results
    description: "Summarize what was fixed"
    compute: |
      fixed = []
      failed = []

      # Check each result
      results = [
        ("Status ‚Üí Refinement", 'status_result'),
        ("Priority", 'priority_result'),
        ("Epic link", 'epic_result'),
        ("Story points", 'points_result'),
      ]

      for label, var_name in results:
        if var_name in dir():
          result_val = eval(var_name)
          if result_val and "‚úÖ" in str(result_val):
            fixed.append(f"‚úÖ {label}")
          elif result_val and "‚ùå" in str(result_val):
            failed.append(f"‚ùå {label}: {str(result_val)[:80]}")

      result = {"fixed": fixed, "failed": failed}
    output: fix_results

  # ==================== GENERATE REPORT ====================

  # Step 5: Build summary
  - name: build_report
    compute: |
      lines = []

      # Health score emoji
      score = validation['health_score']
      if score >= 90:
        health_emoji = "üü¢"
      elif score >= 70:
        health_emoji = "üü°"
      elif score >= 50:
        health_emoji = "üü†"
      else:
        health_emoji = "üî¥"

      lines.append(f"## {health_emoji} Issue Health: {score}%")
      issue_key = inputs.get('issue_key', '') if isinstance(inputs, dict) else getattr(inputs, 'issue_key', '')
      lines.append(f"**Issue:** {issue_key}")
      lines.append(f"**Summary:** {issue.get('summary', 'N/A')}")
      lines.append(f"**Status:** {validation['current_status']}")
      lines.append(f"**Type:** {issue.get('issue_type', 'N/A')}")
      lines.append("")

      # Issues found
      if validation['issues']:
        lines.append("### Issues Found")
        for iss in validation['issues']:
          lines.append(f"- {iss}")
        lines.append("")

      # Fixed items
      if fix_results and fix_results.get('fixed'):
        lines.append("### ‚úÖ Fixed")
        for fix in fix_results['fixed']:
          lines.append(f"- {fix}")
        lines.append("")

      # Needs input
      if validation['needs_input']:
        lines.append("### ‚ùì Needs Your Input")
        for item in validation['needs_input']:
          lines.append(f"**{item['field']}:** {item['issue']}")
          lines.append(f"  ‚Üí {item['action']}")
        lines.append("")

      # Status transition
      auto_transition = inputs.get('auto_transition', True) if isinstance(inputs, dict) else getattr(inputs, 'auto_transition', True)
      if validation['transition_ready'] and not auto_transition:
        lines.append("### üìã Ready for Transition")
        lines.append("This issue has all required fields. Ready to move: **New ‚Üí Refinement**")
        lines.append("")
        lines.append("Run with `auto_transition=true` to transition automatically.")
        lines.append("")

      # All good
      if validation['is_healthy']:
        lines.append("### ‚úÖ All Checks Passed!")
        lines.append("This issue meets all hygiene requirements.")

      result = '\n'.join(lines)
    output: report

  # ==================== MEMORY INTEGRATION ====================

  - name: log_hygiene_check
    description: "Log hygiene check to session"
    tool: memory_session_log
    args:
      action: "Hygiene check on {{ inputs.issue_key }}"
      details: "{{ 'Healthy' if validation.is_healthy else validation.issues|length|string + ' issues found' }}"
    on_error: continue

  - name: create_followup_if_needed
    description: "Create follow-up task if issues need manual input"
    condition: "validation.needs_input"
    compute: |
      # Use shared memory helpers
      data = memory.read_memory("state/current_work")
      follow_ups = data.get("follow_ups", []) if isinstance(data.get("follow_ups"), list) else []

      # Get issue_key from inputs (handle both dict and attribute access)
      issue_key = inputs.get('issue_key', '') if isinstance(inputs, dict) else getattr(inputs, 'issue_key', '')

      # Check if follow-up already exists for this issue
      existing = any(
          fu.get("issue_key") == issue_key and "hygiene" in fu.get("task", "").lower()
          for fu in follow_ups
      )

      if not existing:
          fields_needed = [item["field"] for item in validation.get("needs_input", [])]
          memory.add_follow_up(
              task=f"Fix hygiene issues on {issue_key}: {', '.join(fields_needed[:3])}",
              priority="low",
              issue_key=issue_key
          )
          result = "follow-up created"
      else:
          result = "follow-up already exists"
    output: followup_result
    on_error: continue

outputs:
  - name: summary
    value: |
      {{ report }}

      ---

      {% if validation.needs_input %}
      ### What would you like to do?

      I need some information to complete the fixes:

      {% for item in validation.needs_input %}
      **{{ item.field }}:** {{ item.action }}
      {% endfor %}

      Provide the missing info and I'll update the issue.
      {% elif not validation.is_healthy %}

      ### Quick Fixes

      To update this issue manually:
      ```
      jira_add_comment(issue_key='{{ inputs.issue_key }}', comment='...')
      jira_set_status(issue_key='{{ inputs.issue_key }}', status='Refinement')
      ```
      {% endif %}

  - name: context
    value:
      issue_key: "{{ inputs.issue_key }}"
      health_score: "{{ validation.health_score }}"
      is_healthy: "{{ validation.is_healthy }}"
      issues_count: "{{ validation.issues | length }}"
      needs_input: "{{ validation.needs_input }}"
      transition_ready: "{{ validation.transition_ready }}"
