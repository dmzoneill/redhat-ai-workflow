# Skill: Release to Production
# Create and manage Konflux releases to production

name: release_to_prod
description: |
  Create a Konflux release to push images from staging to production.

  This skill handles the full release workflow:
  1. Verify the image exists in staging (redhat-user-workloads)
  2. Check current release status in Konflux
  3. Get component information
  4. Create the release to production
  5. Monitor release status

  Prerequisites:
  - Image must be built and available in Quay staging
  - User must have Konflux access

version: "1.0"

inputs:
  - name: commit_sha
    type: string
    required: true
    description: "Git commit SHA to release (40-char full SHA)"

  - name: component
    type: string
    required: false
    default: "automation-analytics-backend-main"
    description: "Konflux component name"

  - name: namespace
    type: string
    required: false
    default: "aap-aa-tenant"
    description: "Konflux tenant namespace"

  - name: application
    type: string
    required: false
    default: "aap-aa-main"
    description: "Konflux application name"

  - name: dry_run
    type: boolean
    required: false
    default: false
    description: "If true, just show what would be released without creating"

steps:
  # ==================== KNOWLEDGE INTEGRATION ====================

  - name: get_release_gotchas
    description: "Get release gotchas from knowledge"
    tool: knowledge_query
    args:
      project: "automation-analytics-backend"
      persona: "devops"
      section: "gotchas"
    output: release_gotchas_raw
    on_error: continue

  - name: parse_release_gotchas
    description: "Parse release-related gotchas"
    compute: |
      gotchas_result = release_gotchas_raw if 'release_gotchas_raw' in dir() and release_gotchas_raw else {}

      release_gotchas = []
      if isinstance(gotchas_result, dict) and gotchas_result.get('found'):
          content = gotchas_result.get('content', [])
          if isinstance(content, list):
              # Filter for release-related gotchas
              for g in content:
                  g_str = str(g).lower()
                  if any(kw in g_str for kw in ['release', 'prod', 'deploy', 'konflux', 'quay', 'image']):
                      release_gotchas.append(g)

      result = {
          'gotchas': release_gotchas[:5],
          'has_gotchas': len(release_gotchas) > 0,
      }
    output: prod_release_gotchas
    on_error: continue

  - name: check_release_known_issues
    description: "Check for known release issues"
    compute: |
      # Check known issues for release operations
      release_issues = memory.check_known_issues("release", "") or {}
      konflux_issues = memory.check_known_issues("konflux", "") or {}
      quay_issues = memory.check_known_issues("quay", "") or {}

      all_issues = []
      for issues in [release_issues, konflux_issues, quay_issues]:
          if issues and issues.get("matches"):
              all_issues.extend(issues.get("matches", [])[:2])

      result = {
          "has_known_issues": len(all_issues) > 0,
          "issues": all_issues[:5],
      }
    output: release_known_issues
    on_error: continue

  # ==================== SEMANTIC SEARCH FOR CHANGES ====================

  - name: search_release_changes
    description: "Search codebase for changes related to this release"
    tool: code_search
    args:
      query: "deployment configuration release production"
      project: "automation-analytics-backend"
      limit: 5
    output: release_code_search_raw
    on_error: continue

  - name: parse_release_code_search
    description: "Parse code search results for release context"
    compute: |
      import re

      search_text = str(release_code_search_raw) if 'release_code_search_raw' in dir() and release_code_search_raw else ""

      # Extract relevant files
      file_pattern = r'###\s*\d+\.\s*`([^`]+)`'
      files = re.findall(file_pattern, search_text)

      # Look for deployment-related files
      deployment_files = [f for f in files if any(kw in f.lower() for kw in ['deploy', 'config', 'settings', 'env'])]

      result = {
          "found": len(files) > 0,
          "files": files[:5],
          "deployment_files": deployment_files[:3],
          "has_deployment_changes": len(deployment_files) > 0,
      }
    output: release_code_context
    on_error: continue

  # ==================== VALIDATE INPUT ====================

  - name: validate_sha
    description: "Validate commit SHA format"
    compute: |
      sha = inputs.commit_sha.strip()

      if len(sha) != 40:
          raise ValueError(f"Expected 40-char commit SHA, got {len(sha)} chars: {sha[:20]}...")

      if not all(c in '0123456789abcdef' for c in sha.lower()):
          raise ValueError(f"Invalid SHA format: {sha}")

      result = {"sha": sha, "short": sha[:12]}
    output: validated_sha

  # ==================== CHECK IMAGE EXISTS ====================

  - name: check_staging_image
    description: "Verify image exists in staging Quay"
    tool: quay_check_image_exists
    args:
      repository: "{{ inputs.namespace }}/{{ inputs.application }}/{{ inputs.component }}"
      tag: "{{ validated_sha.sha }}"
      namespace: "redhat-user-workloads"
    output: staging_image_check
    on_error: auto_heal  # Quay API - may need auth

  - name: parse_staging_check
    description: "Parse staging image check result"
    compute: |
      check_text = str(staging_image_check) if staging_image_check else ""

      exists = "not found" not in check_text.lower() and "error" not in check_text.lower()

      result = {
          "exists": exists,
          "raw": check_text[:300] if check_text else "No response",
      }
    output: staging_status

  # ==================== SECURITY SCAN ====================

  - name: scan_vulnerabilities
    description: "Scan image for security vulnerabilities"
    condition: "staging_status.exists"
    tool: quay_get_vulnerabilities
    args:
      repository: "{{ inputs.namespace }}/{{ inputs.application }}/{{ inputs.component }}"
      tag: "{{ validated_sha.sha }}"
      namespace: "redhat-user-workloads"
    output: vuln_scan_raw
    on_error: continue

  - name: parse_vulnerabilities
    description: "Parse vulnerability scan results"
    condition: "vuln_scan_raw"
    compute: |
      vuln_text = str(vuln_scan_raw) if vuln_scan_raw else ""

      # Count vulnerabilities by severity
      critical = vuln_text.lower().count("critical")
      high = vuln_text.lower().count("high")

      # Extract CVE IDs
      import re
      cves = re.findall(r'CVE-\d{4}-\d+', vuln_text)
      unique_cves = list(set(cves))[:10]

      # Determine if release should be blocked
      block_release = critical > 0

      result = {
          "critical": critical,
          "high": high,
          "cves": unique_cves,
          "block_release": block_release,
          "safe": critical == 0,
          "preview": vuln_text[:500] if vuln_text else "",
      }
    output: security_status
    on_error: continue

  # ==================== GET COMPONENT INFO ====================

  - name: get_component
    description: "Get Konflux component details"
    tool: konflux_get_component
    args:
      component_name: "{{ inputs.component }}"
      namespace: "{{ inputs.namespace }}"
    output: component_info_raw
    on_error: continue

  - name: list_components
    description: "List all components in application"
    tool: konflux_list_components
    args:
      namespace: "{{ inputs.namespace }}"
    output: components_list_raw
    on_error: continue

  - name: parse_component_info
    description: "Parse component information"
    compute: |
      comp_text = str(component_info_raw) if 'component_info_raw' in dir() and component_info_raw else ""
      list_text = str(components_list_raw) if 'components_list_raw' in dir() and components_list_raw else ""

      # Check if our component exists
      component_found = inputs.component.lower() in comp_text.lower() or inputs.component.lower() in list_text.lower()

      # Parse component count
      import re
      component_count = len(re.findall(r'component', list_text, re.I))

      result = {
          "component_found": component_found,
          "component_info": comp_text[:500] if comp_text else "Not available",
          "total_components": component_count,
          "components_list": list_text[:500] if list_text else "Not available",
      }
    output: component_status

  # ==================== CHECK EXISTING RELEASES ====================

  - name: list_releases
    description: "List recent releases"
    tool: konflux_list_releases
    args:
      namespace: "{{ inputs.namespace }}"
      limit: 10
    output: releases_list_raw
    on_error: continue

  - name: get_latest_release
    description: "Get details of latest release"
    condition: "releases_list_raw"
    tool: konflux_get_release
    args:
      namespace: "{{ inputs.namespace }}"
    output: latest_release_raw
    on_error: continue

  - name: parse_releases
    description: "Parse release information"
    compute: |
      list_text = str(releases_list_raw) if 'releases_list_raw' in dir() and releases_list_raw else ""
      latest_text = str(latest_release_raw) if 'latest_release_raw' in dir() and latest_release_raw else ""

      # Check if this SHA was already released
      already_released = validated_sha.sha[:12] in list_text or validated_sha.sha in list_text

      # Count releases
      import re
      release_count = len(re.findall(r'release', list_text, re.I))

      result = {
          "already_released": already_released,
          "release_count": release_count,
          "recent_releases": list_text[:600] if list_text else "No releases",
          "latest_release": latest_text[:400] if latest_text else "No latest",
      }
    output: release_status

  # ==================== VALIDATE APP-INTERFACE ====================

  - name: validate_appinterface
    description: "Validate app-interface configuration before release"
    condition: "not inputs.dry_run and staging_status.exists"
    tool: appinterface_validate
    args: {}
    output: appinterface_validation_raw
    on_error: auto_heal  # App Interface - may need auth

  - name: parse_appinterface_validation
    description: "Parse validation result"
    compute: |
      validate_text = str(appinterface_validation_raw) if 'appinterface_validation_raw' in dir() and appinterface_validation_raw else ""

      valid = "valid" in validate_text.lower() or "success" in validate_text.lower()
      has_errors = "error" in validate_text.lower() or "failed" in validate_text.lower()

      result = {
        "valid": valid and not has_errors,
        "message": validate_text[:300] if validate_text else "Validation not run",
      }
    output: appinterface_status
    on_error: continue

  # ==================== CREATE RELEASE ====================

  - name: create_release
    description: "Create Konflux release"
    condition: "not inputs.dry_run and staging_status.exists and not release_status.already_released"
    tool: konflux_create_release
    args:
      component: "{{ inputs.component }}"
      snapshot: "{{ validated_sha.sha }}"
      namespace: "{{ inputs.namespace }}"
    output: create_release_result
    on_error: continue

  - name: parse_release_result
    description: "Parse release creation result"
    condition: "create_release_result"
    compute: |
      result_text = str(create_release_result) if create_release_result else ""

      success = "created" in result_text.lower() or "success" in result_text.lower()

      # Try to extract release name
      import re
      release_name = None
      name_match = re.search(r'release[/\s]+([a-z0-9-]+)', result_text, re.I)
      if name_match:
          release_name = name_match.group(1)

      result = {
          "success": success,
          "release_name": release_name,
          "raw": result_text[:500] if result_text else "No result",
      }
    output: release_result
    on_error: continue

  # ==================== MEMORY ====================

  - name: log_release
    description: "Log release to session"
    condition: "release_result and release_result.success"
    tool: memory_session_log
    args:
      action: "Created Konflux release"
      details: "SHA: {{ validated_sha.short }}, Component: {{ inputs.component }}"
    on_error: continue

  - name: save_release_to_history
    description: "Save release to history for tracking"
    condition: "release_result and release_result.success"
    tool: memory_append
    args:
      key: "state/releases"
      list_path: "release_history"
      item: |
        sha: "{{ validated_sha.sha }}"
        short_sha: "{{ validated_sha.short }}"
        component: "{{ inputs.component }}"
        application: "{{ inputs.application }}"
        namespace: "{{ inputs.namespace }}"
        timestamp: "{{ now().isoformat() }}"
        status: "released"
    on_error: continue

  - name: create_grafana_annotation
    description: "Mark release on Grafana dashboards"
    condition: "release_result and release_result.success"
    tool: grafana_annotation_create
    args:
      text: "Release {{ validated_sha.short }} - {{ inputs.component }}"
      tags: ["release", "{{ inputs.component }}", "{{ inputs.application }}"]
    output: grafana_annotation_result
    on_error: continue

  - name: announce_release
    description: "Announce release to team channel"
    condition: "release_result and release_result.success"
    tool: slack_post_message
    args:
      channel: "team-automation-analytics"
      message: "üì¶ **Production Release** - `{{ validated_sha.short }}` released to {{ inputs.component }}"
    output: slack_release_notify
    on_error: auto_heal  # Slack API - may need auth

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_release_failures
    description: "Detect failure patterns from release operations"
    compute: |
      errors_detected = []

      # Check staging image failures
      staging_text = str(staging_image_check) if 'staging_image_check' in dir() and staging_image_check else ""
      if "not found" in staging_text.lower() or "manifest unknown" in staging_text.lower():
          errors_detected.append({
              "tool": "quay_check_image_exists",
              "pattern": "image not found",
              "cause": "Image not built yet in staging - Konflux build may not have completed",
              "fix": "Wait for Konflux build to complete, check with konflux_list_builds()"
          })

      # Check Konflux auth failures
      component_text = str(component_info_raw) if 'component_info_raw' in dir() and component_info_raw else ""
      releases_text = str(releases_list_raw) if 'releases_list_raw' in dir() and releases_list_raw else ""
      combined_text = component_text + releases_text

      if "unauthorized" in combined_text.lower() or "forbidden" in combined_text.lower():
          errors_detected.append({
              "tool": "konflux_get_component",
              "pattern": "unauthorized",
              "cause": "Kubernetes auth expired for Konflux cluster",
              "fix": "Run kube_login(cluster='konflux') to refresh credentials"
          })
      if "no route to host" in combined_text.lower():
          errors_detected.append({
              "tool": "konflux_get_component",
              "pattern": "no route to host",
              "cause": "VPN not connected - cannot reach Konflux cluster",
              "fix": "Run vpn_connect() to connect to Red Hat VPN"
          })

      # Check release creation failures
      release_text = str(create_release_result) if 'create_release_result' in dir() and create_release_result else ""
      if "already exists" in release_text.lower():
          errors_detected.append({
              "tool": "konflux_create_release",
              "pattern": "already exists",
              "cause": "Release for this SHA already exists",
              "fix": "Check existing releases with konflux_list_releases()"
          })
      if "component not found" in release_text.lower():
          errors_detected.append({
              "tool": "konflux_create_release",
              "pattern": "component not found",
              "cause": "Specified component doesn't exist in Konflux",
              "fix": "List available components with konflux_list_components()"
          })

      result = errors_detected
    output: release_errors_detected
    on_error: continue

  - name: learn_staging_image_failure
    description: "Learn from staging image not found failures"
    condition: "release_errors_detected and any(e.get('pattern') == 'image not found' for e in release_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "quay_check_image_exists"
      error_pattern: "image not found"
      root_cause: "Image not built yet in staging - Konflux build may not have completed"
      fix_description: "Wait for Konflux build to complete, check with konflux_list_builds()"
    output: staging_image_fix_learned
    on_error: continue

  - name: learn_konflux_auth_failure
    description: "Learn from Konflux auth failures"
    condition: "release_errors_detected and any(e.get('pattern') == 'unauthorized' for e in release_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "konflux_get_component"
      error_pattern: "unauthorized"
      root_cause: "Kubernetes auth expired for Konflux cluster"
      fix_description: "Run kube_login(cluster='konflux') to refresh credentials"
    output: konflux_auth_fix_learned
    on_error: continue

  - name: learn_konflux_vpn_failure
    description: "Learn from Konflux VPN failures"
    condition: "release_errors_detected and any(e.get('pattern') == 'no route to host' for e in release_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "konflux_get_component"
      error_pattern: "no route to host"
      root_cause: "VPN not connected - cannot reach Konflux cluster"
      fix_description: "Run vpn_connect() to connect to Red Hat VPN"
    output: konflux_vpn_fix_learned
    on_error: continue

  - name: learn_release_exists_failure
    description: "Learn from release already exists failures"
    condition: "release_errors_detected and any(e.get('pattern') == 'already exists' for e in release_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "konflux_create_release"
      error_pattern: "already exists"
      root_cause: "Release for this SHA already exists"
      fix_description: "Check existing releases with konflux_list_releases()"
    output: release_exists_fix_learned
    on_error: continue

outputs:
  - name: report
    value: |
      ## üöÄ Release to Production

      **Commit:** `{{ validated_sha.sha }}`
      **Component:** `{{ inputs.component }}`
      **Application:** `{{ inputs.application }}`
      **Namespace:** `{{ inputs.namespace }}`

      ---

      ### Pre-flight Checks

      {% if not staging_status.exists %}
      ‚ùå **Image Not Found in Staging**

      The image for commit `{{ validated_sha.short }}` was not found in the staging Quay repository.

      **Expected location:**
      `quay.io/redhat-user-workloads/{{ inputs.namespace }}/{{ inputs.application }}/{{ inputs.component }}:{{ validated_sha.sha }}`

      **Action:** Wait for Konflux to build the image, or verify the commit SHA.

      ```python
      quay_check_image_exists(repository='{{ inputs.namespace }}/{{ inputs.application }}/{{ inputs.component }}', tag='{{ validated_sha.sha }}', namespace='redhat-user-workloads')
      ```

      {% elif security_status and security_status.block_release %}
      üîí **Security Gate BLOCKED**

      Critical vulnerabilities found - release blocked.

      - **Critical:** {{ security_status.critical }}
      - **High:** {{ security_status.high }}
      {% if security_status.cves %}
      - **CVEs:** {{ security_status.cves | join(', ') }}
      {% endif %}

      **Action:** Fix critical vulnerabilities before releasing.

      {% elif release_status.already_released %}
      ‚ö†Ô∏è **Already Released**

      Commit `{{ validated_sha.short }}` appears to have already been released.

      {% elif inputs.dry_run %}
      ‚úÖ **Ready to Release (Dry Run)**

      All checks passed. Would create release for:
      - **Image:** `{{ validated_sha.sha }}`
      - **Component:** `{{ inputs.component }}`

      To create the release:
      ```python
      skill_run("release_to_prod", '{"commit_sha": "{{ validated_sha.sha }}", "dry_run": false}')
      ```

      {% elif release_result and release_result.success %}
      ‚úÖ **Release Created Successfully**

      {% if release_result.release_name %}
      **Release Name:** `{{ release_result.release_name }}`
      {% endif %}

      {{ release_result.raw }}

      **Next Steps:**
      1. Monitor the release pipeline in Konflux
      2. Verify image appears in production Quay
      3. Monitor app-interface for deployment

      ```python
      konflux_list_releases(namespace='{{ inputs.namespace }}', limit=5)
      ```

      {% else %}
      ‚ùå **Release Failed**

      {{ release_result.raw if release_result else "Could not create release" }}

      Check:
      - Konflux access permissions
      - Component exists and is healthy
      - VPN connection

      {% endif %}

      ---

      ### Component Status

      {% if component_status.component_found %}
      ‚úÖ Component `{{ inputs.component }}` found
      {% else %}
      ‚ö†Ô∏è Component `{{ inputs.component }}` not found. Available components:
      ```
      {{ component_status.components_list }}
      ```
      {% endif %}

      ### Recent Releases

      ```
      {{ release_status.recent_releases }}
      ```

      {% if prod_release_gotchas and prod_release_gotchas.has_gotchas %}
      ---

      ### ‚ö†Ô∏è Release Gotchas

      {% for gotcha in prod_release_gotchas.gotchas[:3] %}
      - {{ gotcha }}
      {% endfor %}
      {% endif %}

      {% if release_known_issues and release_known_issues.has_known_issues %}
      ---

      ### üí° Known Issues

      {% for issue in release_known_issues.issues[:3] %}
      - {{ issue.pattern if issue.pattern else issue }}
      {% endfor %}
      {% endif %}

  - name: context
    value:
      sha: "{{ validated_sha.sha }}"
      image_exists: "{{ staging_status.exists }}"
      already_released: "{{ release_status.already_released }}"
      release_created: "{{ release_result.success if release_result else false }}"
      dry_run: "{{ inputs.dry_run }}"
