# Skill: Start Work on Jira Issue
# Combines issue lookup, branch creation/checkout, MR feedback, and status update

name: start_work
description: |
  Begin or resume working on a Jira issue.

  If 'repo' is not provided, automatically resolves the repository from the
  issue key prefix (e.g., AAP â†’ automation-analytics-backend) using config.json.

  Features:
  - Gets issue context from Jira
  - Creates or checks out feature branch
  - Shows MR feedback if exists
  - Updates Jira status

  Uses MCP tools: jira_view_issue, git_fetch, git_branch_list, git_checkout,
                  git_branch_create, git_pull, gitlab_mr_list, gitlab_mr_view,
                  gitlab_mr_comments, gitlab_ci_status, jira_set_status
version: "1.5"

inputs:
  - name: issue_key
    type: string
    required: true
    description: "Jira issue key (e.g., AAP-12345)"
  - name: repo
    type: string
    required: false
    default: ""
    description: "Repository path - if not provided, resolved from issue key via config"
  - name: repo_name
    type: string
    required: false
    description: "Repository name from config (e.g., 'automation-analytics-backend') - alternative to repo path"

  - name: auto_stash
    type: boolean
    required: false
    default: true
    description: "Automatically stash uncommitted changes before checkout (default: true)"

  - name: slack_format
    type: boolean
    required: false
    default: false
    description: "Use Slack link format"

steps:
  # ==================== RESOLVE REPOSITORY ====================

  # Step 0: Resolve repository from issue key if not provided
  - name: resolve_repo
    description: "Determine which repo to use based on issue key or explicit input"
    compute: |
      from scripts.common.repo_utils import resolve_repo

      # Use centralized repository resolution
      resolved = resolve_repo(
          repo_path=inputs.repo if inputs.repo and inputs.repo not in ("", ".") else None,
          repo_name=inputs.repo_name if inputs.repo_name else None,
          issue_key=inputs.issue_key,
      )

      result = {
          "path": resolved.path,
          "source": "resolved",
          "gitlab": resolved.gitlab_project or "",
          "name": resolved.name,
          "jira_project": resolved.jira_project,
      }
    output: resolved_repo

  # ==================== PRE-FLIGHT VALIDATION ====================

  # Step 0a: Validate git repository using MCP tool
  - name: validate_git_repo
    description: "Ensure we're in a valid git repository"
    tool: git_status
    args:
      repo: "{{ resolved_repo.path }}"
    output: git_status_result
    on_error: continue

  - name: check_git_status
    description: "Check if git status indicates any issues"
    compute: |
      import os

      repo = resolved_repo["path"]
      git_dir = os.path.join(repo, ".git")

      # Check for rebase/merge in progress
      issues = []
      if os.path.exists(os.path.join(git_dir, "rebase-merge")):
          issues.append("rebase in progress - run 'git rebase --continue' or '--abort'")
      if os.path.exists(os.path.join(git_dir, "MERGE_HEAD")):
          issues.append("merge in progress - run 'git merge --continue' or '--abort'")

      if issues:
          raise ValueError(f"Git operation in progress: {issues[0]}")

      result = {"valid": True, "repo": repo}
    output: git_validation

  # Step 0b: Validate Jira issue key format
  - name: validate_issue_key
    description: "Validate issue key format using shared parser"
    compute: |
      from scripts.common.parsers import validate_jira_key

      key = inputs.issue_key.upper().strip()

      if not validate_jira_key(key):
          raise ValueError(
              f"Invalid issue key format: {inputs.issue_key}. "
              "Expected format: AAP-12345"
          )

      result = key
    output: validated_issue_key

  # Step 1: Get issue details using MCP tool
  - name: get_issue
    tool: jira_view_issue
    args:
      issue_key: "{{ validated_issue_key }}"
    output: issue
    on_error: continue
    # NOTE: Auto-heal is now handled by @auto_heal() decorator on the tool

  - name: check_issue_exists
    description: "Verify issue was found"
    compute: |
      if not issue or "not found" in str(issue).lower():
          raise ValueError(
              f"Jira issue {validated_issue_key} not found. "
              "Check the issue key and try again."
          )
      result = "Issue found"
    output: issue_check

  # Step 2: Fetch latest using MCP tool
  - name: fetch_all
    description: "Fetch all remotes"
    tool: git_fetch
    args:
      repo: "{{ resolved_repo.path }}"
      prune: true
    output: fetch_result
    on_error: continue

  # Step 3: Check for existing branch using MCP tool
  - name: list_branches
    description: "List all branches"
    tool: git_branch_list
    args:
      repo: "{{ resolved_repo.path }}"
      all_branches: true
    output: branches_raw
    on_error: continue

  - name: find_issue_branch
    description: "Find branch matching this issue key using shared parser"
    compute: |
      from scripts.common.parsers import parse_git_branches

      issue_key = inputs.issue_key.upper()

      # Use shared parser with issue key filter
      matching = parse_git_branches(branches_raw or "", issue_key=issue_key)

      if matching:
        result = {"exists": True, "branch": matching[0], "all_matches": matching}
      else:
        result = {"exists": False, "branch": None, "all_matches": []}
    output: branch_check

  # Step 4: If branch exists, check for MR using MCP tool
  - name: search_for_mr
    description: "Search for open MRs matching this issue"
    condition: "{{ branch_check.get('exists', False) and resolved_repo.get('gitlab') }}"
    tool: gitlab_mr_list
    args:
      project: "{{ resolved_repo.gitlab }}"
    output: open_mrs_raw
    on_error: continue

  - name: find_matching_mr
    description: "Find MR matching our issue key or branch using shared parser"
    condition: "{{ branch_check.get('exists', False) }}"
    compute: |
      from scripts.common.parsers import extract_mr_id_from_text

      issue_key = inputs.issue_key.upper()
      branch = branch_check['branch']

      mr_info = None
      if open_mrs_raw:
        for line in str(open_mrs_raw).split('\n'):
          # Check if this MR matches our issue key or branch
          if issue_key in line.upper() or (branch and branch in line):
            # Use shared parser to extract MR ID
            mr_id = extract_mr_id_from_text(line)
            if mr_id:
              mr_info = {"id": mr_id, "line": line.strip()}
              break

      result = mr_info
    output: existing_mr

  # Step 5: If MR exists, get comments/feedback using MCP tools
  - name: get_mr_details
    description: "Get MR details"
    condition: "{{ existing_mr and existing_mr.get('id') and resolved_repo.get('gitlab') }}"
    tool: gitlab_mr_view
    args:
      project: "{{ resolved_repo.gitlab }}"
      mr_id: "{{ existing_mr.id }}"
    output: mr_details_raw
    on_error: continue

  - name: get_mr_comments
    description: "Get MR review comments"
    condition: "{{ existing_mr and existing_mr.get('id') and resolved_repo.get('gitlab') }}"
    tool: gitlab_mr_comments
    args:
      project: "{{ resolved_repo.gitlab }}"
      mr_id: "{{ existing_mr.id }}"
    output: mr_comments_raw
    on_error: continue

  - name: get_pipeline_status
    description: "Get CI pipeline status"
    condition: "{{ existing_mr and resolved_repo.get('gitlab') }}"
    tool: gitlab_ci_status
    args:
      project: "{{ resolved_repo.gitlab }}"
      branch: "{{ branch_check.branch }}"
    output: pipeline_status_raw
    on_error: continue

  - name: analyze_mr_feedback
    description: "Analyze MR feedback for actionable items using shared parser"
    condition: "{{ existing_mr and existing_mr.get('id') }}"
    compute: |
      from scripts.common.parsers import is_bot_comment

      mr_id = existing_mr['id']
      details = str(mr_details_raw)[:1000] if mr_details_raw else ""
      comments = str(mr_comments_raw)[:1500] if mr_comments_raw else ""
      pipeline = str(pipeline_status_raw)[:200] if pipeline_status_raw else "unknown"

      # Check if there's actionable feedback (filter out bot comments)
      has_feedback = False
      if comments and "No notes found" not in comments:
        for line in comments.split('\n'):
          if line.strip() and not is_bot_comment(line, ""):
            has_feedback = True
            break

      result = {
        "mr_id": mr_id,
        "details": details,
        "comments": comments,
        "has_feedback": has_feedback,
        "pipeline": pipeline
      }
    output: mr_feedback
    on_error: continue

  # Step 6: Check Jira for recent updates
  - name: check_jira_updates
    description: "Check for recent Jira comments or status changes"
    condition: "{{ branch_check.get('exists', False) }}"
    tool: jira_view_issue
    args:
      issue_key: "{{ validated_issue_key }}"
    output: jira_details_raw
    on_error: continue

  - name: parse_jira_updates
    description: "Parse Jira details for updates using shared parser"
    condition: "{{ branch_check.get('exists', False) }}"
    compute: |
      from scripts.common.parsers import parse_jira_status

      jira_updates = {"status": "Unknown", "recent_comments": [], "has_updates": False}

      if jira_details_raw:
        details = str(jira_details_raw)

        # Use shared parser to extract status
        status = parse_jira_status(details)
        if status:
          jira_updates["status"] = status

        # Look for comments section
        if "Comment" in details or "comment" in details:
          jira_updates["has_updates"] = True

      result = jira_updates
    output: jira_updates
    on_error: continue

  # Step 7: Generate branch name (only used if creating new)
  # Branch name MUST start with "AAP-XXXXX" per validate-mr in .gitlab-ci.yml
  # Pattern required: ^aap-[0-9]{3,6} at start of branch name (case insensitive)
  - name: create_branch_name
    condition: "{{ not branch_check.get('exists', False) }}"
    compute: |
      from scripts.common.parsers import slugify_text

      key = inputs.issue_key.upper()  # Use uppercase AAP-XXXXX format
      # Extract summary from issue output and slugify using shared parser
      issue_text = str(issue)
      summary = slugify_text(issue_text, max_length=40)
      # Branch format: AAP-XXXXX-description
      branch_name = f"{key}-{summary}"
    output: new_branch_name

  # Step 7b: Stash uncommitted changes if needed
  - name: stash_changes
    description: "Stash any uncommitted changes before checkout"
    condition: "inputs.get('auto_stash', True)"
    tool: git_stash
    args:
      repo: "{{ resolved_repo.path }}"
      action: "push"
      message: "Auto-stash before switching to {{ inputs.issue_key }}"
    output: stash_result
    on_error: continue

  - name: parse_stash_result
    description: "Parse stash result"
    compute: |
      stash_text = str(stash_result) if 'stash_result' in dir() and stash_result else ""
      had_changes = "Saved" in stash_text or "saved" in stash_text
      result = {
        "had_changes": had_changes,
        "message": stash_text[:100] if stash_text else "No changes to stash",
      }
    output: stash_info
    on_error: continue

  # Step 8a: Checkout existing branch using MCP tool
  - name: checkout_existing
    description: "Checkout existing branch for this issue"
    condition: "{{ branch_check.get('exists', False) }}"
    tool: git_checkout
    args:
      repo: "{{ resolved_repo.path }}"
      target: "{{ branch_check.branch }}"
    output: checkout_result
    on_error: continue

  - name: pull_latest
    description: "Pull latest changes"
    condition: "{{ branch_check.get('exists', False) }}"
    tool: git_pull
    args:
      repo: "{{ resolved_repo.path }}"
      rebase: true
    output: pull_result
    on_error: continue

  # Step 8b: Create new branch using MCP tools
  - name: checkout_main
    description: "Checkout main branch"
    condition: "{{ not branch_check.get('exists', False) }}"
    tool: git_checkout
    args:
      repo: "{{ resolved_repo.path }}"
      target: "main"
    output: main_checkout_result
    on_error: continue

  - name: pull_main
    description: "Pull latest main"
    condition: "{{ not branch_check.get('exists', False) }}"
    tool: git_pull
    args:
      repo: "{{ resolved_repo.path }}"
      rebase: true
    output: main_pull_result
    on_error: continue

  - name: create_new_branch
    description: "Create new feature branch"
    condition: "{{ not branch_check.get('exists', False) }}"
    tool: git_branch_create
    args:
      repo: "{{ resolved_repo.path }}"
      branch_name: "{{ new_branch_name }}"
      checkout: true
    output: create_result
    on_error: continue

  # Step 9: Update Jira status (only for new work)
  - name: update_status
    condition: "{{ not branch_check.get('exists', False) }}"
    tool: jira_set_status
    args:
      issue_key: "{{ inputs.issue_key }}"
      status: "In Progress"
    on_error: continue

  # Step 9b: Transition issue using workflow transition (more reliable)
  - name: transition_issue
    description: "Transition issue to In Progress via workflow"
    condition: "{{ not branch_check.get('exists', False) }}"
    tool: jira_transition
    args:
      issue_key: "{{ inputs.issue_key }}"
      transition: "Start Progress"
    output: transition_result
    on_error: continue

  # Step 9c: Assign issue to current user
  - name: assign_issue
    description: "Assign issue to current user"
    condition: "{{ not branch_check.get('exists', False) }}"
    tool: jira_assign
    args:
      issue_key: "{{ inputs.issue_key }}"
      assignee: "currentUser"
    output: assign_result
    on_error: continue

  # Step 10: Determine final branch name
  - name: get_final_branch
    compute: |
      if branch_check.get('exists', False):
        result = branch_check['branch']
      else:
        result = new_branch_name
    output: final_branch

  # ==================== MEMORY INTEGRATION ====================

  # Step 11: Log session action
  - name: log_session
    description: "Log work start to session log"
    tool: memory_session_log
    args:
      action: "{{ 'Resumed' if branch_check.exists else 'Started' }} work on {{ inputs.issue_key }}"
      details: "Branch: {{ final_branch }}, Repo: {{ resolved_repo.path }}"
    on_error: continue

  # Step 11b: Notify team on Slack (optional)
  - name: notify_slack_start
    description: "Post to team channel that work started"
    condition: "not branch_check.exists"
    compute: |
      from scripts.common.parsers import linkify_jira_keys
      is_slack = inputs.get('slack_format', True)
      msg = f"ðŸš€ Started work on {inputs.issue_key}"
      result = linkify_jira_keys(msg, slack_format=is_slack)
    output: slack_msg

  - name: post_slack_start
    description: "Post to team channel"
    condition: "not branch_check.exists"
    tool: slack_post_message
    args:
      channel: "team-automation-analytics"
      message: "{{ slack_msg }}"
    output: slack_notify_result
    on_error: continue

  # Step 12: Build issue summary and timestamp for memory
  - name: build_memory_context
    description: "Extract issue summary and generate timestamp"
    compute: |
      import re
      from datetime import datetime

      issue_text = str(issue) if issue else ""
      # Extract summary from various formats
      summary = ""
      if "summary:" in issue_text.lower():
        match = re.search(r'summary:\s*(.+?)(?:\n|$)', issue_text, re.IGNORECASE)
        if match:
          summary = match.group(1).strip()[:80]
      elif "|" in issue_text:
        # Table format: | AAP-12345 | Summary here |
        parts = issue_text.split("|")
        if len(parts) > 2:
          summary = parts[2].strip()[:80]
      if not summary:
        summary = issue_text[:80] if issue_text else "No summary"

      result = {
        "summary": summary,
        "timestamp": datetime.now().isoformat()
      }
    output: memory_context

  # Step 13: Update active_issues in memory (only for new work)
  - name: update_memory_active_issues
    description: "Add issue to active_issues in memory"
    condition: "{{ not branch_check.get('exists', False) }}"
    tool: memory_append
    args:
      key: "state/current_work"
      list_path: "active_issues"
      item: |
        key: {{ inputs.issue_key }}
        summary: "{{ memory_context.summary }}"
        status: "In Progress"
        branch: "{{ final_branch }}"
        repo: "{{ resolved_repo.path }}"
        started: "{{ memory_context.timestamp }}"
    on_error: continue

  # Step 14: Update last_updated timestamp
  - name: update_memory_timestamp
    description: "Update last_updated in current_work"
    tool: memory_update
    args:
      key: "state/current_work"
      path: "last_updated"
      value: "{{ memory_context.timestamp }}"
    on_error: continue

outputs:
  - name: summary
    value: |
      {% set is_slack = inputs.slack_format | default(true) %}
      {% if is_slack %}
      ## {{ "ðŸ“‚ Resuming" if branch_check.exists else "âœ¨ Starting" }} Work on <https://issues.redhat.com/browse/{{ inputs.issue_key }}|{{ inputs.issue_key }}>
      {% else %}
      ## {{ "ðŸ“‚ Resuming" if branch_check.exists else "âœ¨ Starting" }} Work on [{{ inputs.issue_key }}](https://issues.redhat.com/browse/{{ inputs.issue_key }})
      {% endif %}

      **Issue:** {{ issue }}
      **Branch:** `{{ final_branch }}`
      {% if stash_info and stash_info.had_changes %}

      ðŸ“¦ **Stashed changes:** {{ stash_info.message }}

      _Tip: Run `git stash pop` when you want to restore these changes._

      {% endif %}
      {% if branch_check.exists %}

      ---
      {% if mr_feedback and mr_feedback.has_feedback %}

      {% set mr_url = "https://gitlab.cee.redhat.com/" ~ (resolved_repo.gitlab or "automation-analytics/automation-analytics-backend") ~ "/-/merge_requests/" ~ mr_feedback.mr_id %}
      {% if is_slack %}
      ### ðŸ’¬ MR Feedback (<{{ mr_url }}|!{{ mr_feedback.mr_id }}>)
      {% else %}
      ### ðŸ’¬ MR Feedback ([!{{ mr_feedback.mr_id }}]({{ mr_url }}))
      {% endif %}

      There are review comments on your MR:

      ```
      {{ mr_feedback.comments[:800] }}
      ```

      **Pipeline:** {{ mr_feedback.pipeline }}

      {% endif %}
      {% if jira_updates and jira_updates.has_updates %}

      ### ðŸ“‹ Recent Jira Updates

      **Status:** {{ jira_updates.status }}

      {% endif %}
      {% if (mr_feedback and mr_feedback.has_feedback) or (jira_updates and jira_updates.has_updates) %}

      ---

      ### ðŸ¤” What would you like to do?

      1. **Address MR feedback** - I can help review the comments and suggest fixes
      2. **Check full MR details** - `gitlab_mr_view`
      3. **View full Jira context** - `jira_view_issue`
      4. **Continue coding** - Just start working

      {% else %}

      âœ… No pending feedback - you're good to continue!

      **What would you like to do next?**

      {% endif %}
      {% else %}

      âœ¨ *Created new branch*

      ### Next Steps
      1. Make your changes
      2. Commit: `git_commit(repo=".", message="your description", issue_key="{{ inputs.issue_key }}")`
      3. When ready: `skill_run("create_mr", '{"issue_key": "{{ inputs.issue_key }}", "repo": "{{ resolved_repo.path }}"}')`

      {% endif %}

  - name: context
    value:
      issue: "{{ issue }}"
      branch: "{{ final_branch }}"
      repo: "{{ resolved_repo.path }}"
      gitlab_project: "{{ resolved_repo.gitlab }}"
      repo_source: "{{ resolved_repo.source }}"
      was_existing: "{{ branch_check.exists }}"
      has_mr: "{{ existing_mr is not none }}"
      has_feedback: "{{ mr_feedback.has_feedback if mr_feedback else false }}"
      mr_id: "{{ mr_feedback.mr_id if mr_feedback else none }}"
