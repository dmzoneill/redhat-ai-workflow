# Skill: Start Work on Jira Issue
# Combines issue lookup, branch creation/checkout, MR feedback, and status update

name: start_work
description: |
  Begin or resume working on a Jira issue.
  
  If 'repo' is not provided, automatically resolves the repository from the
  issue key prefix (e.g., AAP â†’ automation-analytics-backend) using config.json.
  
  Features:
  - Gets issue context from Jira
  - Creates or checks out feature branch
  - Shows MR feedback if exists
  - Updates Jira status
  
  Uses MCP tools: jira_view_issue, git_fetch, git_branch_list, git_checkout,
                  git_branch_create, git_pull, gitlab_mr_list, gitlab_mr_view,
                  gitlab_mr_comments, gitlab_ci_status, jira_set_status
version: "1.4"

inputs:
  - name: issue_key
    type: string
    required: true
    description: "Jira issue key (e.g., AAP-12345)"
  - name: repo
    type: string
    required: false
    default: ""
    description: "Repository path - if not provided, resolved from issue key via config"
  - name: repo_name
    type: string
    required: false
    description: "Repository name from config (e.g., 'automation-analytics-backend') - alternative to repo path"

steps:
  # ==================== RESOLVE REPOSITORY ====================

  # Step 0: Resolve repository from issue key if not provided
  - name: resolve_repo
    description: "Determine which repo to use based on issue key or explicit input"
    compute: |
      import json
      import os
      from pathlib import Path

      # Explicit repo path takes priority
      if inputs.repo and inputs.repo != "" and inputs.repo != ".":
          repo_path = inputs.repo
          gitlab_project = None
          repo_source = "explicit"
      # Then repo name from config
      elif inputs.repo_name:
          config_paths = [
              Path.cwd() / "config.json",
              Path.home() / "src/redhat-ai-workflow/config.json",
          ]
          config = {}
          for p in config_paths:
              if p.exists():
                  with open(p) as f:
                      config = json.load(f)
                  break
          
          repos = config.get("repositories", {})
          if inputs.repo_name in repos:
              repo_path = repos[inputs.repo_name].get("path", "")
              gitlab_project = repos[inputs.repo_name].get("gitlab", "")
              repo_source = "config_name"
          else:
              raise ValueError(f"Repository '{inputs.repo_name}' not found in config.json")
      # Finally, try to resolve from issue key prefix
      else:
          # Load config
          config_paths = [
              Path.cwd() / "config.json",
              Path.home() / "src/redhat-ai-workflow/config.json",
          ]
          config = {}
          for p in config_paths:
              if p.exists():
                  with open(p) as f:
                      config = json.load(f)
                  break
          
          repos = config.get("repositories", {})
          project_prefix = inputs.issue_key.split("-")[0].upper()
          
          # Find repos matching this Jira project
          matching = []
          for name, cfg in repos.items():
              if cfg.get("jira_project") == project_prefix:
                  matching.append({"name": name, "path": cfg.get("path"), "gitlab": cfg.get("gitlab")})
          
          if len(matching) == 0:
              # Fall back to cwd if we're in a git repo
              cwd = os.getcwd()
              git_check = os.path.exists(os.path.join(cwd, ".git"))
              if git_check:
                  repo_path = cwd
                  gitlab_project = None
                  repo_source = "cwd_fallback"
              else:
                  raise ValueError(
                      f"No repository configured for {project_prefix} issues. "
                      "Please specify 'repo' or 'repo_name', or run from within a git repository."
                  )
          elif len(matching) == 1:
              repo_path = matching[0]["path"]
              gitlab_project = matching[0]["gitlab"]
              repo_source = "issue_key"
          else:
              # Multiple matches - need clarification
              names = ", ".join(m["name"] for m in matching)
              raise ValueError(
                  f"Multiple repositories match {project_prefix} issues: {names}. "
                  "Please specify 'repo_name' to choose one."
              )
      
      if not repo_path or not os.path.exists(repo_path):
          raise ValueError(f"Repository path not found: {repo_path}")
      
      result = {"path": repo_path, "source": repo_source, "gitlab": gitlab_project or ""}
    output: resolved_repo

  # ==================== PRE-FLIGHT VALIDATION ====================

  # Step 0a: Validate git repository using MCP tool
  - name: validate_git_repo
    description: "Ensure we're in a valid git repository"
    tool: git_status
    args:
      repo: "{{ resolved_repo.path }}"
    output: git_status_result
    on_error: continue

  - name: check_git_status
    description: "Check if git status indicates any issues"
    compute: |
      import os
      
      repo = resolved_repo["path"]
      git_dir = os.path.join(repo, ".git")
      
      # Check for rebase/merge in progress
      issues = []
      if os.path.exists(os.path.join(git_dir, "rebase-merge")):
          issues.append("rebase in progress - run 'git rebase --continue' or '--abort'")
      if os.path.exists(os.path.join(git_dir, "MERGE_HEAD")):
          issues.append("merge in progress - run 'git merge --continue' or '--abort'")
      
      if issues:
          raise ValueError(f"Git operation in progress: {issues[0]}")
      
      result = {"valid": True, "repo": repo}
    output: git_validation

  # Step 0b: Validate Jira issue key format
  - name: validate_issue_key
    description: "Validate issue key format"
    compute: |
      import re

      key = inputs.issue_key.upper().strip()

      if not re.match(r"^[A-Z]+-\d+$", key):
          raise ValueError(
              f"Invalid issue key format: {inputs.issue_key}. "
              "Expected format: AAP-12345"
          )

      result = key
    output: validated_issue_key

  # Step 1: Get issue details using MCP tool
  - name: get_issue
    tool: jira_view_issue
    args:
      issue_key: "{{ validated_issue_key }}"
    output: issue
    on_error: continue

  - name: check_issue_exists
    description: "Verify issue was found"
    compute: |
      if not issue or "not found" in str(issue).lower():
          raise ValueError(
              f"Jira issue {validated_issue_key} not found. "
              "Check the issue key and try again."
          )
      result = "Issue found"
    output: issue_check

  # Step 2: Fetch latest using MCP tool
  - name: fetch_all
    description: "Fetch all remotes"
    tool: git_fetch
    args:
      repo: "{{ resolved_repo.path }}"
      prune: true
    output: fetch_result
    on_error: continue

  # Step 3: Check for existing branch using MCP tool
  - name: list_branches
    description: "List all branches"
    tool: git_branch_list
    args:
      repo: "{{ resolved_repo.path }}"
      all_branches: true
    output: branches_raw
    on_error: continue

  - name: find_issue_branch
    description: "Find branch matching this issue key"
    compute: |
      import re
      
      issue_key = inputs.issue_key.upper()
      
      matching = []
      if branches_raw:
        for line in str(branches_raw).split('\n'):
          branch = line.strip().replace('* ', '').strip()
          if issue_key in branch.upper():
            clean_name = branch.replace('remotes/origin/', '')
            if clean_name and clean_name not in matching:
              matching.append(clean_name)
      
      if matching:
        result = {"exists": True, "branch": matching[0], "all_matches": matching}
      else:
        result = {"exists": False, "branch": None, "all_matches": []}
    output: branch_check

  # Step 4: If branch exists, check for MR using MCP tool
  - name: search_for_mr
    description: "Search for open MRs matching this issue"
    condition: "{{ branch_check.get('exists', False) and resolved_repo.get('gitlab') }}"
    tool: gitlab_mr_list
    args:
      project: "{{ resolved_repo.gitlab }}"
    output: open_mrs_raw
    on_error: continue

  - name: find_matching_mr
    description: "Find MR matching our issue key or branch"
    condition: "{{ branch_check.get('exists', False) }}"
    compute: |
      import re
      
      issue_key = inputs.issue_key.upper()
      branch = branch_check['branch']
      
      mr_info = None
      if open_mrs_raw:
        for line in str(open_mrs_raw).split('\n'):
          # Check if this MR matches our issue key or branch
          if issue_key in line.upper() or (branch and branch in line):
            # Extract MR ID (usually first number in the line)
            match = re.search(r'!(\d+)', line)
            if match:
              mr_info = {"id": int(match.group(1)), "line": line.strip()}
              break
      
      result = mr_info
    output: existing_mr

  # Step 5: If MR exists, get comments/feedback using MCP tools
  - name: get_mr_details
    description: "Get MR details"
    condition: "{{ existing_mr and existing_mr.get('id') and resolved_repo.get('gitlab') }}"
    tool: gitlab_mr_view
    args:
      project: "{{ resolved_repo.gitlab }}"
      mr_id: "{{ existing_mr.id }}"
    output: mr_details_raw
    on_error: continue

  - name: get_mr_comments
    description: "Get MR review comments"
    condition: "{{ existing_mr and existing_mr.get('id') and resolved_repo.get('gitlab') }}"
    tool: gitlab_mr_comments
    args:
      project: "{{ resolved_repo.gitlab }}"
      mr_id: "{{ existing_mr.id }}"
    output: mr_comments_raw
    on_error: continue

  - name: get_pipeline_status
    description: "Get CI pipeline status"
    condition: "{{ existing_mr and resolved_repo.get('gitlab') }}"
    tool: gitlab_ci_status
    args:
      project: "{{ resolved_repo.gitlab }}"
      branch: "{{ branch_check.branch }}"
    output: pipeline_status_raw
    on_error: continue

  - name: analyze_mr_feedback
    description: "Analyze MR feedback for actionable items"
    condition: "{{ existing_mr and existing_mr.get('id') }}"
    compute: |
      # Import shared parsers
      import sys
      sys.path.insert(0, '/home/daoneill/src/redhat-ai-workflow/scripts')
      from common.parsers import BOT_PATTERNS, is_bot_comment
      
      mr_id = existing_mr['id']
      details = str(mr_details_raw)[:1000] if mr_details_raw else ""
      comments = str(mr_comments_raw)[:1500] if mr_comments_raw else ""
      pipeline = str(pipeline_status_raw)[:200] if pipeline_status_raw else "unknown"
      
      # Check if there's actionable feedback (filter out bot comments)
      has_feedback = False
      if comments and "No notes found" not in comments:
        for line in comments.split('\n'):
          if line.strip() and not is_bot_comment(line, ""):
            has_feedback = True
            break
      
      result = {
        "mr_id": mr_id,
        "details": details,
        "comments": comments,
        "has_feedback": has_feedback,
        "pipeline": pipeline
      }
    output: mr_feedback
    on_error: continue

  # Step 6: Check Jira for recent updates
  - name: check_jira_updates
    description: "Check for recent Jira comments or status changes"
    condition: "{{ branch_check.get('exists', False) }}"
    tool: jira_view_issue
    args:
      issue_key: "{{ validated_issue_key }}"
    output: jira_details_raw
    on_error: continue

  - name: parse_jira_updates
    description: "Parse Jira details for updates"
    condition: "{{ branch_check.get('exists', False) }}"
    compute: |
      import re
      
      jira_updates = {"status": "Unknown", "recent_comments": [], "has_updates": False}
      
      if jira_details_raw:
        details = str(jira_details_raw)
        
        # Try to extract status
        status_match = re.search(r'Status:\s*(\S+)', details)
        if status_match:
          jira_updates["status"] = status_match.group(1)
        
        # Look for comments section
        if "Comment" in details or "comment" in details:
          jira_updates["has_updates"] = True
      
      result = jira_updates
    output: jira_updates
    on_error: continue

  # Step 7: Generate branch name (only used if creating new)
  - name: create_branch_name
    condition: "{{ not branch_check.get('exists', False) }}"
    compute: |
      import re
      key = inputs.issue_key.upper()
      # Extract summary from issue output
      issue_text = str(issue)
      summary = issue_text[:40].lower()
      summary = re.sub(r'[^a-z0-9]+', '-', summary).strip('-')
      branch_name = f"{key}-{summary}"
    output: new_branch_name

  # Step 8a: Checkout existing branch using MCP tool
  - name: checkout_existing
    description: "Checkout existing branch for this issue"
    condition: "{{ branch_check.get('exists', False) }}"
    tool: git_checkout
    args:
      repo: "{{ resolved_repo.path }}"
      target: "{{ branch_check.branch }}"
    output: checkout_result
    on_error: continue

  - name: pull_latest
    description: "Pull latest changes"
    condition: "{{ branch_check.get('exists', False) }}"
    tool: git_pull
    args:
      repo: "{{ resolved_repo.path }}"
      rebase: true
    output: pull_result
    on_error: continue

  # Step 8b: Create new branch using MCP tools
  - name: checkout_main
    description: "Checkout main branch"
    condition: "{{ not branch_check.get('exists', False) }}"
    tool: git_checkout
    args:
      repo: "{{ resolved_repo.path }}"
      target: "main"
    output: main_checkout_result
    on_error: continue

  - name: pull_main
    description: "Pull latest main"
    condition: "{{ not branch_check.get('exists', False) }}"
    tool: git_pull
    args:
      repo: "{{ resolved_repo.path }}"
      rebase: true
    output: main_pull_result
    on_error: continue

  - name: create_new_branch
    description: "Create new feature branch"
    condition: "{{ not branch_check.get('exists', False) }}"
    tool: git_branch_create
    args:
      repo: "{{ resolved_repo.path }}"
      branch_name: "{{ new_branch_name }}"
      checkout: true
    output: create_result
    on_error: continue

  # Step 9: Update Jira status (only for new work)
  - name: update_status
    condition: "{{ not branch_check.get('exists', False) }}"
    tool: jira_set_status
    args:
      issue_key: "{{ inputs.issue_key }}"
      status: "In Progress"
    on_error: continue

  # Step 10: Determine final branch name
  - name: get_final_branch
    compute: |
      if branch_check.get('exists', False):
        result = branch_check['branch']
      else:
        result = new_branch_name
    output: final_branch

outputs:
  - name: summary
    value: |
      ## {{ "ðŸ“‚ Resuming" if branch_check.exists else "âœ¨ Starting" }} Work on {{ inputs.issue_key }}
      
      **Issue:** {{ issue }}
      **Branch:** `{{ final_branch }}`
      {% if branch_check.exists %}
      
      ---
      {% if mr_feedback and mr_feedback.has_feedback %}
      
      ### ðŸ’¬ MR Feedback ({{ mr_feedback.mr_id }})
      
      There are review comments on your MR:
      
      ```
      {{ mr_feedback.comments[:800] }}
      ```
      
      **Pipeline:** {{ mr_feedback.pipeline }}
      
      {% endif %}
      {% if jira_updates and jira_updates.has_updates %}
      
      ### ðŸ“‹ Recent Jira Updates
      
      **Status:** {{ jira_updates.status }}
      
      {% endif %}
      {% if (mr_feedback and mr_feedback.has_feedback) or (jira_updates and jira_updates.has_updates) %}
      
      ---
      
      ### ðŸ¤” What would you like to do?
      
      1. **Address MR feedback** - I can help review the comments and suggest fixes
      2. **Check full MR details** - `gitlab_mr_view`
      3. **View full Jira context** - `jira_view_issue`
      4. **Continue coding** - Just start working
      
      {% else %}
      
      âœ… No pending feedback - you're good to continue!
      
      **What would you like to do next?**
      
      {% endif %}
      {% else %}
      
      âœ¨ *Created new branch*
      
      ### Next Steps
      1. Make your changes
      2. Commit: `git commit -m "{{ inputs.issue_key }} - feat: description"`
      3. When ready: `skill_run("create_mr", '{"issue_key": "{{ inputs.issue_key }}", "repo": "{{ resolved_repo.path }}"}')`
      
      {% endif %}
  
  - name: context
    value:
      issue: "{{ issue }}"
      branch: "{{ final_branch }}"
      repo: "{{ resolved_repo.path }}"
      gitlab_project: "{{ resolved_repo.gitlab }}"
      repo_source: "{{ resolved_repo.source }}"
      was_existing: "{{ branch_check.exists }}"
      has_mr: "{{ existing_mr is not none }}"
      has_feedback: "{{ mr_feedback.has_feedback if mr_feedback else false }}"
      mr_id: "{{ mr_feedback.mr_id if mr_feedback else none }}"
