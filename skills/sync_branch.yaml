# Skill: Sync Branch with Main
# Quick rebase of current branch onto main

name: sync_branch
description: |
  Quickly sync current branch with main using rebase.
  
  Less aggressive than rebase_pr - good for ongoing work:
  - Fetches latest main
  - Rebases current branch onto main
  - Auto-resolves simple conflicts
  - Reports status
  
  Uses MCP tools: git_status, git_fetch, git_stash, git_push
version: "1.2"

inputs:
  - name: repo
    type: string
    required: false
    default: ""
    description: "Repository path - if not provided, resolved from issue_key or repo_name"

  - name: repo_name
    type: string
    required: false
    description: "Repository name from config (e.g., 'automation-analytics-backend')"

  - name: issue_key
    type: string
    required: false
    description: "Jira issue key - used to resolve repo if repo not specified"

  - name: base_branch
    type: string
    required: false
    default: ""
    description: "Branch to sync with (default: repo's default_branch from config)"

  - name: stash_changes
    type: boolean
    required: false
    default: true
    description: "Stash uncommitted changes before rebase"

  - name: force_push
    type: boolean
    required: false
    default: false
    description: "Force push after successful rebase"

steps:
  # ==================== RESOLVE REPOSITORY ====================

  - name: resolve_repo
    description: "Determine which repo to use"
    compute: |
      import os
      from scripts.common.config_loader import load_config
      
      repo_path = None
      default_branch = "main"
      
      # Load config using shared loader
      config = load_config()
      repos = config.get("repositories", {})

      if inputs.repo and inputs.repo != "" and inputs.repo != ".":
          repo_path = inputs.repo
          for name, cfg in repos.items():
              if cfg.get("path") == repo_path:
                  default_branch = cfg.get("default_branch", "main")
                  break
      elif inputs.repo_name and inputs.repo_name in repos:
          cfg = repos[inputs.repo_name]
          repo_path = cfg.get("path")
          default_branch = cfg.get("default_branch", "main")
      elif inputs.issue_key:
          project_prefix = inputs.issue_key.split("-")[0].upper()
          for name, cfg in repos.items():
              if cfg.get("jira_project") == project_prefix:
                  repo_path = cfg.get("path")
                  default_branch = cfg.get("default_branch", "main")
                  break
      else:
          cwd = os.getcwd()
          if os.path.exists(os.path.join(cwd, ".git")):
              repo_path = cwd
              for name, cfg in repos.items():
                  if cfg.get("path") == cwd:
                      default_branch = cfg.get("default_branch", "main")
                      break

      if not repo_path:
          raise ValueError("Repository not specified.")

      if inputs.base_branch:
          default_branch = inputs.base_branch

      result = {"path": repo_path, "default_branch": default_branch}
    output: resolved_repo

  # ==================== PRE-FLIGHT (using MCP tools) ====================

  - name: check_git_status
    description: "Get current branch and check for uncommitted changes"
    tool: git_status
    args:
      repo: "{{ resolved_repo.path }}"
    output: git_status_raw
    on_error: continue

  - name: parse_git_status
    description: "Parse git status output"
    compute: |
      import re
      
      status_output = str(git_status_raw) if git_status_raw else ""
      
      # Extract current branch
      branch_match = re.search(r"On branch (\S+)", status_output)
      branch = branch_match.group(1) if branch_match else None
      
      if not branch:
          raise ValueError("Could not determine current branch")
      
      if branch in ["main", "master"]:
          raise ValueError(f"Already on {branch}. Switch to a feature branch first.")
      
      # Check for uncommitted changes
      has_changes = "Changes not staged" in status_output or "Changes to be committed" in status_output
      
      result = {"branch": branch, "has_changes": has_changes}
    output: branch_status

  # ==================== STASH IF NEEDED (using MCP tool) ====================

  - name: stash_changes
    description: "Stash uncommitted changes"
    condition: "branch_status.has_changes and inputs.stash_changes"
    tool: git_stash
    args:
      repo: "{{ resolved_repo.path }}"
      action: "push"
      message: "sync_branch: auto-stash before rebase"
    output: stash_result
    on_error: continue

  # ==================== FETCH (using MCP tool) ====================

  - name: fetch_base
    description: "Fetch latest from remote"
    tool: git_fetch
    args:
      repo: "{{ resolved_repo.path }}"
      prune: true
    output: fetch_result
    on_error: continue

  # ==================== CHECK COMMITS ====================

  - name: get_commits_behind
    description: "Check how many commits behind"
    tool: git_log
    args:
      repo: "{{ resolved_repo.path }}"
      range_spec: "HEAD..origin/{{ resolved_repo.default_branch }}"
      count_only: true
    output: behind_count_raw

  - name: get_commits_ahead
    description: "Check how many commits ahead"
    tool: git_log
    args:
      repo: "{{ resolved_repo.path }}"
      range_spec: "origin/{{ resolved_repo.default_branch }}..HEAD"
      count_only: true
    output: ahead_count_raw

  - name: parse_commit_status
    description: "Parse commit counts"
    compute: |
      # Parse the count from tool outputs
      def parse_count(raw):
        if raw is None:
          return 0
        text = str(raw).strip()
        # Extract just the number
        for word in text.split():
          if word.isdigit():
            return int(word)
        return 0
      
      behind = parse_count(behind_count_raw)
      ahead = parse_count(ahead_count_raw)
      
      result = {"behind": behind, "ahead": ahead}
    output: commit_status

  # ==================== REBASE ====================

  - name: rebase
    description: "Rebase onto base branch"
    condition: "commit_status.behind > 0"
    tool: git_rebase
    args:
      repo: "{{ resolved_repo.path }}"
      onto: "origin/{{ resolved_repo.default_branch }}"
    output: rebase_raw
    on_error: continue

  - name: check_conflicts
    description: "Check for conflicts after rebase"
    condition: "commit_status.behind > 0 and rebase_raw and 'conflict' in str(rebase_raw).lower()"
    tool: git_status
    args:
      repo: "{{ resolved_repo.path }}"
    output: conflict_status_raw
    on_error: continue

  - name: parse_rebase_result
    description: "Parse rebase result"
    condition: "commit_status.behind > 0"
    compute: |
      rebase_text = str(rebase_raw) if 'rebase_raw' in dir() and rebase_raw else ""
      conflict_text = str(conflict_status_raw) if 'conflict_status_raw' in dir() and conflict_status_raw else ""
      
      if 'success' in rebase_text.lower() or ('conflict' not in rebase_text.lower() and 'error' not in rebase_text.lower() and 'failed' not in rebase_text.lower()):
        rebase_result = {
          "success": True,
          "conflicts": False,
          "message": f"Rebased onto origin/{resolved_repo['default_branch']}",
        }
      else:
        # Parse conflict files from status
        conflict_files = []
        for ln in conflict_text.split("\n"):
          if "both modified" in ln.lower() or "UU" in ln[:3] if len(ln) >= 3 else False:
            parts = ln.split()
            if parts:
              conflict_files.append(parts[-1])
        
        if conflict_files:
          rebase_result = {
            "success": False,
            "conflicts": True,
            "conflict_files": conflict_files[:5],
            "message": f"{len(conflict_files)} file(s) have conflicts",
          }
        else:
          rebase_result = {
            "success": False,
            "conflicts": False,
            "message": rebase_text[:200] if rebase_text else "Unknown error",
          }
      
      result = rebase_result
    output: rebase_result

  - name: skip_rebase_up_to_date
    description: "Branch is already up to date"
    condition: "commit_status.behind == 0"
    compute: |
      result = {
          "success": True,
          "conflicts": False,
          "message": "Already up to date with main",
      }
    output: rebase_result

  # ==================== POP STASH (using MCP tool) ====================

  - name: pop_stash
    description: "Restore stashed changes"
    condition: "stash_result and rebase_result.success"
    tool: git_stash
    args:
      repo: "{{ resolved_repo.path }}"
      action: "pop"
    output: pop_result
    on_error: continue

  # ==================== FORCE PUSH (using MCP tool) ====================

  - name: do_force_push
    description: "Force push rebased branch"
    condition: "rebase_result.success and inputs.force_push and commit_status.behind > 0"
    tool: git_push
    args:
      repo: "{{ resolved_repo.path }}"
      branch: "{{ branch_status.branch }}"
      force: true
    output: push_result
    on_error: continue

outputs:
  - name: summary
    value: |
      ## ğŸ”„ Sync Branch: `{{ branch_status.branch }}`
      
      **Repo:** {{ resolved_repo.path }}
      **Base:** `{{ resolved_repo.default_branch }}`
      **Status:** {{ commit_status.behind }} behind, {{ commit_status.ahead }} ahead
      
      {% if commit_status.behind == 0 %}
      âœ… Already up to date with `{{ resolved_repo.default_branch }}`
      {% elif rebase_result.success %}
      âœ… Successfully rebased onto `{{ resolved_repo.default_branch }}`
      {% if stash_result %}
      - Stashed changes
      - {{ pop_result if pop_result else "Changes restored" }}
      {% endif %}
      {% if push_result %}
      - Pushed to origin
      {% else %}
      
      Ready to push:
      ```bash
      git push --force-with-lease origin {{ branch_status.branch }}
      ```
      {% endif %}
      {% else %}
      
      {% if rebase_result.conflicts %}
      âš ï¸ **Merge Conflicts Detected**
      
      Files with conflicts:
      {% for f in rebase_result.conflict_files %}
      - `{{ f }}`
      {% endfor %}
      
      **To resolve:**
      1. Edit each file (look for `<<<<<<<` markers)
      2. `git add <file>`
      3. `git rebase --continue`
      4. `git push --force-with-lease`
      
      **To abort:** `git rebase --abort`
      {% else %}
      âŒ Rebase failed: {{ rebase_result.message }}
      {% endif %}
      {% endif %}

  - name: context
    value:
      branch: "{{ branch_status.branch }}"
      repo: "{{ resolved_repo.path }}"
      base_branch: "{{ resolved_repo.default_branch }}"
      success: "{{ rebase_result.success }}"
      behind: "{{ commit_status.behind }}"
      ahead: "{{ commit_status.ahead }}"
      pushed: "{{ push_result is defined }}"
