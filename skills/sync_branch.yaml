# Skill: Sync Branch with Main
# Quick rebase of current branch onto main

name: sync_branch
description: |
  Quickly sync current branch with main using rebase.

  Less aggressive than rebase_pr - good for ongoing work:
  - Fetches latest main
  - Rebases current branch onto main
  - Auto-resolves simple conflicts
  - Reports status

  Uses MCP tools: git_status, git_fetch, git_stash, git_push
version: "1.3"

inputs:
  - name: repo
    type: string
    required: false
    default: ""
    description: "Repository path - if not provided, resolved from issue_key or repo_name"

  - name: repo_name
    type: string
    required: false
    description: "Repository name from config (e.g., 'automation-analytics-backend')"

  - name: issue_key
    type: string
    required: false
    description: "Jira issue key - used to resolve repo if repo not specified"

  - name: base_branch
    type: string
    required: false
    default: ""
    description: "Branch to sync with (default: repo's default_branch from config)"

  - name: stash_changes
    type: boolean
    required: false
    default: true
    description: "Stash uncommitted changes before rebase"

  - name: force_push
    type: boolean
    required: false
    default: false
    description: "Force push after successful rebase"

  - name: run_linting
    type: boolean
    required: false
    default: true
    description: "Run linting before force push (if force_push is true)"

steps:

  - name: init_autoheal
    description: "Initialize failure tracking"
    compute: |
      result = {"git_failures": []}
    output: autoheal_state
    on_error: continue

  # ==================== KNOWLEDGE INTEGRATION ====================

  - name: get_git_patterns
    description: "Get git/branching patterns from knowledge base"
    tool: knowledge_query
    args:
      project: "automation-analytics-backend"
      persona: "developer"
      query: "gotchas"
    output: git_knowledge_raw
    on_error: continue

  - name: parse_git_knowledge
    description: "Parse git knowledge for rebase context"
    compute: |
      knowledge_text = str(git_knowledge_raw) if git_knowledge_raw else ""

      gotchas = []

      # Extract gotchas related to git/branching
      if knowledge_text:
          for line in knowledge_text.split("\n"):
              line_lower = line.lower()
              if any(kw in line_lower for kw in ["git", "branch", "rebase", "merge", "conflict", "push", "pull"]):
                  gotchas.append(line.strip()[:150])

      result = {
          "has_knowledge": len(gotchas) > 0,
          "gotchas": gotchas[:5],
      }
    output: git_knowledge
    on_error: continue

  - name: check_rebase_known_issues
    description: "Check for known git rebase issues"
    compute: |
      # Check known issues for git rebase
      rebase_issues = memory.check_known_issues("git_rebase", "") or {}
      git_issues = memory.check_known_issues("git", "") or {}

      all_issues = []
      for issues in [rebase_issues, git_issues]:
          if issues and issues.get("matches"):
              all_issues.extend(issues.get("matches", [])[:2])

      result = {
          "has_known_issues": len(all_issues) > 0,
          "issues": all_issues[:5],
      }
    output: sync_known_issues
    on_error: continue

  # ==================== RESOLVE REPOSITORY ====================

  - name: resolve_repo
    description: "Determine which repo to use"
    compute: |
      import os
      from scripts.common.config_loader import load_config

      repo_path = None
      default_branch = "main"

      # Load config using shared loader
      config = load_config()
      repos = config.get("repositories", {})

      if inputs.repo and inputs.repo != "" and inputs.repo != ".":
          repo_path = inputs.repo
          for name, cfg in repos.items():
              if cfg.get("path") == repo_path:
                  default_branch = cfg.get("default_branch", "main")
                  break
      elif inputs.repo_name and inputs.repo_name in repos:
          cfg = repos[inputs.repo_name]
          repo_path = cfg.get("path")
          default_branch = cfg.get("default_branch", "main")
      elif inputs.issue_key:
          project_prefix = inputs.issue_key.split("-")[0].upper()
          for name, cfg in repos.items():
              if cfg.get("jira_project") == project_prefix:
                  repo_path = cfg.get("path")
                  default_branch = cfg.get("default_branch", "main")
                  break
      else:
          cwd = os.getcwd()
          if os.path.exists(os.path.join(cwd, ".git")):
              repo_path = cwd
              for name, cfg in repos.items():
                  if cfg.get("path") == cwd:
                      default_branch = cfg.get("default_branch", "main")
                      break

      if not repo_path:
          raise ValueError("Repository not specified.")

      if inputs.base_branch:
          default_branch = inputs.base_branch

      result = {"path": repo_path, "default_branch": default_branch}
    output: resolved_repo

  # ==================== PRE-FLIGHT (using MCP tools) ====================

  - name: check_git_status
    description: "Get current branch and check for uncommitted changes"
    tool: git_status
    args:
      repo: "{{ resolved_repo.path }}"
    output: git_status_raw
    on_error: continue

  - name: parse_git_status
    description: "Parse git status output using shared parser"
    compute: |
      from scripts.common.parsers import extract_current_branch

      status_output = str(git_status_raw) if git_status_raw else ""

      # Extract current branch using shared parser
      branch = extract_current_branch(status_output)

      if not branch:
          raise ValueError("Could not determine current branch")

      if branch in ["main", "master"]:
          raise ValueError(f"Already on {branch}. Switch to a feature branch first.")

      # Check for uncommitted changes
      has_changes = "Changes not staged" in status_output or "Changes to be committed" in status_output

      result = {"branch": branch, "has_changes": has_changes}
    output: branch_status

  # ==================== STASH IF NEEDED (using MCP tool) ====================

  - name: stash_changes
    description: "Stash uncommitted changes"
    condition: "branch_status.has_changes and inputs.stash_changes"
    tool: git_stash
    args:
      repo: "{{ resolved_repo.path }}"
      action: "push"
      message: "sync_branch: auto-stash before rebase"
    output: stash_result
    on_error: continue

  # ==================== FETCH (using MCP tool) ====================

  - name: fetch_base
    description: "Fetch latest from remote"
    tool: git_fetch
    args:
      repo: "{{ resolved_repo.path }}"
      prune: true
    output: fetch_result
    on_error: auto_heal  # Git remote - may need auth/network

  # ==================== CHECK COMMITS ====================

  - name: get_commits_behind
    description: "Check how many commits behind"
    tool: git_log
    args:
      repo: "{{ resolved_repo.path }}"
      range_spec: "HEAD..origin/{{ resolved_repo.default_branch }}"
      count_only: true
    output: behind_count_raw

  - name: get_commits_ahead
    description: "Check how many commits ahead"
    tool: git_log
    args:
      repo: "{{ resolved_repo.path }}"
      range_spec: "origin/{{ resolved_repo.default_branch }}..HEAD"
      count_only: true
    output: ahead_count_raw

  - name: parse_commit_status
    description: "Parse commit counts"
    compute: |
      # Parse the count from tool outputs
      def parse_count(raw):
        if raw is None:
          return 0
        text = str(raw).strip()
        # Extract just the number
        for word in text.split():
          if word.isdigit():
            return int(word)
        return 0

      behind = parse_count(behind_count_raw)
      ahead = parse_count(ahead_count_raw)

      result = {"behind": behind, "ahead": ahead}
    output: commit_status

  # ==================== REBASE ====================

  - name: rebase
    description: "Rebase onto base branch"
    condition: "commit_status.behind > 0"
    tool: git_rebase
    args:
      repo: "{{ resolved_repo.path }}"
      onto: "origin/{{ resolved_repo.default_branch }}"
    output: rebase_raw
    on_error: continue

  - name: check_conflicts
    description: "Check for conflicts after rebase"
    condition: "commit_status.behind > 0 and rebase_raw and 'conflict' in str(rebase_raw).lower()"
    tool: git_status
    args:
      repo: "{{ resolved_repo.path }}"
    output: conflict_status_raw
    on_error: continue

  - name: parse_rebase_result
    description: "Parse rebase result"
    condition: "commit_status.behind > 0"
    compute: |
      rebase_text = str(rebase_raw) if 'rebase_raw' in dir() and rebase_raw else ""
      conflict_text = str(conflict_status_raw) if 'conflict_status_raw' in dir() and conflict_status_raw else ""

      if 'success' in rebase_text.lower() or ('conflict' not in rebase_text.lower() and 'error' not in rebase_text.lower() and 'failed' not in rebase_text.lower()):
        rebase_result = {
          "success": True,
          "conflicts": False,
          "message": f"Rebased onto origin/{resolved_repo['default_branch']}",
        }
      else:
        # Parse conflict files from status
        conflict_files = []
        for ln in conflict_text.split("\n"):
          if "both modified" in ln.lower() or "UU" in ln[:3] if len(ln) >= 3 else False:
            parts = ln.split()
            if parts:
              conflict_files.append(parts[-1])

        if conflict_files:
          rebase_result = {
            "success": False,
            "conflicts": True,
            "conflict_files": conflict_files[:5],
            "message": f"{len(conflict_files)} file(s) have conflicts",
          }
        else:
          rebase_result = {
            "success": False,
            "conflicts": False,
            "message": rebase_text[:200] if rebase_text else "Unknown error",
          }

      result = rebase_result
    output: rebase_result

  - name: skip_rebase_up_to_date
    description: "Branch is already up to date"
    condition: "commit_status.behind == 0"
    compute: |
      result = {
          "success": True,
          "conflicts": False,
          "message": "Already up to date with main",
      }
    output: rebase_result

  # ==================== POP STASH (using MCP tool) ====================

  - name: pop_stash
    description: "Restore stashed changes"
    condition: "stash_result and rebase_result.success"
    tool: git_stash
    args:
      repo: "{{ resolved_repo.path }}"
      action: "pop"
    output: pop_result
    on_error: continue

  # ==================== LINTING BEFORE PUSH ====================

  - name: run_black_check
    description: "Check code formatting before push"
    condition: "rebase_result.success and inputs.force_push and inputs.run_linting"
    tool: code_format
    args:
      repo: "{{ resolved_repo.path }}"
      tool: "black"
      check_only: true
    output: black_raw
    on_error: continue

  - name: run_flake8_check
    description: "Run flake8 linting before push"
    condition: "rebase_result.success and inputs.force_push and inputs.run_linting"
    tool: code_lint
    args:
      repo: "{{ resolved_repo.path }}"
      tool: "flake8"
      max_line_length: 100
      ignore: "E501,W503,E203"
    output: flake8_raw
    on_error: continue

  - name: parse_lint_results
    description: "Parse lint results and warn if issues"
    condition: "rebase_result.success and inputs.force_push and inputs.run_linting"
    compute: |
      black_output = str(black_raw) if black_raw else ""
      flake8_output = str(flake8_raw) if flake8_raw else ""

      black_ok = "‚úÖ" in black_output or "check passed" in black_output.lower()
      flake8_ok = "‚úÖ" in flake8_output or "passed" in flake8_output.lower() or not flake8_output.strip()

      issues = []
      if not black_ok:
        issues.append("Black: Code needs formatting (run 'black .')")
      if not flake8_ok:
        # Count issues
        issue_lines = [l for l in flake8_output.split('\n') if ':' in l and ('E' in l or 'F' in l or 'W' in l)]
        if issue_lines:
          issues.append(f"Flake8: {len(issue_lines)} issue(s) found")

      result = {
        "passed": len(issues) == 0,
        "issues": issues,
        "message": "Lint passed" if not issues else "; ".join(issues),
      }
    output: lint_result

  - name: block_on_lint_before_push
    description: "Block push if lint fails"
    condition: "rebase_result.success and inputs.force_push and inputs.run_linting and lint_result and not lint_result.get('passed', True)"
    compute: |
      issues = lint_result.get("issues", [])
      raise ValueError(
        f"‚ùå Lint errors found. Fix before pushing:\n" +
        "\n".join(f"  - {i}" for i in issues) +
        "\n\nRun 'black . && flake8' to check locally."
      )
    output: lint_block

  # ==================== FORCE PUSH (using MCP tool) ====================

  - name: do_force_push
    description: "Force push rebased branch"
    condition: "rebase_result.success and inputs.force_push and commit_status.behind > 0"
    tool: git_push
    args:
      repo: "{{ resolved_repo.path }}"
      branch: "{{ branch_status.branch }}"
      force: true
    output: push_result
    on_error: auto_heal  # Git remote - may need auth/network

  # ==================== SEMANTIC SEARCH ====================

  - name: search_branch_code
    description: "Search for code related to this branch"
    condition: "branch_status and branch_status.branch"
    tool: code_search
    args:
      query: "Git branch {{ branch_status.branch }} rebase sync {{ resolved_repo.default_branch or 'main' }}"
      project: "automation-analytics-backend"
      limit: 3
    output: branch_code_raw
    on_error: continue

  - name: parse_branch_code
    description: "Parse branch code search results"
    condition: "branch_code_raw"
    compute: |
      code_result = branch_code_raw if branch_code_raw else {}

      related_code = []
      if isinstance(code_result, dict) and code_result.get('found'):
          for item in code_result.get('content', []):
              related_code.append(item.get('path', '') + ":" + str(item.get('line_number', '')))

      result = {
          "has_code": len(related_code) > 0,
          "code_snippets": related_code[:5],
      }
    output: branch_code_search
    on_error: continue

  # ==================== MEMORY INTEGRATION ====================

  - name: log_sync
    description: "Log branch sync to session"
    tool: memory_session_log
    args:
      action: "Synced branch {{ branch_status.branch }}"
      details: "{{ commit_status.behind }} commits behind, rebased: {{ rebase_result.success if rebase_result else 'skipped' }}"
    on_error: continue

  - name: learn_sync_pattern
    description: "Learn from branch sync for future reference"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "branch_syncs" not in patterns:
          patterns["branch_syncs"] = []

      # Record this sync
      sync_record = {
          "branch": branch_status.get("branch", "unknown") if branch_status else "unknown",
          "repo": resolved_repo.get("path", "unknown") if resolved_repo else "unknown",
          "base_branch": resolved_repo.get("default_branch", "main") if resolved_repo else "main",
          "commits_behind": commit_status.get("behind", 0) if commit_status else 0,
          "commits_ahead": commit_status.get("ahead", 0) if commit_status else 0,
          "success": rebase_result.get("success", False) if rebase_result else False,
          "had_conflicts": rebase_result.get("conflicts", False) if rebase_result else False,
          "pushed": bool(push_result) if 'push_result' in dir() and push_result else False,
          "timestamp": datetime.now().isoformat(),
      }

      patterns["branch_syncs"].append(sync_record)

      # Keep last 100 sync records
      patterns["branch_syncs"] = patterns["branch_syncs"][-100:]

      memory.write_memory("learned/patterns", patterns)
      result = "sync pattern learned"
    output: pattern_learn_result
    on_error: continue

  - name: track_branches_behind
    description: "Track branches that frequently fall behind"
    condition: "commit_status and commit_status.behind > 5"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "branches_falling_behind" not in patterns:
          patterns["branches_falling_behind"] = []

      branch_name = branch_status.get("branch", "") if branch_status else ""

      # Track this branch
      existing = [b for b in patterns["branches_falling_behind"] if b.get("branch") == branch_name]

      if existing:
          existing[0]["count"] = existing[0].get("count", 1) + 1
          existing[0]["last_behind"] = commit_status.get("behind", 0)
          existing[0]["last_synced"] = datetime.now().isoformat()
      else:
          patterns["branches_falling_behind"].append({
              "branch": branch_name,
              "repo": resolved_repo.get("path", "") if resolved_repo else "",
              "count": 1,
              "max_behind": commit_status.get("behind", 0),
              "last_behind": commit_status.get("behind", 0),
              "first_synced": datetime.now().isoformat(),
              "last_synced": datetime.now().isoformat(),
          })

      # Update max
      for b in patterns["branches_falling_behind"]:
          if b.get("branch") == branch_name:
              b["max_behind"] = max(b.get("max_behind", 0), commit_status.get("behind", 0))

      # Keep top 30 by count
      patterns["branches_falling_behind"] = sorted(
          patterns["branches_falling_behind"],
          key=lambda x: x.get("count", 0),
          reverse=True
      )[:30]

      memory.write_memory("learned/patterns", patterns)
      result = "branch behind pattern tracked"
    output: behind_tracking_result
    on_error: continue

  - name: save_shared_context
    description: "Save sync context for other skills"
    compute: |
      from datetime import datetime

      # Share context that other skills can use
      shared = memory.read_memory("state/shared_context") or {}

      shared["last_branch_sync"] = {
          "timestamp": datetime.now().isoformat(),
          "branch": branch_status.get("branch", "") if branch_status else "",
          "base": resolved_repo.get("default_branch", "main") if resolved_repo else "main",
          "behind": commit_status.get("behind", 0) if commit_status else 0,
          "ahead": commit_status.get("ahead", 0) if commit_status else 0,
          "success": rebase_result.get("success", False) if rebase_result else False,
          "pushed": bool(push_result) if 'push_result' in dir() and push_result else False,
      }

      memory.write_memory("state/shared_context", shared)
      result = "shared context saved"
    output: shared_context_result
    on_error: continue

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_sync_failures
    description: "Detect failure patterns from sync operations"
    compute: |
      errors_detected = []

      # Check git failures
      rebase_text = str(rebase_raw) if 'rebase_raw' in dir() and rebase_raw else ""
      fetch_text = str(fetch_result) if 'fetch_result' in dir() and fetch_result else ""
      push_text = str(push_result) if 'push_result' in dir() and push_result else ""
      combined = rebase_text + fetch_text + push_text

      if "conflict" in combined.lower():
          errors_detected.append({
              "tool": "git_rebase",
              "pattern": "conflict",
              "cause": "Rebase resulted in merge conflicts",
              "fix": "Resolve conflicts manually, then git add and git rebase --continue"
          })
      if "permission denied" in combined.lower():
          errors_detected.append({
              "tool": "git_fetch",
              "pattern": "permission denied",
              "cause": "SSH key not loaded or git credentials expired",
              "fix": "Run ssh-add or check git credentials"
          })
      if "rejected" in combined.lower() and "push" in combined.lower():
          errors_detected.append({
              "tool": "git_push",
              "pattern": "push rejected",
              "cause": "Remote has changes not in local branch",
              "fix": "Use --force-with-lease to push rebased branch"
          })

      result = errors_detected
    output: sync_errors_detected
    on_error: continue

  - name: learn_sync_conflict_failure
    description: "Learn from rebase conflict failures"
    condition: "sync_errors_detected and any(e.get('pattern') == 'conflict' for e in sync_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "git_rebase"
      error_pattern: "conflict"
      root_cause: "Rebase resulted in merge conflicts"
      fix_description: "Resolve conflicts manually, then git add and git rebase --continue"
    output: sync_conflict_fix_learned
    on_error: continue

  - name: learn_sync_push_failure
    description: "Learn from push rejected failures"
    condition: "sync_errors_detected and any(e.get('pattern') == 'push rejected' for e in sync_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "git_push"
      error_pattern: "push rejected"
      root_cause: "Remote has changes not in local branch"
      fix_description: "Use --force-with-lease to push rebased branch"
    output: sync_push_fix_learned
    on_error: continue

outputs:
  - name: summary
    value: |
      ## üîÑ Sync Branch: `{{ branch_status.branch }}`

      **Repo:** {{ resolved_repo.path }}
      **Base:** `{{ resolved_repo.default_branch }}`
      **Status:** {{ commit_status.behind }} behind, {{ commit_status.ahead }} ahead

      {% if commit_status.behind == 0 %}
      ‚úÖ Already up to date with `{{ resolved_repo.default_branch }}`
      {% elif rebase_result.success %}
      ‚úÖ Successfully rebased onto `{{ resolved_repo.default_branch }}`
      {% if stash_result %}
      - Stashed changes
      - {{ pop_result if pop_result else "Changes restored" }}
      {% endif %}
      {% if push_result %}
      - Pushed to origin
      {% else %}

      Ready to push:
      ```bash
      git push --force-with-lease origin {{ branch_status.branch }}
      ```
      {% endif %}
      {% else %}

      {% if rebase_result.conflicts %}
      ‚ö†Ô∏è **Merge Conflicts Detected**

      Files with conflicts:
      {% for f in rebase_result.conflict_files %}
      - `{{ f }}`
      {% endfor %}

      **To resolve:**
      1. Edit each file (look for `<<<<<<<` markers)
      2. `git add <file>`
      3. `git rebase --continue`
      4. `git push --force-with-lease`

      **To abort:** `git rebase --abort`

      {% if sync_known_issues and sync_known_issues.has_known_issues %}
      ---

      ### üí° Known Issues

      {% for issue in sync_known_issues.issues[:3] %}
      - {{ issue.pattern if issue.pattern else issue }}
      {% endfor %}
      {% endif %}
      {% else %}
      ‚ùå Rebase failed: {{ rebase_result.message }}
      {% endif %}
      {% endif %}

  - name: context
    value:
      branch: "{{ branch_status.branch }}"
      repo: "{{ resolved_repo.path }}"
      base_branch: "{{ resolved_repo.default_branch }}"
      success: "{{ rebase_result.success }}"
      behind: "{{ commit_status.behind }}"
      ahead: "{{ commit_status.ahead }}"
      pushed: "{{ push_result is defined }}"
