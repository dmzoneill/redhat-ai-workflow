# Skill: Cleanup Branches
# Delete merged and stale feature branches

name: cleanup_branches
description: |
  Clean up old feature branches that have been merged or are stale.

  The skill will:
  1. Fetch latest from remote
  2. List all local and remote branches
  3. Identify merged branches
  4. Delete merged branches (with confirmation)
  5. Optionally clean up tracking refs

version: "1.0"

inputs:
  - name: repo
    type: string
    required: false
    default: ""
    description: "Repository path (defaults to cwd)"

  - name: dry_run
    type: boolean
    required: false
    default: true
    description: "Just show what would be deleted (default: true for safety)"

  - name: include_remote
    type: boolean
    required: false
    default: false
    description: "Also delete remote branches (requires push access)"

  - name: older_than_days
    type: integer
    required: false
    default: 30
    description: "Consider branches stale if no commits in this many days"

  - name: protected_branches
    type: string
    required: false
    default: "main,master,develop,release"
    description: "Comma-separated list of branches to never delete"

steps:

  - name: init_autoheal
    description: "Initialize failure tracking"
    compute: |
      result = {"git_failures": []}
    output: autoheal_state
    on_error: continue

  # ==================== KNOWLEDGE INTEGRATION ====================

  - name: get_branch_naming_patterns
    description: "Get branch naming conventions from knowledge"
    tool: knowledge_query
    args:
      project: "automation-analytics-backend"
      persona: "developer"
      section: "patterns.coding"
    output: branch_patterns_raw
    on_error: continue

  - name: parse_branch_patterns
    description: "Parse branch naming patterns"
    compute: |
      patterns_result = branch_patterns_raw if 'branch_patterns_raw' in dir() and branch_patterns_raw else {}

      branch_patterns = []
      if isinstance(patterns_result, dict) and patterns_result.get('found'):
          content = patterns_result.get('content', [])
          if isinstance(content, list):
              # Filter for branch-related patterns
              for p in content:
                  p_str = str(p).lower()
                  if any(kw in p_str for kw in ['branch', 'naming', 'aap-', 'feature/', 'fix/']):
                      branch_patterns.append(p)

      result = {
          'patterns': branch_patterns[:5],
          'has_patterns': len(branch_patterns) > 0,
      }
    output: branch_naming_patterns
    on_error: continue

  - name: check_git_known_issues
    description: "Check for known git branch issues"
    compute: |
      # Check known issues for git operations
      git_issues = memory.check_known_issues("git", "") or {}
      branch_issues = memory.check_known_issues("branch", "") or {}

      all_issues = []
      for issues in [git_issues, branch_issues]:
          if issues and issues.get("matches"):
              all_issues.extend(issues.get("matches", [])[:2])

      result = {
          "has_known_issues": len(all_issues) > 0,
          "issues": all_issues[:5],
      }
    output: cleanup_known_issues
    on_error: continue

  # ==================== RESOLVE REPOSITORY ====================

  - name: resolve_repo
    description: "Determine repository path"
    compute: |
      import os

      if inputs.repo and inputs.repo != "":
          repo_path = inputs.repo
      else:
          repo_path = os.getcwd()

      if not os.path.exists(os.path.join(repo_path, ".git")):
          raise ValueError(f"Not a git repository: {repo_path}")

      # Parse protected branches
      protected = [b.strip().lower() for b in inputs.protected_branches.split(",")]

      result = {"path": repo_path, "protected": protected}
    output: resolved_repo

  # ==================== FETCH AND LIST ====================

  - name: fetch_all
    description: "Fetch latest from all remotes"
    tool: git_fetch
    args:
      repo: "{{ resolved_repo.path }}"
      all: true
      prune: true
    output: fetch_result
    on_error: auto_heal  # Git remote - may need auth/network

  - name: list_local_branches
    description: "List all local branches"
    tool: git_branch_list
    args:
      repo: "{{ resolved_repo.path }}"
      all: false
    output: local_branches_raw

  - name: list_remote_branches
    description: "List all remote branches"
    tool: git_remote
    args:
      repo: "{{ resolved_repo.path }}"
      action: "show"
      remote: "origin"
    output: remote_info_raw
    on_error: continue

  - name: list_all_branches
    description: "List all branches including remote"
    tool: git_branch_list
    args:
      repo: "{{ resolved_repo.path }}"
      all: true
    output: all_branches_raw
    on_error: continue

  # ==================== SEMANTIC SEARCH ====================

  - name: search_related_issues
    description: "Search for Jira issues related to candidate branches"
    condition: "branch_candidates and branch_candidates.candidate_count > 0"
    tool: code_search
    args:
      query: "branch cleanup {{ branch_candidates.candidates[0].name if branch_candidates.candidates else '' }}"
      project: "automation-analytics-backend"
      limit: 3
    output: branch_code_raw
    on_error: continue

  - name: parse_branch_code
    description: "Parse branch code search results"
    condition: "branch_code_raw"
    compute: |
      code_result = branch_code_raw if branch_code_raw else {}

      related_code = []
      if isinstance(code_result, dict) and code_result.get('results'):
          for r in code_result.get('results', [])[:3]:
              related_code.append({
                  'file': r.get('file_path', ''),
                  'score': r.get('score', 0),
              })

      result = {
          'code': related_code,
          'count': len(related_code),
      }
    output: branch_code_analysis
    on_error: continue

  # ==================== IDENTIFY MERGED BRANCHES ====================

  - name: identify_candidates
    description: "Identify branches to delete"
    compute: |
      local_text = str(local_branches_raw) if local_branches_raw else ""
      all_text = str(all_branches_raw) if 'all_branches_raw' in dir() and all_branches_raw else ""

      protected = resolved_repo.get("protected", ["main", "master", "develop"])

      # Parse local branches
      local_branches = []
      current_branch = None
      for line in local_text.split("\n"):
          line = line.strip()
          if line.startswith("*"):
              current_branch = line.replace("*", "").strip()
              local_branches.append(current_branch)
          elif line:
              local_branches.append(line)

      # Filter out protected branches
      candidates = []
      for branch in local_branches:
          branch_lower = branch.lower()
          is_protected = any(p in branch_lower for p in protected)

          if not is_protected and branch != current_branch:
              candidates.append({
                  "name": branch,
                  "type": "local",
              })

      # Count remote branches
      remote_branches = []
      for line in all_text.split("\n"):
          if "remotes/origin/" in line and "HEAD" not in line:
              branch_name = line.strip().replace("remotes/origin/", "")
              if not any(p in branch_name.lower() for p in protected):
                  remote_branches.append(branch_name)

      result = {
          "candidates": candidates[:50],
          "candidate_count": len(candidates),
          "remote_branches": remote_branches[:50],
          "remote_count": len(remote_branches),
          "current_branch": current_branch,
          "protected": protected,
      }
    output: branch_candidates

  # ==================== DELETE BRANCHES ====================

  - name: delete_first_branch
    description: "Delete first candidate branch"
    condition: "not inputs.dry_run and branch_candidates.candidate_count > 0"
    tool: git_branch_delete
    args:
      repo: "{{ resolved_repo.path }}"
      branch: "{{ branch_candidates.candidates[0].name }}"
      force: false
    output: delete_1_result
    on_error: continue

  - name: delete_second_branch
    description: "Delete second candidate branch"
    condition: "not inputs.dry_run and branch_candidates.candidate_count > 1"
    tool: git_branch_delete
    args:
      repo: "{{ resolved_repo.path }}"
      branch: "{{ branch_candidates.candidates[1].name }}"
      force: false
    output: delete_2_result
    on_error: continue

  - name: delete_third_branch
    description: "Delete third candidate branch"
    condition: "not inputs.dry_run and branch_candidates.candidate_count > 2"
    tool: git_branch_delete
    args:
      repo: "{{ resolved_repo.path }}"
      branch: "{{ branch_candidates.candidates[2].name }}"
      force: false
    output: delete_3_result
    on_error: continue

  - name: count_deleted
    description: "Count deleted branches"
    compute: |
      deleted = 0
      errors = []

      for i, result in enumerate([
          delete_1_result if 'delete_1_result' in dir() else None,
          delete_2_result if 'delete_2_result' in dir() else None,
          delete_3_result if 'delete_3_result' in dir() else None,
      ]):
          if result:
              result_text = str(result)
              if "error" not in result_text.lower() and "not found" not in result_text.lower():
                  deleted += 1
              else:
                  errors.append(result_text[:100])

      result = {
          "deleted_count": deleted,
          "errors": errors,
      }
    output: deletion_results
    on_error: continue

  # ==================== MEMORY ====================

  - name: log_cleanup
    description: "Log cleanup action"
    condition: "deletion_results and deletion_results.deleted_count > 0"
    tool: memory_session_log
    args:
      action: "Cleaned up branches"
      details: "Deleted {{ deletion_results.deleted_count }} branches in {{ resolved_repo.path }}"
    on_error: continue

  - name: learn_cleanup_pattern
    description: "Learn from branch cleanup for future reference"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "branch_cleanups" not in patterns:
          patterns["branch_cleanups"] = []

      # Record this cleanup
      cleanup_record = {
          "repo": resolved_repo.get("path", "unknown") if resolved_repo else "unknown",
          "candidate_count": branch_candidates.get("candidate_count", 0) if branch_candidates else 0,
          "deleted_count": deletion_results.get("deleted_count", 0) if deletion_results else 0,
          "dry_run": inputs.dry_run,
          "timestamp": datetime.now().isoformat(),
      }

      patterns["branch_cleanups"].append(cleanup_record)

      # Keep last 50 cleanup records
      patterns["branch_cleanups"] = patterns["branch_cleanups"][-50:]

      memory.write_memory("learned/patterns", patterns)
      result = "cleanup pattern learned"
    output: pattern_learn_result
    on_error: continue

  - name: track_stale_branches
    description: "Track frequently stale branches by pattern"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "stale_branch_patterns" not in patterns:
          patterns["stale_branch_patterns"] = {}

      # Analyze branch naming patterns
      for candidate in (branch_candidates.get("candidates", []) or [])[:20]:
          branch_name = candidate.get("name", "")

          # Extract prefix pattern (e.g., "aap-" or "feature/")
          import re
          prefix_match = re.match(r'^([a-zA-Z]+-|\w+/)', branch_name)
          if prefix_match:
              prefix = prefix_match.group(1)
              if prefix not in patterns["stale_branch_patterns"]:
                  patterns["stale_branch_patterns"][prefix] = {"count": 0, "examples": []}

              patterns["stale_branch_patterns"][prefix]["count"] += 1
              if len(patterns["stale_branch_patterns"][prefix]["examples"]) < 5:
                  patterns["stale_branch_patterns"][prefix]["examples"].append(branch_name)

      memory.write_memory("learned/patterns", patterns)
      result = "stale branch patterns tracked"
    output: stale_pattern_result
    on_error: continue

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_cleanup_failures
    description: "Detect failure patterns from branch cleanup"
    compute: |
      errors_detected = []

      # Check git failures
      fetch_text = str(fetch_result) if 'fetch_result' in dir() and fetch_result else ""
      branches_text = str(all_branches_raw) if 'all_branches_raw' in dir() and all_branches_raw else ""
      combined = fetch_text + branches_text

      if "permission denied" in combined.lower():
          errors_detected.append({
              "tool": "git_fetch",
              "pattern": "permission denied",
              "cause": "SSH key not loaded or git credentials expired",
              "fix": "Run ssh-add or check git credentials"
          })
      if "could not read" in combined.lower() and "remote" in combined.lower():
          errors_detected.append({
              "tool": "git_fetch",
              "pattern": "could not read remote",
              "cause": "Remote repository not accessible",
              "fix": "Check VPN connection and remote URL"
          })

      result = errors_detected
    output: cleanup_errors_detected
    on_error: continue

  - name: learn_cleanup_permission_failure
    description: "Learn from git permission failures"
    condition: "cleanup_errors_detected and any(e.get('pattern') == 'permission denied' for e in cleanup_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "git_fetch"
      error_pattern: "permission denied"
      root_cause: "SSH key not loaded or git credentials expired"
      fix_description: "Run ssh-add or check git credentials"
    output: cleanup_permission_fix_learned
    on_error: continue

outputs:
  - name: report
    value: |
      ## üßπ Branch Cleanup

      **Repository:** `{{ resolved_repo.path }}`
      **Current Branch:** `{{ branch_candidates.current_branch }}`
      **Mode:** {{ "üîç Dry Run" if inputs.dry_run else "üóëÔ∏è Delete" }}

      ---

      ### Local Branches to Clean

      {% if branch_candidates.candidate_count == 0 %}
      ‚úÖ No branches to clean up.
      {% else %}
      Found **{{ branch_candidates.candidate_count }}** candidate branches:

      {% for branch in branch_candidates.candidates[:15] %}
      - `{{ branch.name }}`
      {% endfor %}
      {% if branch_candidates.candidate_count > 15 %}
      ... and {{ branch_candidates.candidate_count - 15 }} more
      {% endif %}

      {% if inputs.dry_run %}
      ### ‚ö†Ô∏è Dry Run Mode

      No branches were deleted. To delete, run:
      ```python
      skill_run("cleanup_branches", '{"dry_run": false}')
      ```

      {% else %}
      ### Deletion Results

      **Deleted:** {{ deletion_results.deleted_count }} branches

      {% if deletion_results.errors %}
      **Errors:**
      {% for err in deletion_results.errors %}
      - {{ err }}
      {% endfor %}
      {% endif %}

      {% if branch_candidates.candidate_count > 3 %}
      ‚ö†Ô∏è Only first 3 branches deleted per run for safety.
      Run again to delete more.
      {% endif %}
      {% endif %}
      {% endif %}

      ---

      ### Protected Branches (never deleted)
      {% for p in resolved_repo.protected %}
      - `{{ p }}`
      {% endfor %}

      ### Commands

      **List all branches:**
      ```python
      git_branch_list(repo='{{ resolved_repo.path }}', all=True)
      ```

      **Delete specific branch:**
      ```python
      git_branch_delete(repo='{{ resolved_repo.path }}', branch='BRANCH_NAME')
      ```

      {% if branch_naming_patterns and branch_naming_patterns.has_patterns %}
      ---

      ### üìã Branch Naming Conventions

      {% for pattern in branch_naming_patterns.patterns[:3] %}
      - {{ pattern }}
      {% endfor %}
      {% endif %}

      {% if cleanup_known_issues and cleanup_known_issues.has_known_issues %}
      ---

      ### üí° Known Issues

      {% for issue in cleanup_known_issues.issues[:3] %}
      - {{ issue.pattern if issue.pattern else issue }}
      {% endfor %}
      {% endif %}

  - name: context
    value:
      repo: "{{ resolved_repo.path }}"
      candidate_count: "{{ branch_candidates.candidate_count }}"
      deleted_count: "{{ deletion_results.deleted_count if deletion_results else 0 }}"
      dry_run: "{{ inputs.dry_run }}"
