# Skill: Rollout Restart
# Restart a deployment and monitor rollout

name: rollout_restart
description: |
  Restart a Kubernetes deployment and monitor its rollout.

  This is useful for:
  - Picking up new ConfigMap/Secret changes
  - Recovering from stuck pods
  - Forcing a fresh start without redeploying

  Uses: kubectl_rollout_restart, kubectl_rollout_status, kubectl_describe_deployment,
        kubectl_get_pods
version: "1.0"

inputs:
  - name: deployment
    type: string
    required: true
    description: "Deployment name to restart"

  - name: namespace
    type: string
    required: true
    description: "Kubernetes namespace"

  - name: environment
    type: string
    required: false
    default: "stage"
    description: "Environment (stage, production, ephemeral)"

  - name: wait
    type: boolean
    required: false
    default: true
    description: "Wait for rollout to complete"

steps:
  # ==================== MEMORY CONTEXT ====================

  - name: check_known_issues
    description: "Check for known k8s rollout issues"
    compute: |
      # Check known issues for kubectl operations
      issues = memory.check_known_issues("kubectl_rollout_restart", "")

      result = {
          "has_known_issues": len(issues.get("matches", [])) > 0 if issues else False,
          "issues": issues.get("matches", [])[:3] if issues else [],
      }
    output: known_issues
    on_error: continue

  - name: get_rollout_gotchas
    description: "Get rollout-related gotchas from knowledge"
    tool: knowledge_query
    args:
      project: "automation-analytics-backend"
      persona: "devops"
      section: "gotchas"
    output: rollout_gotchas_raw
    on_error: continue

  - name: parse_rollout_gotchas
    description: "Parse rollout-related gotchas"
    compute: |
      gotchas_result = rollout_gotchas_raw if 'rollout_gotchas_raw' in dir() and rollout_gotchas_raw else {}

      rollout_gotchas = []
      if isinstance(gotchas_result, dict) and gotchas_result.get('found'):
          content = gotchas_result.get('content', [])
          if isinstance(content, list):
              # Filter for rollout-related gotchas
              for g in content:
                  g_str = str(g).lower()
                  if any(kw in g_str for kw in ['rollout', 'restart', 'pod', 'deploy', 'k8s', 'configmap', 'secret']):
                      rollout_gotchas.append(g)

      result = {
          'gotchas': rollout_gotchas[:5],
          'has_gotchas': len(rollout_gotchas) > 0,
      }
    output: restart_gotchas
    on_error: continue

  - name: load_restart_history
    description: "Load previous restart history for this deployment"
    compute: |
      # Load learned patterns
      patterns = memory.read_memory("learned/patterns") or {}
      restart_history = patterns.get("rollout_restarts", [])

      # Find history for this specific deployment
      deployment_history = [
          r for r in restart_history
          if r.get("deployment") == inputs.deployment and r.get("namespace") == inputs.namespace
      ]

      result = {
          "previous_restarts": len(deployment_history),
          "recent_failures": [r for r in deployment_history if not r.get("healthy")][-3:],
          "last_restart": deployment_history[-1] if deployment_history else None,
      }
    output: restart_history
    on_error: continue

  # ==================== PRE-RESTART CHECK ====================

  - name: describe_before
    description: "Get deployment state before restart"
    tool: kubectl_describe_deployment
    args:
      deployment: "{{ inputs.deployment }}"
      namespace: "{{ inputs.namespace }}"
      environment: "{{ inputs.environment }}"
    output: describe_before_raw
    on_error: continue

  - name: parse_before_state
    description: "Parse current deployment state"
    compute: |
      desc_text = str(describe_before_raw) if 'describe_before_raw' in dir() and describe_before_raw else ""

      import re

      # Extract replicas
      replicas_match = re.search(r'Replicas:\s*(\d+)', desc_text)
      replicas = int(replicas_match.group(1)) if replicas_match else 0

      # Extract image
      image_match = re.search(r'Image:\s*(\S+)', desc_text)
      image = image_match.group(1) if image_match else "unknown"

      # Check if deployment exists
      exists = "NotFound" not in desc_text and replicas > 0

      result = {
        "exists": exists,
        "replicas": replicas,
        "image": image[:80],
        "preview": desc_text[:400] if desc_text else "",
      }
    output: before_state

  # ==================== RESTART ====================

  - name: restart_deployment
    description: "Trigger rolling restart"
    condition: "before_state.exists"
    tool: kubectl_rollout_restart
    args:
      deployment: "{{ inputs.deployment }}"
      namespace: "{{ inputs.namespace }}"
      environment: "{{ inputs.environment }}"
    output: restart_result
    on_error: auto_heal  # K8s cluster - may need kube_login

  - name: parse_restart
    description: "Parse restart result"
    compute: |
      restart_text = str(restart_result) if 'restart_result' in dir() and restart_result else ""

      success = "restarted" in restart_text.lower() or "triggered" in restart_text.lower()
      if "error" in restart_text.lower() or "failed" in restart_text.lower():
        success = False

      result = {
        "success": success,
        "message": restart_text[:200] if restart_text else "",
      }
    output: restart_status

  # ==================== MONITOR ROLLOUT ====================

  - name: check_rollout
    description: "Monitor rollout progress"
    condition: "restart_status.success and inputs.wait"
    tool: kubectl_rollout_status
    args:
      deployment: "{{ inputs.deployment }}"
      namespace: "{{ inputs.namespace }}"
      environment: "{{ inputs.environment }}"
    output: rollout_raw
    on_error: continue

  - name: parse_rollout
    description: "Parse rollout status"
    compute: |
      rollout_text = str(rollout_raw) if 'rollout_raw' in dir() and rollout_raw else ""

      complete = "successfully rolled out" in rollout_text.lower()
      in_progress = "waiting" in rollout_text.lower() or "progressing" in rollout_text.lower()

      result = {
        "complete": complete,
        "in_progress": in_progress,
        "message": rollout_text[:300] if rollout_text else "",
      }
    output: rollout_status

  # ==================== POST-RESTART CHECK ====================

  - name: get_pods_after
    description: "Get pod status after restart"
    condition: "restart_status.success"
    tool: kubectl_get_pods
    args:
      namespace: "{{ inputs.namespace }}"
      environment: "{{ inputs.environment }}"
    output: pods_after_raw
    on_error: auto_heal  # K8s cluster - may need kube_login

  - name: parse_pods_after
    description: "Analyze pod health after restart"
    compute: |
      pods_text = str(pods_after_raw) if 'pods_after_raw' in dir() and pods_after_raw else ""

      running = 0
      pending = 0
      failed = 0
      deployment_pods = []

      for line in pods_text.split("\n"):
        # Filter to only this deployment's pods
        if inputs.deployment.lower() in line.lower():
          deployment_pods.append(line)
          if "Running" in line:
            running += 1
          elif "Pending" in line or "ContainerCreating" in line:
            pending += 1
          elif "Error" in line or "CrashLoopBackOff" in line:
            failed += 1

      healthy = running > 0 and failed == 0

      result = {
        "running": running,
        "pending": pending,
        "failed": failed,
        "healthy": healthy,
        "pods": deployment_pods[:5],
      }
    output: pods_health

  # ==================== MEMORY ====================

  - name: log_restart
    description: "Log restart to session"
    tool: memory_session_log
    args:
      action: "Restarted {{ inputs.deployment }} in {{ inputs.namespace }}"
      details: "Environment: {{ inputs.environment }}, Healthy: {{ pods_health.healthy if pods_health else 'unknown' }}"
    on_error: continue

  - name: learn_restart_pattern
    description: "Learn from this restart for future reference"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "rollout_restarts" not in patterns:
          patterns["rollout_restarts"] = []

      # Record this restart
      restart_record = {
          "deployment": inputs.deployment,
          "namespace": inputs.namespace,
          "environment": inputs.environment,
          "success": restart_status.success if restart_status else False,
          "healthy": pods_health.healthy if pods_health else False,
          "running_pods": pods_health.running if pods_health else 0,
          "failed_pods": pods_health.failed if pods_health else 0,
          "timestamp": datetime.now().isoformat(),
      }

      patterns["rollout_restarts"].append(restart_record)

      # Keep last 100 restart records
      patterns["rollout_restarts"] = patterns["rollout_restarts"][-100:]

      memory.write_memory("learned/patterns", patterns)
      result = "restart pattern learned"
    output: pattern_learn_result
    on_error: continue

  - name: track_unhealthy_deployments
    description: "Track deployments that frequently have issues"
    condition: "pods_health and not pods_health.healthy"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "unhealthy_deployments" not in patterns:
          patterns["unhealthy_deployments"] = []

      # Track this deployment's failure
      key = f"{inputs.namespace}/{inputs.deployment}"
      existing = [d for d in patterns["unhealthy_deployments"] if d.get("key") == key]

      if existing:
          existing[0]["count"] = existing[0].get("count", 1) + 1
          existing[0]["last_unhealthy"] = datetime.now().isoformat()
          existing[0]["last_error"] = pods_health.pods[0] if pods_health.pods else None
      else:
          patterns["unhealthy_deployments"].append({
              "key": key,
              "deployment": inputs.deployment,
              "namespace": inputs.namespace,
              "environment": inputs.environment,
              "count": 1,
              "first_unhealthy": datetime.now().isoformat(),
              "last_unhealthy": datetime.now().isoformat(),
              "last_error": pods_health.pods[0] if pods_health.pods else None,
          })

      # Keep top 50 problematic deployments
      patterns["unhealthy_deployments"] = sorted(
          patterns["unhealthy_deployments"],
          key=lambda x: x.get("count", 0),
          reverse=True
      )[:50]

      memory.write_memory("learned/patterns", patterns)
      result = "unhealthy deployment tracked"
    output: unhealthy_tracking_result
    on_error: continue

  - name: update_environment_state
    description: "Update environment state after restart"
    compute: |
      from datetime import datetime

      # Update environment state
      env_data = memory.read_memory("state/environments") or {}
      if "environments" not in env_data:
          env_data["environments"] = {}

      env_key = inputs.environment
      if env_key not in env_data["environments"]:
          env_data["environments"][env_key] = {"status": "unknown", "deployments": {}}

      env = env_data["environments"][env_key]
      env["deployments"][inputs.deployment] = {
          "last_restart": datetime.now().isoformat(),
          "healthy": pods_health.healthy if pods_health else False,
          "running": pods_health.running if pods_health else 0,
      }

      memory.write_memory("state/environments", env_data)
      result = "environment state updated"
    output: env_update_result
    on_error: continue

  # ==================== SEMANTIC SEARCH ====================

  - name: search_deployment_code
    description: "Search for code related to this deployment"
    tool: code_search
    args:
      query: "{{ inputs.deployment }} kubernetes deployment configuration"
      project: "automation-analytics-backend"
      limit: 3
    output: deployment_code_raw
    on_error: continue

  - name: parse_deployment_code
    description: "Parse deployment code search results"
    condition: "deployment_code_raw"
    compute: |
      code_result = deployment_code_raw if deployment_code_raw else {}

      related_code = []
      if isinstance(code_result, dict) and code_result.get('results'):
          for r in code_result.get('results', [])[:3]:
              related_code.append({
                  'file': r.get('file_path', ''),
                  'score': r.get('score', 0),
              })

      result = {
          'code': related_code,
          'count': len(related_code),
      }
    output: deployment_code_analysis
    on_error: continue

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_rollout_failures
    description: "Detect failure patterns from rollout restart"
    compute: |
      errors_detected = []

      # Check kubectl failures
      describe_text = str(describe_before_raw) if 'describe_before_raw' in dir() and describe_before_raw else ""
      restart_text = str(restart_result) if 'restart_result' in dir() and restart_result else ""
      combined = describe_text + restart_text

      if "unauthorized" in combined.lower() or "forbidden" in combined.lower():
          errors_detected.append({
              "tool": "kubectl_rollout",
              "pattern": "unauthorized",
              "cause": "Kubernetes auth expired",
              "fix": "Run kube_login(cluster='stage' or 'prod') to refresh credentials"
          })
      if "not found" in combined.lower() and "deployment" in combined.lower():
          errors_detected.append({
              "tool": "kubectl_rollout",
              "pattern": "deployment not found",
              "cause": "Deployment name is incorrect or doesn't exist",
              "fix": "List deployments with kubectl_get_deployments()"
          })

      result = errors_detected
    output: rollout_errors_detected
    on_error: continue

  - name: learn_rollout_auth_failure
    description: "Learn from k8s auth failures"
    condition: "rollout_errors_detected and any(e.get('pattern') == 'unauthorized' for e in rollout_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "kubectl_rollout"
      error_pattern: "unauthorized"
      root_cause: "Kubernetes auth expired"
      fix_description: "Run kube_login(cluster='stage' or 'prod') to refresh credentials"
    output: rollout_auth_fix_learned
    on_error: continue

outputs:
  - name: report
    value: |
      ## üîÑ Rollout Restart: {{ inputs.deployment }}

      **Namespace:** `{{ inputs.namespace }}`
      **Environment:** {{ inputs.environment }}

      ---

      {% if not before_state.exists %}
      ### ‚ùå Deployment Not Found

      Could not find deployment `{{ inputs.deployment }}` in namespace `{{ inputs.namespace }}`.

      {{ before_state.preview }}

      {% elif not restart_status.success %}
      ### ‚ùå Restart Failed

      {{ restart_status.message }}

      {% else %}
      ### ‚úÖ Restart Initiated

      {{ restart_status.message }}

      **Before:**
      - Replicas: {{ before_state.replicas }}
      - Image: `{{ before_state.image }}`

      ---

      ### Rollout Status

      {% if rollout_status and rollout_status.complete %}
      ‚úÖ **Rollout complete**
      {% elif rollout_status and rollout_status.in_progress %}
      üîÑ **Rollout in progress...**

      {{ rollout_status.message }}
      {% else %}
      ‚è≥ Rollout status not checked (wait=false)
      {% endif %}

      ---

      ### Pod Health

      - üü¢ Running: {{ pods_health.running }}
      - üü° Pending: {{ pods_health.pending }}
      - üî¥ Failed: {{ pods_health.failed }}

      {% for pod in pods_health.pods %}
      - `{{ pod }}`
      {% endfor %}

      {% if not pods_health.healthy %}
      ‚ö†Ô∏è **Some pods are not healthy. Check logs:**
      ```
      kubectl_logs(pod_name='<pod>', namespace='{{ inputs.namespace }}', environment='{{ inputs.environment }}')
      ```
      {% endif %}

      {% if restart_gotchas and restart_gotchas.has_gotchas %}
      ---

      ### ‚ö†Ô∏è Rollout Gotchas

      {% for gotcha in restart_gotchas.gotchas[:3] %}
      - {{ gotcha }}
      {% endfor %}
      {% endif %}

      {% if known_issues and known_issues.has_known_issues %}
      ---

      ### üí° Known Issues

      {% for issue in known_issues.issues[:3] %}
      - {{ issue.pattern if issue.pattern else issue }}
      {% endfor %}
      {% endif %}
      {% endif %}

  - name: context
    value:
      deployment: "{{ inputs.deployment }}"
      namespace: "{{ inputs.namespace }}"
      restarted: "{{ restart_status.success if restart_status else false }}"
      healthy: "{{ pods_health.healthy if pods_health else false }}"
