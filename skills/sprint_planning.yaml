# Skill: Sprint Planning
# Prepare sprint backlog

name: sprint_planning
description: |
  Help with sprint planning by analyzing the backlog.

  This skill:
  - Lists unassigned issues in the backlog
  - Identifies blocked items
  - Shows issues ready for sprint
  - Can add issues to a sprint

  Uses: jira_list_issues, jira_list_blocked, jira_add_to_sprint, jira_add_flag
version: "1.0"

inputs:
  - name: project
    type: string
    required: false
    default: "AAP"
    description: "Jira project key"

  - name: sprint
    type: string
    required: false
    default: ""
    description: "Sprint name to add issues to (optional)"

  - name: limit
    type: integer
    required: false
    default: 20
    description: "Max issues to show"

steps:
  # ==================== PROACTIVE ISSUE DETECTION ====================

  - name: check_jira_known_issues
    description: "Check for known Jira issues before starting"
    tool: check_known_issues
    args:
      tool_name: "jira_list_issues"
      error_text: ""
    output: jira_known_issues
    on_error: continue

  # ==================== KNOWLEDGE INTEGRATION ====================

  - name: get_sprint_patterns
    description: "Get sprint planning patterns from knowledge"
    tool: knowledge_query
    args:
      project: "automation-analytics-backend"
      persona: "developer"
      section: "patterns"
    output: sprint_patterns_raw
    on_error: continue

  - name: parse_sprint_patterns
    description: "Parse sprint planning patterns"
    compute: |
      patterns_result = sprint_patterns_raw if 'sprint_patterns_raw' in dir() and sprint_patterns_raw else {}

      sprint_patterns = []
      if isinstance(patterns_result, dict) and patterns_result.get('found'):
          content = patterns_result.get('content', {})
          if isinstance(content, dict):
              # Get coding patterns that might affect estimation
              coding = content.get('coding', [])
              if isinstance(coding, list):
                  sprint_patterns.extend(coding[:3])

      result = {
          'patterns': sprint_patterns[:5],
          'has_patterns': len(sprint_patterns) > 0,
      }
    output: sprint_planning_patterns
    on_error: continue

  - name: get_project_gotchas
    description: "Get project gotchas that might affect sprint planning"
    tool: knowledge_query
    args:
      project: "automation-analytics-backend"
      persona: "developer"
      section: "gotchas"
    output: planning_gotchas_raw
    on_error: continue

  - name: parse_planning_gotchas
    description: "Parse planning-relevant gotchas"
    compute: |
      gotchas_result = planning_gotchas_raw if 'planning_gotchas_raw' in dir() and planning_gotchas_raw else {}

      planning_gotchas = []
      if isinstance(gotchas_result, dict) and gotchas_result.get('found'):
          content = gotchas_result.get('content', [])
          if isinstance(content, list):
              planning_gotchas = content[:5]

      result = {
          'gotchas': planning_gotchas,
          'has_gotchas': len(planning_gotchas) > 0,
      }
    output: planning_gotchas
    on_error: continue

  # ==================== JIRA QUERIES ====================

  - name: get_backlog
    description: "Get backlog issues"
    tool: jira_list_issues
    args:
      project: "{{ inputs.project }}"
      status: "Backlog"
      limit: "{{ inputs.limit }}"
    output: backlog_raw
    on_error: auto_heal  # Jira API - may need auth refresh

  - name: parse_backlog
    description: "Parse backlog issues"
    compute: |
      backlog_text = str(backlog_raw) if 'backlog_raw' in dir() and backlog_raw else ""

      import re
      issues = []

      # Extract issue keys and summaries
      for line in backlog_text.split("\n"):
        key_match = re.search(r'(AAP-\d+)', line)
        if key_match:
          key = key_match.group(1)
          # Get summary after the key
          summary = line.split(key)[-1].strip()[:60] if key in line else ""
          issues.append({"key": key, "summary": summary})

      result = {
        "issues": issues[:inputs.limit],
        "count": len(issues),
      }
    output: backlog_info

  - name: get_blocked
    description: "Get blocked issues"
    tool: jira_list_blocked
    args:
      project: "{{ inputs.project }}"
    output: blocked_raw
    on_error: auto_heal  # Jira API - may need auth refresh

  - name: parse_blocked
    description: "Parse blocked issues"
    compute: |
      blocked_text = str(blocked_raw) if 'blocked_raw' in dir() and blocked_raw else ""

      import re
      blocked = []

      for line in blocked_text.split("\n"):
        key_match = re.search(r'(AAP-\d+)', line)
        if key_match:
          blocked.append(key_match.group(1))

      result = {
        "blocked": blocked,
        "count": len(blocked),
      }
    output: blocked_info

  - name: get_ready_issues
    description: "Get issues ready for development"
    tool: jira_list_issues
    args:
      project: "{{ inputs.project }}"
      status: "Ready for Development"
      limit: "{{ inputs.limit }}"
    output: ready_raw
    on_error: auto_heal  # Jira API - may need auth refresh

  - name: parse_ready
    description: "Parse ready issues"
    compute: |
      ready_text = str(ready_raw) if 'ready_raw' in dir() and ready_raw else ""

      import re
      ready = []

      for line in ready_text.split("\n"):
        key_match = re.search(r'(AAP-\d+)', line)
        if key_match:
          key = key_match.group(1)
          summary = line.split(key)[-1].strip()[:60] if key in line else ""
          ready.append({"key": key, "summary": summary})

      result = {
        "issues": ready,
        "count": len(ready),
      }
    output: ready_info

  - name: analyze_sprint_candidates
    description: "Identify best candidates for sprint"
    compute: |
      # Issues that are ready but not blocked
      ready_issues = ready_info.get("issues", [])
      blocked_keys = set(blocked_info.get("blocked", []))

      candidates = []
      for issue in ready_issues:
        if issue["key"] not in blocked_keys:
          candidates.append(issue)

      result = {
        "candidates": candidates[:10],
        "count": len(candidates),
      }
    output: sprint_candidates

outputs:
  - name: report
    value: |
      ## ðŸ“‹ Sprint Planning: {{ inputs.project }}

      ---

      ### ðŸ“¥ Backlog ({{ backlog_info.count }} issues)

      {% for issue in backlog_info.issues[:10] %}
      - **{{ issue.key }}**: {{ issue.summary }}
      {% endfor %}
      {% if backlog_info.count > 10 %}
      ... and {{ backlog_info.count - 10 }} more
      {% endif %}

      ---

      ### âœ… Ready for Development ({{ ready_info.count }})

      {% for issue in ready_info.issues[:10] %}
      - **{{ issue.key }}**: {{ issue.summary }}
      {% endfor %}

      ---

      ### ðŸš« Blocked ({{ blocked_info.count }})

      {% if blocked_info.count > 0 %}
      {% for key in blocked_info.blocked[:10] %}
      - {{ key }}
      {% endfor %}
      {% else %}
      No blocked issues! ðŸŽ‰
      {% endif %}

      ---

      ### ðŸŽ¯ Sprint Candidates ({{ sprint_candidates.count }})

      These are ready and not blocked:

      {% for issue in sprint_candidates.candidates %}
      - **{{ issue.key }}**: {{ issue.summary }}
      {% endfor %}

      {% if inputs.sprint %}
      ---

      ### Add to Sprint

      To add these to sprint "{{ inputs.sprint }}":

      {% for issue in sprint_candidates.candidates[:5] %}
      ```
      jira_add_to_sprint(issue_key='{{ issue.key }}', sprint='{{ inputs.sprint }}')
      ```
      {% endfor %}
      {% endif %}

      {% if planning_gotchas and planning_gotchas.has_gotchas %}
      ---

      ### âš ï¸ Project Gotchas (Consider for Estimation)

      {% for gotcha in planning_gotchas.gotchas[:5] %}
      - {{ gotcha }}
      {% endfor %}
      {% endif %}

      {% if sprint_planning_patterns and sprint_planning_patterns.has_patterns %}
      ---

      ### ðŸ“‹ Coding Patterns

      {% for pattern in sprint_planning_patterns.patterns[:3] %}
      - {{ pattern }}
      {% endfor %}
      {% endif %}

  # ==================== SEMANTIC SEARCH ====================

  - name: search_sprint_code
    description: "Search for code related to sprint planning issues"
    condition: "sprint_candidates and sprint_candidates.count > 0"
    tool: code_search
    args:
      query: "Jira sprint planning {{ inputs.project }} {{ sprint_candidates.candidates[0].key if sprint_candidates.candidates else '' }}"
      project: "automation-analytics-backend"
      limit: 3
    output: sprint_code_raw
    on_error: continue

  - name: parse_sprint_code
    description: "Parse sprint code search results"
    condition: "sprint_code_raw"
    compute: |
      code_result = sprint_code_raw if sprint_code_raw else {}

      related_code = []
      if isinstance(code_result, dict) and code_result.get('found'):
          for item in code_result.get('content', []):
              related_code.append(item.get('path', '') + ":" + str(item.get('line_number', '')))

      result = {
          "has_code": len(related_code) > 0,
          "code_snippets": related_code[:5],
      }
    output: sprint_code_search
    on_error: continue

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_planning_failures
    description: "Detect failure patterns from sprint planning"
    compute: |
      errors_detected = []

      # Check Jira failures
      backlog_text = str(backlog_issues_raw) if 'backlog_issues_raw' in dir() and backlog_issues_raw else ""
      blocked_text = str(blocked_issues_raw) if 'blocked_issues_raw' in dir() and blocked_issues_raw else ""
      combined = backlog_text + blocked_text

      if "command timed out" in combined.lower():
          errors_detected.append({
              "tool": "jira_list_issues",
              "pattern": "command timed out",
              "cause": "Jira API timeout - network or server issue",
              "fix": "Check VPN connection and retry"
          })
      if "unauthorized" in combined.lower():
          errors_detected.append({
              "tool": "jira_list_issues",
              "pattern": "unauthorized",
              "cause": "Jira authentication failed",
              "fix": "Check Jira credentials in config.json"
          })
      if "project does not exist" in combined.lower():
          errors_detected.append({
              "tool": "jira_list_issues",
              "pattern": "project does not exist",
              "cause": "Jira project key is incorrect",
              "fix": "Check project key (e.g., AAP, RHCLOUD)"
          })

      result = errors_detected
    output: planning_errors_detected
    on_error: continue

  - name: learn_planning_jira_failure
    description: "Learn from Jira timeout failures"
    condition: "planning_errors_detected and any(e.get('pattern') == 'command timed out' for e in planning_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "jira_list_issues"
      error_pattern: "command timed out"
      root_cause: "Jira API timeout - network or server issue"
      fix_description: "Check VPN connection and retry"
    output: planning_jira_fix_learned
    on_error: continue

  - name: log_planning_session
    description: "Log sprint planning to session"
    tool: memory_session_log
    args:
      action: "Sprint planning for {{ inputs.project }}"
      details: "Backlog: {{ backlog_info.count if backlog_info else 0 }}, Blocked: {{ blocked_info.count if blocked_info else 0 }}, Candidates: {{ sprint_candidates.count if sprint_candidates else 0 }}"
    on_error: continue

  - name: track_sprint_planning
    description: "Track sprint planning sessions for patterns"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "sprint_planning_sessions" not in patterns:
          patterns["sprint_planning_sessions"] = []

      # Record this planning session
      planning_record = {
          "project": inputs.project,
          "sprint": inputs.sprint if inputs.sprint else None,
          "backlog_count": backlog_info.count if backlog_info else 0,
          "blocked_count": blocked_info.count if blocked_info else 0,
          "ready_count": ready_info.count if ready_info else 0,
          "candidates_count": sprint_candidates.count if sprint_candidates else 0,
          "timestamp": datetime.now().isoformat(),
      }

      patterns["sprint_planning_sessions"].append(planning_record)

      # Keep last 50 planning sessions
      patterns["sprint_planning_sessions"] = patterns["sprint_planning_sessions"][-50:]

      memory.write_memory("learned/patterns", patterns)
      result = "planning session tracked"
    output: planning_tracking_result
    on_error: continue

  - name: track_blocked_issues_trend
    description: "Track blocked issues trend over time"
    condition: "blocked_info and blocked_info.count > 0"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "blocked_issues_trend" not in patterns:
          patterns["blocked_issues_trend"] = []

      # Record blocked issues snapshot
      trend_record = {
          "project": inputs.project,
          "count": blocked_info.count,
          "issues": blocked_info.blocked[:10] if blocked_info.blocked else [],
          "timestamp": datetime.now().isoformat(),
      }

      patterns["blocked_issues_trend"].append(trend_record)

      # Keep last 100 snapshots
      patterns["blocked_issues_trend"] = patterns["blocked_issues_trend"][-100:]

      memory.write_memory("learned/patterns", patterns)
      result = "blocked issues trend tracked"
    output: blocked_trend_result
    on_error: continue

  - name: save_sprint_context
    description: "Save sprint context for other skills"
    compute: |
      from datetime import datetime

      # Share context that other skills can use
      shared = memory.read_memory("state/shared_context") or {}

      shared["last_sprint_planning"] = {
          "timestamp": datetime.now().isoformat(),
          "project": inputs.project,
          "sprint": inputs.sprint if inputs.sprint else None,
          "backlog_count": backlog_info.count if backlog_info else 0,
          "blocked_count": blocked_info.count if blocked_info else 0,
          "candidates": [c["key"] for c in sprint_candidates.candidates[:5]] if sprint_candidates else [],
      }

      memory.write_memory("state/shared_context", shared)
      result = "sprint context saved"
    output: sprint_context_result
    on_error: continue
