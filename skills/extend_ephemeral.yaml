# Skill: Extend Ephemeral Namespace
# Extend the duration of an ephemeral namespace reservation

name: extend_ephemeral
description: |
  Extend the duration of an ephemeral namespace reservation.

  Use when:
  - Tests are taking longer than expected
  - You need more time to debug
  - Demo/testing session running long

  The skill will:
  1. List your current namespaces
  2. Get details on the target namespace
  3. Extend the reservation
  4. Confirm new expiry time

version: "1.0"

inputs:
  - name: namespace
    type: string
    required: false
    description: "Namespace to extend (will list yours if not specified)"

  - name: duration
    type: string
    required: false
    default: "1h"
    description: "How much time to add (e.g., '1h', '2h', '4h')"

  - name: list_only
    type: boolean
    required: false
    default: false
    description: "Just list namespaces without extending"

steps:
  # ==================== KNOWLEDGE INTEGRATION ====================

  - name: check_bonfire_known_issues
    description: "Check for known bonfire/ephemeral issues"
    compute: |
      # Check known issues for bonfire operations
      bonfire_issues = memory.check_known_issues("bonfire", "") or {}
      ephemeral_issues = memory.check_known_issues("ephemeral", "") or {}
      namespace_issues = memory.check_known_issues("namespace", "") or {}

      all_issues = []
      for issues in [bonfire_issues, ephemeral_issues, namespace_issues]:
          if issues and issues.get("matches"):
              all_issues.extend(issues.get("matches", [])[:2])

      result = {
          "has_known_issues": len(all_issues) > 0,
          "issues": all_issues[:5],
      }
    output: ephemeral_known_issues
    on_error: continue

  - name: get_ephemeral_gotchas
    description: "Get ephemeral-related gotchas from knowledge"
    tool: knowledge_query
    args:
      project: "automation-analytics-backend"
      persona: "devops"
      section: "gotchas"
    output: ephemeral_gotchas_raw
    on_error: continue

  - name: parse_ephemeral_gotchas
    description: "Parse ephemeral-related gotchas"
    compute: |
      gotchas_result = ephemeral_gotchas_raw if 'ephemeral_gotchas_raw' in dir() and ephemeral_gotchas_raw else {}

      ephemeral_gotchas = []
      if isinstance(gotchas_result, dict) and gotchas_result.get('found'):
          content = gotchas_result.get('content', [])
          if isinstance(content, list):
              # Filter for ephemeral-related gotchas
              for g in content:
                  g_str = str(g).lower()
                  if any(kw in g_str for kw in ['ephemeral', 'bonfire', 'namespace', 'reserve', 'extend', 'deploy']):
                      ephemeral_gotchas.append(g)

      result = {
          'gotchas': ephemeral_gotchas[:5],
          'has_gotchas': len(ephemeral_gotchas) > 0,
      }
    output: extend_gotchas
    on_error: continue

  # ==================== LIST NAMESPACES ====================

  - name: list_my_namespaces
    description: "List my ephemeral namespaces"
    tool: bonfire_namespace_list
    args:
      mine: true
    output: my_namespaces_raw
    on_error: auto_heal  # Ephemeral cluster - may need kube_login

  - name: parse_namespaces
    description: "Parse namespace list"
    compute: |
      ns_text = str(my_namespaces_raw) if my_namespaces_raw else ""

      namespaces = []
      for line in ns_text.split("\n"):
          line = line.strip()
          if line and "ephemeral" in line.lower():
              # Extract namespace name (usually first word)
              parts = line.split()
              if parts:
                  namespaces.append({
                      "name": parts[0],
                      "line": line[:100],
                  })

      result = {
          "namespaces": namespaces,
          "count": len(namespaces),
          "raw": ns_text[:800] if ns_text else "No namespaces found",
      }
    output: namespaces_list

  - name: select_namespace
    description: "Select namespace to extend"
    compute: |
      if inputs.namespace:
          target = inputs.namespace
      elif namespaces_list.get("count", 0) == 1:
          target = namespaces_list["namespaces"][0]["name"]
      elif namespaces_list.get("count", 0) > 1:
          target = None  # Need user to select
      else:
          target = None

      result = {"namespace": target, "needs_selection": target is None and namespaces_list.get("count", 0) > 1}
    output: selected_ns

  # ==================== GET NAMESPACE DETAILS ====================

  - name: describe_namespace
    description: "Get namespace details"
    condition: "selected_ns.namespace and not inputs.list_only"
    tool: bonfire_namespace_describe
    args:
      namespace: "{{ selected_ns.namespace }}"
    output: ns_describe_raw
    on_error: auto_heal  # Ephemeral cluster - may need kube_login

  - name: parse_describe
    description: "Parse namespace details"
    condition: "ns_describe_raw"
    compute: |
      desc_text = str(ns_describe_raw) if ns_describe_raw else ""

      # Extract key info
      import re

      # Look for expiry/reservation time
      expiry = None
      expiry_match = re.search(r'expir[a-z]*[:\s]+([^\n]+)', desc_text, re.I)
      if expiry_match:
          expiry = expiry_match.group(1).strip()

      # Look for owner
      owner = None
      owner_match = re.search(r'owner[:\s]+([^\n]+)', desc_text, re.I)
      if owner_match:
          owner = owner_match.group(1).strip()

      # Look for status
      status = "unknown"
      if "ready" in desc_text.lower():
          status = "ready"
      elif "reserved" in desc_text.lower():
          status = "reserved"

      result = {
          "expiry": expiry,
          "owner": owner,
          "status": status,
          "raw": desc_text[:600] if desc_text else "No details",
      }
    output: ns_details
    on_error: continue

  # ==================== EXTEND NAMESPACE ====================

  - name: extend_namespace
    description: "Extend the namespace reservation"
    condition: "selected_ns.namespace and not inputs.list_only"
    tool: bonfire_namespace_extend
    args:
      namespace: "{{ selected_ns.namespace }}"
      duration: "{{ inputs.duration }}"
    output: extend_result
    on_error: auto_heal  # Ephemeral cluster - may need kube_login

  - name: parse_extend_result
    description: "Parse extend result"
    condition: "extend_result"
    compute: |
      result_text = str(extend_result) if extend_result else ""

      success = "extended" in result_text.lower() or "success" in result_text.lower()

      # Extract new expiry
      import re
      new_expiry = None
      expiry_match = re.search(r'until[:\s]+([^\n]+)', result_text, re.I)
      if expiry_match:
          new_expiry = expiry_match.group(1).strip()

      result = {
          "success": success,
          "new_expiry": new_expiry,
          "raw": result_text[:400] if result_text else "No result",
      }
    output: extension_status
    on_error: continue

  # ==================== SEMANTIC SEARCH ====================

  - name: search_ephemeral_code
    description: "Search for code related to ephemeral namespace management"
    condition: "selected_ns and selected_ns.namespace"
    tool: code_search
    args:
      query: "ephemeral namespace {{ selected_ns.namespace }} bonfire extend"
      project: "automation-analytics-backend"
      limit: 3
    output: ephemeral_code_raw
    on_error: continue

  - name: parse_ephemeral_code
    description: "Parse ephemeral code search results"
    condition: "ephemeral_code_raw"
    compute: |
      code_result = ephemeral_code_raw if ephemeral_code_raw else {}

      related_code = []
      if isinstance(code_result, dict) and code_result.get('found'):
          for item in code_result.get('content', []):
              related_code.append(item.get('path', '') + ":" + str(item.get('line_number', '')))

      result = {
          "has_code": len(related_code) > 0,
          "code_snippets": related_code[:5],
      }
    output: ephemeral_code_search
    on_error: continue

  # ==================== MEMORY ====================

  - name: log_extension
    description: "Log extension to session"
    condition: "extension_status and extension_status.success"
    tool: memory_session_log
    args:
      action: "Extended ephemeral namespace"
      details: "{{ selected_ns.namespace }} + {{ inputs.duration }}"
    on_error: continue

  - name: track_extension_history
    description: "Track namespace extension history for patterns"
    condition: "extension_status and extension_status.success"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "namespace_extensions" not in patterns:
          patterns["namespace_extensions"] = []

      # Record this extension
      extension_record = {
          "namespace": selected_ns.namespace if selected_ns else "unknown",
          "duration": inputs.duration,
          "success": extension_status.success if extension_status else False,
          "new_expiry": extension_status.new_expiry if extension_status else None,
          "timestamp": datetime.now().isoformat(),
      }

      patterns["namespace_extensions"].append(extension_record)

      # Keep last 50 extension records
      patterns["namespace_extensions"] = patterns["namespace_extensions"][-50:]

      memory.write_memory("learned/patterns", patterns)
      result = "extension pattern learned"
    output: extension_pattern_result
    on_error: continue

  - name: update_ephemeral_state
    description: "Update ephemeral deployment state"
    condition: "extension_status and extension_status.success"
    tool: memory_append
    args:
      key: "state/ephemeral_deployments"
      list_path: "extensions"
      item: |
        namespace: {{ selected_ns.namespace if selected_ns else 'unknown' }}
        duration: {{ inputs.duration }}
        new_expiry: {{ extension_status.new_expiry if extension_status else 'unknown' }}
        timestamp: {{ now().isoformat() }}
    on_error: continue

outputs:
  - name: report
    value: |
      ## ‚è∞ Ephemeral Namespace Manager

      {% if inputs.list_only or not selected_ns.namespace %}
      ### üìã Your Ephemeral Namespaces

      {% if namespaces_list.count == 0 %}
      No ephemeral namespaces found.

      Reserve one:
      ```python
      bonfire_namespace_reserve(duration='2h')
      ```
      {% else %}
      Found **{{ namespaces_list.count }}** namespace(s):

      ```
      {{ namespaces_list.raw }}
      ```

      {% if selected_ns.needs_selection %}
      **Multiple namespaces found.** Specify which one:
      ```python
      skill_run("extend_ephemeral", '{"namespace": "ephemeral-xxxxx", "duration": "{{ inputs.duration }}"}')
      ```
      {% endif %}
      {% endif %}

      {% else %}
      ### üéØ Namespace: `{{ selected_ns.namespace }}`

      {% if ns_details %}
      **Status:** {{ ns_details.status }}
      {% if ns_details.expiry %}**Previous Expiry:** {{ ns_details.expiry }}{% endif %}
      {% if ns_details.owner %}**Owner:** {{ ns_details.owner }}{% endif %}
      {% endif %}

      ---

      {% if extension_status and extension_status.success %}
      ### ‚úÖ Extended Successfully

      Added **{{ inputs.duration }}** to the reservation.
      {% if extension_status.new_expiry %}
      **New Expiry:** {{ extension_status.new_expiry }}
      {% endif %}

      {% else %}
      ### ‚ùå Extension Failed

      {{ extension_status.raw if extension_status else "Could not extend namespace" }}

      Try manually:
      ```python
      bonfire_namespace_extend(namespace='{{ selected_ns.namespace }}', duration='{{ inputs.duration }}')
      ```
      {% endif %}

      ---

      ### Other Actions

      **Describe namespace:**
      ```python
      bonfire_namespace_describe(namespace='{{ selected_ns.namespace }}')
      ```

      **Release when done:**
      ```python
      bonfire_namespace_release(namespace='{{ selected_ns.namespace }}')
      ```

      **Get pods:**
      ```python
      kubectl_get_pods(namespace='{{ selected_ns.namespace }}', environment='ephemeral')
      ```

      {% if extend_gotchas and extend_gotchas.has_gotchas %}
      ---

      ### ‚ö†Ô∏è Ephemeral Gotchas

      {% for gotcha in extend_gotchas.gotchas[:3] %}
      - {{ gotcha }}
      {% endfor %}
      {% endif %}

      {% if ephemeral_known_issues and ephemeral_known_issues.has_known_issues %}
      ---

      ### üí° Known Issues

      {% for issue in ephemeral_known_issues.issues[:3] %}
      - {{ issue.pattern if issue.pattern else issue }}
      {% endfor %}
      {% endif %}
      {% endif %}

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_extend_failures
    description: "Detect failure patterns from ephemeral extension"
    compute: |
      errors_detected = []

      # Check bonfire failures
      namespaces_text = str(my_namespaces_raw) if 'my_namespaces_raw' in dir() and my_namespaces_raw else ""
      extend_text = str(extend_result_raw) if 'extend_result_raw' in dir() and extend_result_raw else ""
      combined = namespaces_text + extend_text

      if "no route to host" in combined.lower():
          errors_detected.append({
              "tool": "bonfire_namespace_extend",
              "pattern": "no route to host",
              "cause": "VPN not connected - ephemeral cluster not reachable",
              "fix": "Run vpn_connect() and kube_login('ephemeral')"
          })
      if "unauthorized" in combined.lower() or "forbidden" in combined.lower():
          errors_detected.append({
              "tool": "bonfire_namespace_extend",
              "pattern": "unauthorized",
              "cause": "Kubernetes auth expired for ephemeral cluster",
              "fix": "Run kube_login('ephemeral')"
          })
      if "not found" in combined.lower() and "namespace" in combined.lower():
          errors_detected.append({
              "tool": "bonfire_namespace_extend",
              "pattern": "namespace not found",
              "cause": "Namespace doesn't exist or already expired",
              "fix": "Reserve a new namespace with bonfire_namespace_reserve()"
          })

      result = errors_detected
    output: extend_errors_detected
    on_error: continue

  - name: learn_extend_vpn_failure
    description: "Learn from VPN failures"
    condition: "extend_errors_detected and any(e.get('pattern') == 'no route to host' for e in extend_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "bonfire_namespace_extend"
      error_pattern: "no route to host"
      root_cause: "VPN not connected - ephemeral cluster not reachable"
      fix_description: "Run vpn_connect() and kube_login('ephemeral')"
    output: extend_vpn_fix_learned
    on_error: continue

  - name: learn_extend_auth_failure
    description: "Learn from auth failures"
    condition: "extend_errors_detected and any(e.get('pattern') == 'unauthorized' for e in extend_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "bonfire_namespace_extend"
      error_pattern: "unauthorized"
      root_cause: "Kubernetes auth expired for ephemeral cluster"
      fix_description: "Run kube_login('ephemeral')"
    output: extend_auth_fix_learned
    on_error: continue

  - name: log_extend_session
    description: "Log extension to session"
    tool: memory_session_log
    args:
      action: "Extended ephemeral namespace {{ selected_ns.namespace if selected_ns else 'unknown' }}"
      details: "Duration: {{ inputs.duration }}, Success: {{ extension_status.success if extension_status else 'unknown' }}"
    on_error: continue

  - name: context
    value:
      namespace: "{{ selected_ns.namespace }}"
      extended: "{{ extension_status.success if extension_status else false }}"
      namespaces_count: "{{ namespaces_list.count }}"
