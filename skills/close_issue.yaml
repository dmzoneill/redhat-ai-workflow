# Skill: Close Issue
# Marks a Jira issue as Done with a summary of work completed

name: close_issue
description: |
  Close a Jira issue by transitioning it to Done.
  Adds a comment summarizing the work from branch commits.

  Resolves Jira statuses from config.json.
version: "1.2"

inputs:
  - name: issue_key
    type: string
    required: true
    description: "Jira issue key (e.g., AAP-12345)"

  - name: repo
    type: string
    required: false
    default: "."
    description: "Repository path to look for branch/commits"

  - name: add_comment
    type: boolean
    required: false
    default: true
    description: "Whether to add a closing comment with commit summary"

# No hardcoded constants - resolved from config.json

steps:
  # ==================== LOAD CONFIG ====================

  - name: load_config
    description: "Load Jira status configuration"
    compute: |
      from scripts.common.config_loader import load_config

      config = load_config()
      jira_statuses = config.get("jira", {}).get("statuses", {})

      result = {
          "done_status": jira_statuses.get("done", "Done"),
          "pending_release_status": jira_statuses.get("pending_release", "Pending Release"),
          "jira_url": config.get("jira", {}).get("url", "https://issues.redhat.com"),
      }
    output: cfg
  # ==================== AUTO-HEAL SETUP ====================

  - name: init_autoheal
    description: "Initialize failure tracking"
    compute: |
      result = {"jira_failures": []}
    output: autoheal_state
    on_error: continue

  # ==================== GET ISSUE DETAILS ====================

  # Step 1: Get current issue status
  - name: get_issue
    description: "Fetch current issue details"
    tool: jira_get_issue
    args:
      issue_key: "{{ inputs.issue_key }}"
    output: issue
    on_error: continue

  # ==================== AUTO-HEAL: get_issue ====================

  - name: detect_failure_issue
    description: "Detect if Jira call failed"
    compute: |
      from scripts.common.auto_heal import detect_failure

      result_text = str(issue) if 'issue' in dir() and issue else ""
      failure = detect_failure(result_text, "jira_get_issue")
      result = failure
    output: failure_issue
    on_error: continue

  - name: quick_fix_vpn_issue
    description: "Auto-fix VPN issues for Jira"
    condition: "failure_issue and failure_issue.get('error_type') == 'network'"
    tool: vpn_connect
    args: {}
    output: vpn_fix_issue
    on_error: continue

  - name: retry_get_issue
    description: "Retry Jira call after VPN fix"
    condition: "vpn_fix_issue and failure_issue"
    tool: jira_get_issue
    args:
      issue_key: "{{ inputs.issue_key }}"
    output: issue_retry
    on_error: continue

  - name: merge_issue_result
    description: "Use retry result if available"
    condition: "issue_retry"
    compute: |
      result = issue_retry
    output: issue

  # Step 2: Check current status
  - name: check_status
    compute: |
      status = issue.get('status', '').lower()

      # Already done?
      if status == 'done':
        result = {"already_done": True, "message": f"Issue {inputs.issue_key} is already Done."}
      else:
        result = {"already_done": False, "current_status": status}
    output: status_check

  # ==================== GET BRANCH AND COMMITS ====================

  # Step 3: Find branch for this issue (using MCP tool)
  - name: list_branches
    description: "List all git branches"
    condition: "{{ not status_check.already_done }}"
    tool: git_branch_list
    args:
      repo: "{{ inputs.repo }}"
      all_branches: true
    output: branches_raw
    on_error: continue

  - name: find_branch
    description: "Find branch matching this issue using shared parser"
    condition: "{{ not status_check.already_done }}"
    compute: |
      from scripts.common.parsers import parse_git_branches

      issue_key = inputs.issue_key.upper()

      # Use shared parser with issue key filter
      branches = parse_git_branches(branches_raw or "", issue_key=issue_key)

      result = {
        "found": len(branches) > 0,
        "branches": branches,
        "primary": branches[0] if branches else None
      }
    output: branch_info

  # Step 4: Get commits from the branch (using MCP tool)
  - name: get_commit_log
    description: "Get commits from the issue branch"
    condition: "{{ not status_check.already_done and branch_info.found }}"
    tool: git_log
    args:
      repo: "{{ inputs.repo }}"
      limit: 20
      oneline: true
    output: commit_log_raw
    on_error: continue

  - name: parse_commits
    description: "Parse commit log"
    condition: "{{ not status_check.already_done and branch_info.found }}"
    compute: |
      commits = []
      if commit_log_raw:
        for line in str(commit_log_raw).strip().split('\n'):
          if line.strip():
            parts = line.split(' ', 1)
            if len(parts) == 2:
              commits.append({
                "sha": parts[0],
                "message": parts[1]
              })

      result = {
        "branch": branch_info['primary'],
        "base": "main",
        "commits": commits[:20],
        "count": len(commits)
      }
    output: commit_info
    on_error: continue

  # Step 5: Get MR info if exists
  - name: get_mr
    description: "Check for associated Merge Request"
    condition: "{{ not status_check.already_done }}"
    tool: gitlab_list_mrs
    args:
      search: "{{ inputs.issue_key }}"
      state: "all"
    output: mr_list
    on_error: continue

  # Step 6: Extract MR details
  - name: parse_mr
    condition: "{{ not status_check.already_done and mr_list }}"
    compute: |
      mrs = mr_list if isinstance(mr_list, list) else []

      relevant_mr = None
      for mr in mrs:
        if isinstance(mr, dict):
          title = mr.get('title', '')
          if inputs.issue_key.upper() in title.upper():
            relevant_mr = {
              "id": mr.get('iid'),
              "title": mr.get('title'),
              "state": mr.get('state'),
              "merged": mr.get('state') == 'merged',
              "url": mr.get('web_url')
            }
            break

      result = relevant_mr
    output: mr_info
    on_error: continue

  # ==================== BUILD CLOSING COMMENT ====================

  # Step 7: Build the closing comment
  - name: build_comment
    condition: "{{ not status_check.already_done and inputs.add_comment }}"
    compute: |
      lines = []
      lines.append("h3. âœ… Issue Completed")
      lines.append("")

      # Branch info
      if branch_info.get('found'):
        lines.append(f"*Branch:* {{code}}{branch_info['primary']}{{code}}")

      # MR info
      if mr_info:
        status_emoji = "âœ…" if mr_info.get('merged') else "ğŸ”„"
        lines.append(f"*Merge Request:* [{mr_info['title']}|{mr_info['url']}] {status_emoji}")
        lines.append("")

      # Commits
      if commit_info and commit_info.get('commits'):
        lines.append("h4. Commits")
        lines.append("||SHA||Message||")
        for c in commit_info['commits'][:10]:
          sha_short = c['sha'][:7]
          msg = c['message'][:60].replace('|', '\\|')
          lines.append(f"|{{monospace}}{sha_short}{{monospace}}|{msg}|")

        if commit_info['count'] > 10:
          lines.append(f"_... and {commit_info['count'] - 10} more commits_")
      elif not branch_info.get('found'):
        lines.append("_No branch found for this issue._")
      else:
        lines.append("_No commits found on branch._")

      lines.append("")
      lines.append("----")
      lines.append("_Closed via workflow automation_")

      result = '\n'.join(lines)
    output: closing_comment

  # ==================== UPDATE JIRA ====================

  # Step 8: Add the closing comment
  - name: add_closing_comment
    description: "Add closing comment to Jira"
    condition: "{{ not status_check.already_done and inputs.add_comment and closing_comment }}"
    tool: jira_add_comment
    args:
      issue_key: "{{ inputs.issue_key }}"
      comment: "{{ closing_comment }}"
    output: comment_result
    on_error: continue

  # Step 9: Check available transitions
  - name: get_available_transitions
    description: "Check what transitions are available from current status"
    condition: "{{ not status_check.already_done }}"
    tool: jira_get_transitions
    args:
      issue_key: "{{ inputs.issue_key }}"
    output: available_transitions
    on_error: continue

  # Step 10: Validate and select transition
  - name: select_transition
    description: "Select the transition to Done using shared parser"
    condition: "{{ not status_check.already_done }}"
    compute: |
      from scripts.common.parsers import find_transition_name

      target_status = cfg["done_status"]
      transitions_text = str(available_transitions) if available_transitions else ""

      # Look for Done transition in available transitions
      done_available = target_status.lower() in transitions_text.lower()
      transition_name = target_status

      # Use shared parser to find exact transition name
      if not done_available:
          found_name = find_transition_name(transitions_text)
          if found_name:
              done_available = True
              transition_name = found_name

      if not done_available and available_transitions:
          # List what's available
          result = {
              "target_status": target_status,
              "transition_available": False,
              "error": (
                  f"'{target_status}' transition not available from current status. "
                  f"Available: {transitions_text[:200]}"
              ),
          }
      else:
          result = {
              "target_status": transition_name,
              "transition_available": True,
              "error": None,
          }
    output: transition_target

  - name: do_transition
    description: "Execute the transition"
    condition: "{{ not status_check.already_done and transition_target.transition_available }}"
    tool: jira_transition_issue
    args:
      issue_key: "{{ inputs.issue_key }}"
      transition: "{{ transition_target.target_status }}"
    output: transition_result
    on_error: continue

  # ==================== VERIFY ====================

  # Step 10: Verify the issue is now Done
  - name: verify_status
    description: "Verify issue status after transition"
    condition: "{{ not status_check.already_done }}"
    tool: jira_get_issue
    args:
      issue_key: "{{ inputs.issue_key }}"
    output: final_issue
    on_error: continue

  # Step 11: Emit issue closed hook
  - name: emit_issue_closed_hook
    description: "Notify team channel about closed issue"
    condition: "not status_check.already_done"
    compute: |
      # emit_event is available from skill engine safe_globals
      commit_count = commit_info.get("count", 0) if commit_info else 0

      if emit_event:
          emit_event("issue_closed", {
              "issue_key": inputs.issue_key,
              "commit_count": str(commit_count),
          })
          result = "hook sent"
      else:
          result = "hook skipped: emit_event not available"
    output: close_hook_result
    on_error: continue

  # ==================== MEMORY INTEGRATION ====================

  - name: build_memory_context
    description: "Build timestamp for memory"
    condition: "{{ not status_check.already_done }}"
    compute: |
      from datetime import datetime
      result = {"timestamp": datetime.now().isoformat()}
    output: memory_context

  - name: log_session_issue_closed
    description: "Log issue closure to session log"
    condition: "{{ not status_check.already_done }}"
    tool: memory_session_log
    args:
      action: "Closed issue {{ inputs.issue_key }}"
      details: "Commits: {{ commit_info.count if commit_info else 0 }}, MR merged: {{ mr_info.merged if mr_info else 'N/A' }}"
    on_error: continue

  - name: remove_from_active_issues
    description: "Remove issue from active_issues in memory"
    condition: "{{ not status_check.already_done }}"
    compute: |
      # Use shared memory helpers
      issue_key = inputs.issue_key.upper()

      # Remove from active_issues
      memory.remove_from_list("state/current_work", "active_issues", "key", issue_key)

      # Also remove from open_mrs if MR was merged
      if mr_info and mr_info.get("merged"):
          # Find MRs related to this issue and remove them
          data = memory.read_memory("state/current_work")
          open_mrs = data.get("open_mrs", []) if isinstance(data.get("open_mrs"), list) else []
          data["open_mrs"] = [
              m for m in open_mrs
              if m.get("issue_key", "").upper() != issue_key
          ]
          memory.write_memory("state/current_work", data)

      result = "memory updated"
    output: memory_cleanup_result
    on_error: continue

outputs:
  - name: summary
    value: |
      {% if status_check.already_done %}
      {{ status_check.message }}
      {% else %}
      ## âœ… Issue Closed: {{ inputs.issue_key }}

      **Status:** {{ final_issue.status if final_issue else 'Done' }}

      {% if branch_info.found %}
      **Branch:** `{{ branch_info.primary }}`
      {% endif %}

      {% if commit_info and commit_info.count > 0 %}
      **Commits:** {{ commit_info.count }}
      {% for c in commit_info.commits[:5] %}
      - `{{ c.sha[:7] }}` {{ c.message[:50] }}
      {% endfor %}
      {% endif %}

      {% if mr_info %}
      **MR:** [{{ mr_info.title }}]({{ mr_info.url }}) - {{ 'Merged âœ…' if mr_info.merged else mr_info.state }}
      {% endif %}

      {% if inputs.add_comment %}
      ğŸ“ Closing comment added to Jira
      {% endif %}

      ğŸ”— [View Issue]({{ cfg.jira.url }}/browse/{{ inputs.issue_key }})
      {% endif %}

  - name: context
    value:
      issue_key: "{{ inputs.issue_key }}"
      closed: "{{ not status_check.already_done }}"
      branch: "{{ branch_info.primary if branch_info else None }}"
      commits: "{{ commit_info.count if commit_info else 0 }}"
      mr_merged: "{{ mr_info.merged if mr_info else False }}"
