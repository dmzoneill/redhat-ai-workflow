# Skill: Close Issue
# Marks a Jira issue as Done with a summary of work completed

name: close_issue
description: |
  Close a Jira issue by transitioning it to Done.
  Adds a comment summarizing the work from branch commits.
  
  Resolves Jira statuses from config.json.
version: "1.1"

inputs:
  - name: issue_key
    type: string
    required: true
    description: "Jira issue key (e.g., AAP-12345)"
  
  - name: repo
    type: string
    required: false
    default: "."
    description: "Repository path to look for branch/commits"
  
  - name: add_comment
    type: boolean
    required: false
    default: true
    description: "Whether to add a closing comment with commit summary"

# No hardcoded constants - resolved from config.json

steps:
  # ==================== LOAD CONFIG ====================

  - name: load_config
    description: "Load Jira status configuration"
    compute: |
      from scripts.common.config_loader import load_config
      
      config = load_config()
      jira_statuses = config.get("jira", {}).get("statuses", {})
      
      result = {
          "done_status": jira_statuses.get("done", "Done"),
          "pending_release_status": jira_statuses.get("pending_release", "Pending Release"),
          "jira_url": config.get("jira", {}).get("url", "https://issues.redhat.com"),
      }
    output: cfg
  # ==================== GET ISSUE DETAILS ====================

  # Step 1: Get current issue status
  - name: get_issue
    description: "Fetch current issue details"
    tool: jira_get_issue
    args:
      issue_key: "{{ inputs.issue_key }}"
    output: issue

  # Step 2: Check current status
  - name: check_status
    compute: |
      status = issue.get('status', '').lower()
      
      # Already done?
      if status == 'done':
        result = {"already_done": True, "message": f"Issue {inputs.issue_key} is already Done."}
      else:
        result = {"already_done": False, "current_status": status}
    output: status_check

  # ==================== GET BRANCH AND COMMITS ====================

  # Step 3: Find branch for this issue (using MCP tool)
  - name: list_branches
    description: "List all git branches"
    condition: "{{ not status_check.already_done }}"
    tool: git_branch_list
    args:
      repo: "{{ inputs.repo }}"
      all_branches: true
    output: branches_raw
    on_error: continue

  - name: find_branch
    description: "Find branch matching this issue"
    condition: "{{ not status_check.already_done }}"
    compute: |
      import re
      
      issue_key = inputs.issue_key.upper()
      
      branches = []
      if branches_raw:
        for line in str(branches_raw).split('\n'):
          branch = line.strip().replace('* ', '').replace('remotes/origin/', '')
          if branch and issue_key in branch.upper():
            if branch not in branches:
              branches.append(branch)
      
      result = {
        "found": len(branches) > 0,
        "branches": branches,
        "primary": branches[0] if branches else None
      }
    output: branch_info

  # Step 4: Get commits from the branch (using MCP tool)
  - name: get_commit_log
    description: "Get commits from the issue branch"
    condition: "{{ not status_check.already_done and branch_info.found }}"
    tool: git_log
    args:
      repo: "{{ inputs.repo }}"
      limit: 20
      oneline: true
    output: commit_log_raw
    on_error: continue

  - name: parse_commits
    description: "Parse commit log"
    condition: "{{ not status_check.already_done and branch_info.found }}"
    compute: |
      commits = []
      if commit_log_raw:
        for line in str(commit_log_raw).strip().split('\n'):
          if line.strip():
            parts = line.split(' ', 1)
            if len(parts) == 2:
              commits.append({
                "sha": parts[0],
                "message": parts[1]
              })
      
      result = {
        "branch": branch_info['primary'],
        "base": "main",
        "commits": commits[:20],
        "count": len(commits)
      }
    output: commit_info
    on_error: continue

  # Step 5: Get MR info if exists
  - name: get_mr
    description: "Check for associated Merge Request"
    condition: "{{ not status_check.already_done }}"
    tool: gitlab_list_mrs
    args:
      search: "{{ inputs.issue_key }}"
      state: "all"
    output: mr_list
    on_error: continue

  # Step 6: Extract MR details
  - name: parse_mr
    condition: "{{ not status_check.already_done and mr_list }}"
    compute: |
      mrs = mr_list if isinstance(mr_list, list) else []
      
      relevant_mr = None
      for mr in mrs:
        if isinstance(mr, dict):
          title = mr.get('title', '')
          if inputs.issue_key.upper() in title.upper():
            relevant_mr = {
              "id": mr.get('iid'),
              "title": mr.get('title'),
              "state": mr.get('state'),
              "merged": mr.get('state') == 'merged',
              "url": mr.get('web_url')
            }
            break
      
      result = relevant_mr
    output: mr_info
    on_error: continue

  # ==================== BUILD CLOSING COMMENT ====================

  # Step 7: Build the closing comment
  - name: build_comment
    condition: "{{ not status_check.already_done and inputs.add_comment }}"
    compute: |
      lines = []
      lines.append("h3. âœ… Issue Completed")
      lines.append("")
      
      # Branch info
      if branch_info.get('found'):
        lines.append(f"*Branch:* {{code}}{branch_info['primary']}{{code}}")
      
      # MR info
      if mr_info:
        status_emoji = "âœ…" if mr_info.get('merged') else "ğŸ”„"
        lines.append(f"*Merge Request:* [{mr_info['title']}|{mr_info['url']}] {status_emoji}")
        lines.append("")
      
      # Commits
      if commit_info and commit_info.get('commits'):
        lines.append("h4. Commits")
        lines.append("||SHA||Message||")
        for c in commit_info['commits'][:10]:
          sha_short = c['sha'][:7]
          msg = c['message'][:60].replace('|', '\\|')
          lines.append(f"|{{monospace}}{sha_short}{{monospace}}|{msg}|")
        
        if commit_info['count'] > 10:
          lines.append(f"_... and {commit_info['count'] - 10} more commits_")
      elif not branch_info.get('found'):
        lines.append("_No branch found for this issue._")
      else:
        lines.append("_No commits found on branch._")
      
      lines.append("")
      lines.append("----")
      lines.append("_Closed via workflow automation_")
      
      result = '\n'.join(lines)
    output: closing_comment

  # ==================== UPDATE JIRA ====================

  # Step 8: Add the closing comment
  - name: add_closing_comment
    description: "Add closing comment to Jira"
    condition: "{{ not status_check.already_done and inputs.add_comment and closing_comment }}"
    tool: jira_add_comment
    args:
      issue_key: "{{ inputs.issue_key }}"
      comment: "{{ closing_comment }}"
    output: comment_result
    on_error: continue

  # Step 9: Check available transitions
  - name: get_available_transitions
    description: "Check what transitions are available from current status"
    condition: "{{ not status_check.already_done }}"
    tool: jira_get_transitions
    args:
      issue_key: "{{ inputs.issue_key }}"
    output: available_transitions
    on_error: continue

  # Step 10: Validate and select transition
  - name: select_transition
    description: "Select the transition to Done"
    condition: "{{ not status_check.already_done }}"
    compute: |
      import re
      
      target_status = cfg["done_status"]
      transitions_text = str(available_transitions) if available_transitions else ""
      
      # Look for Done transition in available transitions
      done_available = False
      transition_name = target_status
      
      # Parse available transitions
      # Format varies but usually contains "Done" or the target status
      if target_status.lower() in transitions_text.lower():
          done_available = True
      
      # Also check for common variations
      for variation in ["Done", "Close", "Resolve", "Complete"]:
          if variation.lower() in transitions_text.lower():
              done_available = True
              # Try to extract exact transition name
              match = re.search(rf"({variation}[^,\n]*)", transitions_text, re.IGNORECASE)
              if match:
                  transition_name = match.group(1).strip()
              break
      
      if not done_available and available_transitions:
          # List what's available
          result = {
              "target_status": target_status,
              "transition_available": False,
              "error": (
                  f"'{target_status}' transition not available from current status. "
                  f"Available: {transitions_text[:200]}"
              ),
          }
      else:
          result = {
              "target_status": transition_name,
              "transition_available": True,
              "error": None,
          }
    output: transition_target

  - name: do_transition
    description: "Execute the transition"
    condition: "{{ not status_check.already_done and transition_target.transition_available }}"
    tool: jira_transition_issue
    args:
      issue_key: "{{ inputs.issue_key }}"
      transition: "{{ transition_target.target_status }}"
    output: transition_result
    on_error: continue

  # ==================== VERIFY ====================

  # Step 10: Verify the issue is now Done
  - name: verify_status
    description: "Verify issue status after transition"
    condition: "{{ not status_check.already_done }}"
    tool: jira_get_issue
    args:
      issue_key: "{{ inputs.issue_key }}"
    output: final_issue
    on_error: continue

  # Step 11: Emit issue closed hook
  - name: emit_issue_closed_hook
    description: "Notify team channel about closed issue"
    condition: "not status_check.already_done"
    compute: |
      import asyncio
      import sys
      from pathlib import Path
      from scripts.common.config_loader import load_config
      sys.path.insert(0, str(Path.home() / "src/redhat-ai-workflow"))
      
      try:
          from scripts.skill_hooks import emit_event
          
          commit_count = commit_info.get("count", 0) if commit_info else 0
          
          asyncio.run(emit_event("issue_closed", {
              "issue_key": inputs.issue_key,
              "commit_count": str(commit_count),
          }))
          result = "hook sent"
      except Exception as e:
          result = f"hook skipped: {e}"
    output: close_hook_result
    on_error: continue

outputs:
  - name: summary
    value: |
      {% if status_check.already_done %}
      {{ status_check.message }}
      {% else %}
      ## âœ… Issue Closed: {{ inputs.issue_key }}
      
      **Status:** {{ final_issue.status if final_issue else 'Done' }}
      
      {% if branch_info.found %}
      **Branch:** `{{ branch_info.primary }}`
      {% endif %}
      
      {% if commit_info and commit_info.count > 0 %}
      **Commits:** {{ commit_info.count }}
      {% for c in commit_info.commits[:5] %}
      - `{{ c.sha[:7] }}` {{ c.message[:50] }}
      {% endfor %}
      {% endif %}
      
      {% if mr_info %}
      **MR:** [{{ mr_info.title }}]({{ mr_info.url }}) - {{ 'Merged âœ…' if mr_info.merged else mr_info.state }}
      {% endif %}
      
      {% if inputs.add_comment %}
      ğŸ“ Closing comment added to Jira
      {% endif %}
      
      ğŸ”— [View Issue]({{ cfg.jira.url }}/browse/{{ inputs.issue_key }})
      {% endif %}
  
  - name: context
    value:
      issue_key: "{{ inputs.issue_key }}"
      closed: "{{ not status_check.already_done }}"
      branch: "{{ branch_info.primary if branch_info else None }}"
      commits: "{{ commit_info.count if commit_info else 0 }}"
      mr_merged: "{{ mr_info.merged if mr_info else False }}"

