# Skill: App Interface Check
# Validate app-interface configuration and compare to live state

name: appinterface_check
description: |
  Comprehensive app-interface validation and release readiness check.

  This skill:
  - Validates YAML configuration, $ref paths, and SHA formats
  - Compares app-interface refs to live cluster state
  - Shows resource quotas and limits
  - Lists pending MRs that may affect release
  - Assesses overall release readiness with blockers/warnings

  Uses: appinterface_get_saas, appinterface_diff, appinterface_resources,
        kubectl_get_deployments, kubectl_get_resourcequotas, gitlab_mr_list
version: "3.1"

inputs:
  - name: saas_file
    type: string
    required: false
    default: "tower-analytics"
    description: "SaaS file name to check (service name)"

  - name: namespace_stage
    type: string
    required: false
    default: "tower-analytics-stage"
    description: "Stage namespace"

  - name: namespace_prod
    type: string
    required: false
    default: "tower-analytics-prod"
    description: "Production namespace"

  - name: deployment
    type: string
    required: false
    default: "automation-analytics-api-fastapi-v2"
    description: "Deployment to check for live SHA"

  - name: stale_days
    type: integer
    required: false
    default: 7
    description: "Alert if deployed SHA is older than this many days"

  - name: gitlab_project
    type: string
    required: false
    default: "automation-analytics/automation-analytics-backend"
    description: "GitLab project to check for pending MRs"

steps:
  # ==================== GET SAAS FILES ====================

  - name: get_saas_file
    description: "Get SaaS file details"
    tool: appinterface_get_saas
    args:
      service_name: "{{ inputs.saas_file }}"
    output: saas_raw
    on_error: continue

  - name: parse_saas_refs
    description: "Extract stage and prod refs from SaaS file"
    compute: |
      import re

      saas_text = str(saas_raw) if 'saas_raw' in dir() and saas_raw else ""

      # Find all refs (40-char hex SHAs)
      sha_pattern = r'ref:\s*([a-f0-9]{40})'
      sha_refs = re.findall(sha_pattern, saas_text)

      # Find all $ref paths
      ref_paths = re.findall(r'\$ref:\s*(\S+)', saas_text)

      # Try to identify stage vs prod refs from context
      stage_ref = None
      prod_ref = None

      lines = saas_text.split('\n')
      in_stage = False
      in_prod = False

      for i, line in enumerate(lines):
        if 'stage' in line.lower():
          in_stage = True
          in_prod = False
        elif 'prod' in line.lower():
          in_prod = True
          in_stage = False

        sha_match = re.search(r'ref:\s*([a-f0-9]{40})', line)
        if sha_match:
          if in_stage and not stage_ref:
            stage_ref = sha_match.group(1)
          elif in_prod and not prod_ref:
            prod_ref = sha_match.group(1)

      # Fallback: use first two refs found
      if not stage_ref and len(sha_refs) > 0:
        stage_ref = sha_refs[0]
      if not prod_ref and len(sha_refs) > 1:
        prod_ref = sha_refs[1]

      result = {
        "stage_ref": stage_ref or "main",
        "prod_ref": prod_ref or "unknown",
        "all_refs": sha_refs[:5],
        "ref_paths": ref_paths[:10],
        "raw_preview": saas_text[:1000],
      }
    output: saas_refs

  # ==================== VALIDATION ====================

  - name: validate_refs
    description: "Validate $ref paths and SHA formats"
    compute: |
      import re
      import os

      saas_text = str(saas_raw) if 'saas_raw' in dir() and saas_raw else ""
      issues = []
      warnings = []

      # Check SHA format (must be 40-char hex or 'main')
      sha_pattern = r'ref:\s*(\S+)'
      refs = re.findall(sha_pattern, saas_text)

      for ref in refs:
        if ref == 'main':
          continue
        if not re.match(r'^[a-f0-9]{40}$', ref):
          if re.match(r'^[a-f0-9]+$', ref) and len(ref) < 40:
            issues.append(f"Short SHA detected: {ref[:12]}... (should be 40 chars)")
          elif not ref.startswith('/') and not ref.startswith('$'):
            warnings.append(f"Non-standard ref: {ref[:30]}")

      # Check $ref paths point to reasonable locations
      ref_paths = re.findall(r'\$ref:\s*(/\S+)', saas_text)
      for path in ref_paths:
        if not path.startswith('/services/') and not path.startswith('/dependencies/'):
          warnings.append(f"Unusual $ref path: {path[:40]}")

      # Check required fields
      required_fields = ['name:', 'app:', 'resourceTemplates:']
      for field in required_fields:
        if field not in saas_text:
          issues.append(f"Missing required field: {field}")

      valid = len(issues) == 0

      result = {
        "valid": valid,
        "issues": issues,
        "warnings": warnings,
        "ref_count": len(refs),
        "path_count": len(ref_paths),
      }
    output: validation_result

  # ==================== GET LIVE STATE ====================

  - name: get_live_stage
    description: "Get live deployment from stage cluster"
    tool: kubectl_get_deployments
    args:
      namespace: "{{ inputs.namespace_stage }}"
      environment: "stage"
    output: live_stage_raw
    on_error: continue

  - name: parse_live_stage
    description: "Extract deployed image SHA from stage"
    compute: |
      import re

      deploy_text = str(live_stage_raw) if 'live_stage_raw' in dir() and live_stage_raw else ""
      deployment_name = str(inputs.get('deployment', 'automation-analytics-api-fastapi-v2'))

      # Look for image tags in the deployment output
      # Format: quay.io/...@sha256:xxx or :sha
      image_pattern = r'quay\.io/[^\s]+[:\@]([a-f0-9]{40,64})'
      images = re.findall(image_pattern, deploy_text)

      # Also check for IMAGE column in kubectl output
      sha_pattern = r'([a-f0-9]{40})'
      shas = re.findall(sha_pattern, deploy_text)

      live_sha = None
      if shas:
        # Prefer 40-char git SHAs over 64-char digests
        for sha in shas:
          if len(sha) == 40:
            live_sha = sha
            break
        if not live_sha:
          live_sha = shas[0][:40] if shas else None

      result = {
        "live_sha": live_sha,
        "deployment_found": deployment_name in deploy_text,
        "raw": deploy_text[:500] if deploy_text else "",
      }
    output: live_stage

  - name: get_live_prod
    description: "Get live deployment from prod cluster"
    tool: kubectl_get_deployments
    args:
      namespace: "{{ inputs.namespace_prod }}"
      environment: "prod"
    output: live_prod_raw
    on_error: continue

  - name: parse_live_prod
    description: "Extract deployed image SHA from prod"
    compute: |
      import re

      deploy_text = str(live_prod_raw) if 'live_prod_raw' in dir() and live_prod_raw else ""

      sha_pattern = r'([a-f0-9]{40})'
      shas = re.findall(sha_pattern, deploy_text)

      live_sha = shas[0] if shas else None

      result = {
        "live_sha": live_sha,
        "raw": deploy_text[:500] if deploy_text else "",
      }
    output: live_prod

  # ==================== COMPARE STATE ====================

  - name: compare_state
    description: "Compare app-interface refs to live state"
    compute: |
      from datetime import datetime, timedelta

      stage_ref = saas_refs.get('stage_ref', 'unknown') if isinstance(saas_refs, dict) else 'unknown'
      prod_ref = saas_refs.get('prod_ref', 'unknown') if isinstance(saas_refs, dict) else 'unknown'

      live_stage_sha = live_stage.get('live_sha') if isinstance(live_stage, dict) else None
      live_prod_sha = live_prod.get('live_sha') if isinstance(live_prod, dict) else None

      # Compare stage
      stage_match = False
      if stage_ref and live_stage_sha:
        stage_match = stage_ref[:12] == live_stage_sha[:12] if live_stage_sha else False

      # Compare prod
      prod_match = False
      if prod_ref and live_prod_sha:
        prod_match = prod_ref[:12] == live_prod_sha[:12] if live_prod_sha else False

      # Check if stage is ahead of prod (ready to promote)
      stage_ahead = stage_ref != prod_ref and stage_ref != 'main'

      # Build status
      issues = []
      if not stage_match and live_stage_sha:
        issues.append(f"Stage drift: app-interface has {stage_ref[:8]}... but cluster has {live_stage_sha[:8]}...")
      if not prod_match and live_prod_sha:
        issues.append(f"Prod drift: app-interface has {prod_ref[:8]}... but cluster has {live_prod_sha[:8]}...")

      result = {
        "stage_ref": stage_ref,
        "prod_ref": prod_ref,
        "live_stage_sha": live_stage_sha,
        "live_prod_sha": live_prod_sha,
        "stage_in_sync": stage_match,
        "prod_in_sync": prod_match,
        "stage_ahead_of_prod": stage_ahead,
        "issues": issues,
        "ready_to_promote": stage_ahead and stage_match,
      }
    output: state_comparison

  # ==================== CHECK FOR CHANGES ====================

  - name: get_diff
    description: "Get diff from main branch"
    tool: appinterface_diff
    args: {}
    output: diff_raw
    on_error: continue

  - name: parse_diff
    description: "Parse diff for tower-analytics changes"
    compute: |
      import re

      diff_text = str(diff_raw) if 'diff_raw' in dir() and diff_raw else ""
      service_name = str(inputs.get('saas_file', 'tower-analytics'))

      has_changes = len(diff_text.strip()) > 0 and "no changes" not in diff_text.lower()

      # Filter for service-specific changes
      file_changes = re.findall(r'^\+\+\+ b/(.+)$', diff_text, re.M)
      service_changes = [f for f in file_changes if service_name in f.lower()]

      result = {
        "has_changes": has_changes,
        "all_changed_files": len(file_changes),
        "service_changes": service_changes[:10],
        "service_change_count": len(service_changes),
        "preview": diff_text[:600] if diff_text else "",
      }
    output: diff_info

  # ==================== GET RESOURCES ====================

  - name: list_resources
    description: "List app-interface resources"
    tool: appinterface_resources
    args:
      namespace: "{{ inputs.namespace_stage }}"
    output: resources_raw
    on_error: continue

  - name: parse_resources
    description: "Parse resources"
    compute: |
      resources_text = str(resources_raw) if 'resources_raw' in dir() and resources_raw else ""

      resources = []
      for line in resources_text.split("\n"):
        line = line.strip()
        if line and not line.startswith("#") and not line.startswith("##"):
          resources.append(line[:80])

      result = {
        "resources": resources[:20],
        "count": len(resources),
      }
    output: resources_info

  # ==================== GET QUOTAS ====================

  - name: get_quota_stage
    description: "Get resource quotas from stage namespace"
    tool: kubectl_get
    args:
      resource: "resourcequota"
      namespace: "{{ inputs.namespace_stage }}"
      environment: "stage"
    output: quota_stage_raw
    on_error: continue

  - name: get_limits_stage
    description: "Get limit ranges from stage namespace"
    tool: kubectl_get
    args:
      resource: "limitrange"
      namespace: "{{ inputs.namespace_stage }}"
      environment: "stage"
    output: limits_stage_raw
    on_error: continue

  - name: parse_quotas
    description: "Parse quota and limit information"
    compute: |
      import re

      quota_text = str(quota_stage_raw) if 'quota_stage_raw' in dir() and quota_stage_raw else ""
      limits_text = str(limits_stage_raw) if 'limits_stage_raw' in dir() and limits_stage_raw else ""

      quotas = {}
      limits = {}

      # Parse CPU quota
      cpu_match = re.search(r'cpu[:\s]+(\d+[mM]?)', quota_text)
      if cpu_match:
        quotas['cpu'] = cpu_match.group(1)

      # Parse memory quota
      mem_match = re.search(r'memory[:\s]+(\d+[GgMmKk]i?)', quota_text)
      if mem_match:
        quotas['memory'] = mem_match.group(1)

      # Parse pod count
      pod_match = re.search(r'pods[:\s]+(\d+)', quota_text)
      if pod_match:
        quotas['pods'] = pod_match.group(1)

      # Parse limits
      limit_cpu = re.search(r'default.*cpu[:\s]+(\d+[mM]?)', limits_text, re.I)
      if limit_cpu:
        limits['default_cpu'] = limit_cpu.group(1)

      limit_mem = re.search(r'default.*memory[:\s]+(\d+[GgMmKk]i?)', limits_text, re.I)
      if limit_mem:
        limits['default_memory'] = limit_mem.group(1)

      result = {
        "quotas": quotas,
        "limits": limits,
        "quota_raw": quota_text[:300] if quota_text else "No quotas found",
        "limits_raw": limits_text[:300] if limits_text else "No limits found",
        "has_quotas": len(quotas) > 0,
        "has_limits": len(limits) > 0,
      }
    output: quota_info

  # ==================== GET PENDING MRs ====================

  - name: get_pending_mrs
    description: "Get open MRs that might affect this service"
    tool: gitlab_mr_list
    args:
      project: "{{ inputs.gitlab_project }}"
      state: "opened"
      per_page: 10
    output: mrs_raw
    on_error: continue

  - name: parse_pending_mrs
    description: "Parse pending MRs for release-relevant changes"
    compute: |
      import re

      mrs_text = str(mrs_raw) if 'mrs_raw' in dir() and mrs_raw else ""

      # Extract MR info from the listing
      mr_pattern = r'!(\d+)\s+\S+!(\d+)\s+(.+?)\s+\(main\)'
      mrs = re.findall(mr_pattern, mrs_text)

      pending_mrs = []
      for mr in mrs[:5]:
        mr_id = mr[0]
        title = mr[2].strip()[:60]
        pending_mrs.append({
          "id": mr_id,
          "title": title,
        })

      # Also extract from simpler format
      if not pending_mrs:
        simple_pattern = r'!(\d+)[^\n]+\n[^\n]*([A-Z]+-\d+[^\n]+)'
        simple_mrs = re.findall(simple_pattern, mrs_text)
        for mr in simple_mrs[:5]:
          pending_mrs.append({
            "id": mr[0],
            "title": mr[1].strip()[:60],
          })

      result = {
        "pending_mrs": pending_mrs,
        "count": len(pending_mrs),
        "raw": mrs_text[:500] if mrs_text else "",
      }
    output: pending_mrs_info

  # ==================== RELEASE READINESS ====================

  - name: assess_release_readiness
    description: "Assess overall release readiness"
    compute: |
      # Gather all signals
      validation_ok = validation_result.get('valid', False) if isinstance(validation_result, dict) else False
      stage_in_sync = state_comparison.get('stage_in_sync', False) if isinstance(state_comparison, dict) else False
      stage_ahead = state_comparison.get('stage_ahead_of_prod', False) if isinstance(state_comparison, dict) else False
      no_pending_changes = not diff_info.get('service_change_count', 0) if isinstance(diff_info, dict) else True
      pending_mr_count = pending_mrs_info.get('count', 0) if isinstance(pending_mrs_info, dict) else 0

      # Determine readiness
      ready = validation_ok and stage_ahead and no_pending_changes
      blockers = []

      if not validation_ok:
        blockers.append("Validation issues found")
      if not stage_ahead:
        blockers.append("Stage is not ahead of prod (nothing to promote)")
      if not no_pending_changes:
        blockers.append("Uncommitted changes in app-interface")

      warnings = []
      if pending_mr_count > 0:
        warnings.append(f"{pending_mr_count} open MRs - consider waiting for merge")
      if not stage_in_sync:
        warnings.append("Stage cluster may not reflect app-interface yet")

      stage_ref = state_comparison.get('stage_ref', '') if isinstance(state_comparison, dict) else ''
      prod_ref = state_comparison.get('prod_ref', '') if isinstance(state_comparison, dict) else ''

      result = {
        "ready": ready,
        "blockers": blockers,
        "warnings": warnings,
        "stage_ref": stage_ref,
        "prod_ref": prod_ref,
        "commits_ahead": 1 if stage_ahead else 0,  # Simplified
      }
    output: release_readiness

outputs:
  - name: report
    value: |
      ## ğŸ“‹ App-Interface Check: {{ inputs.saas_file }}

      ---

      ### âœ… Validation

      {% if validation_result.valid %}
      âœ… Configuration valid ({{ validation_result.ref_count }} refs, {{ validation_result.path_count }} paths)
      {% else %}
      âŒ **Issues found:**
      {% for issue in validation_result.issues %}
      - {{ issue }}
      {% endfor %}
      {% endif %}

      {% if validation_result.warnings %}
      âš ï¸ **Warnings:**
      {% for warn in validation_result.warnings %}
      - {{ warn }}
      {% endfor %}
      {% endif %}

      ---

      ### ğŸ”„ Live State Comparison

      **Stage:**
      - App-Interface: `{{ state_comparison.stage_ref[:12] }}...`
      - Live Cluster: `{{ state_comparison.live_stage_sha[:12] if state_comparison.live_stage_sha else 'N/A' }}`
      - Status: {% if state_comparison.stage_in_sync %}âœ… In Sync{% else %}âš ï¸ Drift{% endif %}

      **Prod:**
      - App-Interface: `{{ state_comparison.prod_ref[:12] }}...`
      - Live Cluster: `{{ state_comparison.live_prod_sha[:12] if state_comparison.live_prod_sha else 'N/A' }}`
      - Status: {% if state_comparison.prod_in_sync %}âœ… In Sync{% else %}âš ï¸ Drift{% endif %}

      {% if state_comparison.ready_to_promote %}
      ğŸš€ **Ready to promote!** Stage is ahead of prod and in sync with cluster.
      {% endif %}

      {% if state_comparison.stage_ahead_of_prod and not state_comparison.ready_to_promote %}
      â„¹ï¸ Stage has newer ref than prod ({{ state_comparison.stage_ref[:8] }}... vs {{ state_comparison.prod_ref[:8] }}...)
      {% endif %}

      {% if state_comparison.issues %}
      âš ï¸ **Drift detected:**
      {% for issue in state_comparison.issues %}
      - {{ issue }}
      {% endfor %}
      {% endif %}

      ---

      ### ğŸ“ Pending Changes

      {% if diff_info.service_change_count > 0 %}
      **{{ diff_info.service_change_count }} uncommitted changes for {{ inputs.saas_file }}:**
      {% for file in diff_info.service_changes %}
      - `{{ file }}`
      {% endfor %}
      {% elif diff_info.has_changes %}
      âœ… No changes to {{ inputs.saas_file }} ({{ diff_info.all_changed_files }} other files changed)
      {% else %}
      âœ… No uncommitted changes
      {% endif %}

      ---

      ### ğŸ“¦ Namespace Resources

      {{ resources_info.count }} config files for `{{ inputs.namespace_stage }}`

      {% if quota_info.has_quotas or quota_info.has_limits %}
      **Resource Quotas:**
      {% for key, val in quota_info.quotas.items() %}
      - {{ key }}: {{ val }}
      {% endfor %}

      **Default Limits:**
      {% for key, val in quota_info.limits.items() %}
      - {{ key }}: {{ val }}
      {% endfor %}
      {% endif %}

      ---

      ### ğŸ”€ Pending Merge Requests

      {% if pending_mrs_info.count > 0 %}
      **{{ pending_mrs_info.count }} open MRs:**
      {% for mr in pending_mrs_info.pending_mrs %}
      - !{{ mr.id }} - {{ mr.title }}
      {% endfor %}
      {% else %}
      âœ… No pending MRs
      {% endif %}

      ---

      ### ğŸš€ Release Readiness

      {% if release_readiness.ready %}
      âœ… **Ready to release!**
      - Stage ref: `{{ release_readiness.stage_ref[:12] }}...`
      - Prod ref: `{{ release_readiness.prod_ref[:12] }}...`
      {% else %}
      âŒ **Not ready to release**
      {% for blocker in release_readiness.blockers %}
      - âŒ {{ blocker }}
      {% endfor %}
      {% endif %}

      {% if release_readiness.warnings %}
      âš ï¸ **Warnings:**
      {% for warn in release_readiness.warnings %}
      - {{ warn }}
      {% endfor %}
      {% endif %}

      ---

      ### ğŸ› ï¸ Actions

      {% if release_readiness.ready %}
      ```python
      # Promote stage to prod
      skill_run("release_to_prod", '{"commit_sha": "{{ release_readiness.stage_ref }}"}')
      ```
      {% endif %}

      ```python
      # Check prod namespace
      skill_run("appinterface_check", '{"namespace_stage": "{{ inputs.namespace_prod }}"}')
      ```
