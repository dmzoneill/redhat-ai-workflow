# Slack Daemon Control Skill
# Controls the autonomous Slack daemon via D-Bus IPC
#
# Usage:
#   skill_run("slack_daemon_control", '{"action": "start"}')
#   skill_run("slack_daemon_control", '{"action": "status"}')
#   skill_run("slack_daemon_control", '{"action": "pending"}')
#   skill_run("slack_daemon_control", '{"action": "approve", "message_id": "xxx"}')
#   skill_run("slack_daemon_control", '{"action": "approve_all"}')
#   skill_run("slack_daemon_control", '{"action": "history", "limit": 50}')
#   skill_run("slack_daemon_control", '{"action": "send", "target": "C123", "message": "Hi!"}')
#   skill_run("slack_daemon_control", '{"action": "send", "target": "U123", "message": "Hi!"}')  # DM to user
#   skill_run("slack_daemon_control", '{"action": "send", "target": "@username", "message": "Hi!"}')  # DM by name
#   skill_run("slack_daemon_control", '{"action": "stop"}')

name: slack_daemon_control
version: "1.0"
description: |
  Control the autonomous Slack daemon via D-Bus IPC.

  Actions:
  - start: Launch daemon in background with nohup
  - stop: Gracefully shutdown the daemon
  - status: Get daemon status and stats
  - pending: List messages awaiting approval
  - approve <id>: Approve and send a pending message
  - approve_all: Approve all pending messages
  - reject <id>: Reject a pending message
  - history: Get message history with filters
  - send: Send a direct message to Slack
  - reload: Reload configuration

inputs:
  - name: action
    description: "Action to perform: start, stop, status, pending, approve, approve_all, reject, history, send, reload"
    type: string
    required: true

  - name: message_id
    description: "Message ID for approve/reject actions"
    type: string
    required: false

  - name: target
    description: "Target for send action: Channel (C123), User ID (U123), or @username"
    type: string
    required: false

  - name: channel
    description: "Alias for target (deprecated, use target instead)"
    type: string
    required: false

  - name: message
    description: "Message text for send action"
    type: string
    required: false

  - name: thread
    description: "Thread timestamp for send action"
    type: string
    required: false

  - name: limit
    description: "Limit for history query (default: 50)"
    type: integer
    required: false
    default: 50

  - name: filter_channel
    description: "Channel ID filter for history"
    type: string
    required: false

  - name: filter_user
    description: "User ID filter for history"
    type: string
    required: false

  - name: filter_status
    description: "Status filter for history (pending, sent, skipped, etc.)"
    type: string
    required: false

  - name: enable_llm
    description: "Enable LLM for start action"
    type: boolean
    required: false
    default: false

  - name: verbose
    description: "Enable verbose output for start action"
    type: boolean
    required: false
    default: false

steps:
  # ==================== SEMANTIC SEARCH ====================

  - name: search_daemon_code
    description: "Search for code related to Slack daemon"
    tool: code_search
    args:
      query: "Slack daemon control D-Bus IPC {{ inputs.action }}"
      project: "automation-analytics-backend"
      limit: 3
    output: daemon_code_raw
    on_error: continue

  - name: parse_daemon_code
    description: "Parse daemon code search results"
    condition: "daemon_code_raw"
    compute: |
      code_result = daemon_code_raw if daemon_code_raw else {}

      related_code = []
      if isinstance(code_result, dict) and code_result.get('found'):
          for item in code_result.get('content', []):
              related_code.append(item.get('path', '') + ":" + str(item.get('line_number', '')))

      result = {
          "has_code": len(related_code) > 0,
          "code_snippets": related_code[:5],
      }
    output: daemon_code_search
    on_error: continue

  - name: validate_action
    description: "Validate the action and required parameters"
    compute: |
      valid_actions = ["start", "stop", "status", "pending", "approve", "approve_all", "reject", "history", "send", "reload"]
      action = inputs.get("action", "").lower()

      if action not in valid_actions:
        raise ValueError(f"Invalid action: {action}. Valid actions: {', '.join(valid_actions)}")

      # Validate required params for specific actions
      if action == "approve" and not inputs.get("message_id"):
        raise ValueError("approve action requires message_id parameter")

      if action == "reject" and not inputs.get("message_id"):
        raise ValueError("reject action requires message_id parameter")

      if action == "send":
        # Support both 'target' and 'channel' for backwards compatibility
        target = inputs.get("target") or inputs.get("channel")
        if not target:
          raise ValueError("send action requires target parameter (channel C123, user U123, or @username)")
        if not inputs.get("message"):
          raise ValueError("send action requires message parameter")

      result = {"action": action, "valid": True}
    output: validation

  - name: run_action
    description: "Execute the daemon control action"
    compute: |
      import subprocess
      import sys
      import os
      import json
      from pathlib import Path

      action = inputs["action"].lower()
      project_root = Path(os.getenv("PROJECT_ROOT", os.getcwd()))
      control_script = project_root / "scripts" / "slack_control.py"
      daemon_script = project_root / "scripts" / "slack_daemon.py"

      # Build command based on action
      if action == "start":
        # Use nohup to start in background
        log_file = Path("/tmp/slack-daemon.log")
        pid_file = Path("/tmp/slack-daemon.pid")

        # Check if already running
        if pid_file.exists():
          try:
            pid = int(pid_file.read_text().strip())
            os.kill(pid, 0)  # Check if process exists
            result = {"success": False, "error": f"Daemon already running (PID: {pid})"}
            raise SystemExit  # Skip to output
          except (OSError, ValueError):
            pid_file.unlink(missing_ok=True)

        cmd = [
          "nohup",
          sys.executable,
          str(daemon_script),
          "--dbus",
        ]
        if inputs.get("enable_llm"):
          cmd.append("--llm")
        if inputs.get("verbose"):
          cmd.append("--verbose")

        with open(log_file, "w") as log:
          process = subprocess.Popen(
            cmd,
            stdout=log,
            stderr=log,
            start_new_session=True,
          )

        pid_file.write_text(str(process.pid))

        import time
        time.sleep(2)

        try:
          os.kill(process.pid, 0)
          result = {
            "success": True,
            "pid": process.pid,
            "log_file": str(log_file),
            "message": f"Daemon started (PID: {process.pid})"
          }
        except OSError:
          result = {"success": False, "error": "Daemon failed to start. Check logs."}

      elif action == "stop":
        cmd = [sys.executable, str(control_script), "stop"]
        proc = subprocess.run(cmd, capture_output=True, text=True)
        result = {"success": proc.returncode == 0, "output": proc.stdout}

      elif action == "status":
        cmd = [sys.executable, str(control_script), "status"]
        proc = subprocess.run(cmd, capture_output=True, text=True)
        result = {"success": proc.returncode == 0, "output": proc.stdout}

      elif action == "pending":
        cmd = [sys.executable, str(control_script), "pending", "-v"]
        proc = subprocess.run(cmd, capture_output=True, text=True)
        result = {"success": proc.returncode == 0, "output": proc.stdout}

      elif action == "approve":
        msg_id = inputs["message_id"]
        cmd = [sys.executable, str(control_script), "approve", msg_id]
        proc = subprocess.run(cmd, capture_output=True, text=True)
        result = {"success": proc.returncode == 0, "output": proc.stdout}

      elif action == "approve_all":
        cmd = [sys.executable, str(control_script), "approve-all"]
        proc = subprocess.run(cmd, capture_output=True, text=True)
        result = {"success": proc.returncode == 0, "output": proc.stdout}

      elif action == "reject":
        msg_id = inputs["message_id"]
        cmd = [sys.executable, str(control_script), "reject", msg_id]
        proc = subprocess.run(cmd, capture_output=True, text=True)
        result = {"success": proc.returncode == 0, "output": proc.stdout}

      elif action == "history":
        cmd = [sys.executable, str(control_script), "history", "-n", str(inputs.get("limit", 50))]
        if inputs.get("filter_channel"):
          cmd.extend(["-c", inputs["filter_channel"]])
        if inputs.get("filter_user"):
          cmd.extend(["-u", inputs["filter_user"]])
        if inputs.get("filter_status"):
          cmd.extend(["-s", inputs["filter_status"]])
        cmd.append("-v")
        proc = subprocess.run(cmd, capture_output=True, text=True)
        result = {"success": proc.returncode == 0, "output": proc.stdout}

      elif action == "send":
        # Support both 'target' and 'channel' for backwards compatibility
        target = inputs.get("target") or inputs.get("channel")
        message = inputs["message"]
        cmd = [sys.executable, str(control_script), "send", target, message]
        if inputs.get("thread"):
          cmd.extend(["-t", inputs["thread"]])
        proc = subprocess.run(cmd, capture_output=True, text=True)
        result = {"success": proc.returncode == 0, "output": proc.stdout}

      elif action == "reload":
        cmd = [sys.executable, str(control_script), "reload"]
        proc = subprocess.run(cmd, capture_output=True, text=True)
        result = {"success": proc.returncode == 0, "output": proc.stdout}

      else:
        result = {"success": False, "error": f"Unknown action: {action}"}
    output: action_result

  # ==================== MEMORY INTEGRATION ====================

  - name: log_daemon_action
    description: "Log daemon action to session"
    tool: memory_session_log
    args:
      action: "Slack daemon {{ inputs.action }}"
      details: "Success: {{ action_result.success }}, {{ action_result.output[:100] if action_result.output else '' }}"
    on_error: continue

  - name: track_daemon_state
    description: "Track daemon state in memory"
    condition: "inputs.action in ['start', 'stop', 'status']"
    compute: |
      from datetime import datetime

      # Update daemon state
      state = memory.read_memory("state/slack_daemon") or {}

      if inputs.action == "start" and action_result.success:
          state["status"] = "running"
          state["pid"] = action_result.get("pid")
          state["started_at"] = datetime.now().isoformat()
      elif inputs.action == "stop" and action_result.success:
          state["status"] = "stopped"
          state["stopped_at"] = datetime.now().isoformat()
      elif inputs.action == "status":
          state["last_checked"] = datetime.now().isoformat()

      memory.write_memory("state/slack_daemon", state)
      result = "daemon state tracked"
    output: daemon_state_result
    on_error: continue

outputs:
  - name: success
    description: Whether the action succeeded
    value: "{{ action_result.success }}"

  - name: output
    description: Command output
    value: "{{ action_result.output }}"

  - name: error
    description: Error message if failed
    value: "{{ action_result.error }}"

  - name: pid
    description: Daemon PID (for start action)
    value: "{{ action_result.pid }}"
