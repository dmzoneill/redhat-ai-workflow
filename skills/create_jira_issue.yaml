# Skill: Create Jira Issue
# Create new Jira issues with linking and assignment
# Enhanced with semantic code search for context-rich issues

name: create_jira_issue
description: |
  Create a new Jira issue with proper linking and assignment.

  **Enhanced with Semantic Search:**
  - Searches codebase for related code based on issue summary
  - Adds relevant file references to issue description
  - Identifies potential areas of impact
  - Suggests related components/modules

  Use for:
  - Creating bug reports (with relevant code context)
  - Creating feature requests (with implementation hints)
  - Creating sub-tasks
  - Linking related issues

  The skill will:
  1. Search codebase for related code (semantic search)
  2. Create the issue with enriched description
  3. Assign to specified user (or self)
  4. Link to related issues
  5. Transition to appropriate status

version: "1.1"

inputs:
  - name: summary
    type: string
    required: true
    description: "Issue summary/title"

  - name: description
    type: string
    required: false
    default: ""
    description: "Issue description (markdown supported)"

  - name: issue_type
    type: string
    required: false
    default: "Task"
    description: "Issue type: 'Bug', 'Task', 'Story', 'Sub-task'"

  - name: project
    type: string
    required: false
    default: "AAP"
    description: "Jira project key"

  - name: repo
    type: string
    required: false
    default: "automation-analytics-backend"
    description: "Repository to search for related code"

  - name: search_code
    type: boolean
    required: false
    default: true
    description: "Search codebase for related code (semantic search)"

  - name: assignee
    type: string
    required: false
    description: "Assign to user (leave empty for self)"

  - name: labels
    type: string
    required: false
    description: "Comma-separated labels"

  - name: priority
    type: string
    required: false
    default: "Medium"
    description: "Priority: 'Highest', 'High', 'Medium', 'Low', 'Lowest'"

  - name: link_to
    type: string
    required: false
    description: "Issue key to link to (e.g., AAP-12345)"

  - name: link_type
    type: string
    required: false
    default: "relates to"
    description: "Link type: 'relates to', 'blocks', 'is blocked by', 'duplicates'"

  - name: start_progress
    type: boolean
    required: false
    default: false
    description: "Immediately transition to In Progress"

  - name: slack_format
    type: boolean
    required: false
    default: false
    description: "Use Slack link format in report"

steps:

  - name: init_autoheal
    description: "Initialize failure tracking"
    compute: |
      result = {"jira_failures": []}
    output: autoheal_state
    on_error: continue

  # ==================== KNOWLEDGE INTEGRATION ====================

  - name: check_jira_known_issues
    description: "Check for known Jira issues"
    compute: |
      # Check known issues for Jira operations
      jira_issues = memory.check_known_issues("jira", "") or {}
      issue_issues = memory.check_known_issues("issue_create", "") or {}

      all_issues = []
      for issues in [jira_issues, issue_issues]:
          if issues and issues.get("matches"):
              all_issues.extend(issues.get("matches", [])[:2])

      result = {
          "has_known_issues": len(all_issues) > 0,
          "issues": all_issues[:5],
      }
    output: jira_known_issues
    on_error: continue

  - name: get_jira_best_practices
    description: "Get Jira best practices from knowledge"
    tool: knowledge_query
    args:
      project: "automation-analytics-backend"
      persona: "developer"
      section: "patterns"
    output: jira_practices_raw
    on_error: continue

  - name: parse_jira_practices
    description: "Parse Jira best practices"
    compute: |
      practices_result = jira_practices_raw if 'jira_practices_raw' in dir() and jira_practices_raw else {}

      jira_practices = []
      if isinstance(practices_result, dict) and practices_result.get('found'):
          content = practices_result.get('content', {})
          if isinstance(content, dict):
              # Get coding patterns that might relate to Jira
              coding = content.get('coding', [])
              if isinstance(coding, list):
                  for p in coding:
                      p_str = str(p).lower()
                      if any(kw in p_str for kw in ['jira', 'issue', 'ticket', 'story', 'bug', 'task']):
                          jira_practices.append(p)

      result = {
          'practices': jira_practices[:5],
          'has_practices': len(jira_practices) > 0,
      }
    output: jira_best_practices
    on_error: continue

  # ==================== SEMANTIC CODE SEARCH ====================

  - name: search_related_code
    description: "Search codebase for code related to the issue"
    condition: "inputs.search_code"
    tool: code_search
    args:
      query: "{{ inputs.summary }}"
      project: "{{ inputs.repo }}"
      limit: 5
    output: code_search_raw
    on_error: continue

  - name: parse_code_search
    description: "Parse semantic search results"
    condition: "inputs.search_code"
    compute: |
      import re

      search_result = code_search_raw if 'code_search_raw' in dir() and code_search_raw else ""
      search_text = str(search_result) if search_result else ""

      related_files = []
      code_snippets = []
      modules_affected = set()

      # Parse the markdown output from code_search
      # Format: ### 1. `file_path` (lines X-Y)
      file_pattern = r'###\s*\d+\.\s*`([^`]+)`\s*\(lines\s*(\d+)-(\d+)\)'
      type_pattern = r'\*\*Type:\*\*\s*(\w+)\s*\|\s*\*\*Name:\*\*\s*(\w+)\s*\|\s*\*\*Relevance:\*\*\s*(\d+)%'

      matches = re.findall(file_pattern, search_text)
      type_matches = re.findall(type_pattern, search_text)

      for i, (file_path, start_line, end_line) in enumerate(matches[:5]):
          # Extract module/component from path
          parts = file_path.split('/')
          if len(parts) > 1:
              module = parts[0] if parts[0] not in ['src', 'app', 'lib'] else (parts[1] if len(parts) > 1 else parts[0])
              modules_affected.add(module)

          file_info = {
              'path': file_path,
              'start_line': int(start_line),
              'end_line': int(end_line),
              'type': type_matches[i][0] if i < len(type_matches) else 'unknown',
              'name': type_matches[i][1] if i < len(type_matches) else 'unknown',
              'relevance': int(type_matches[i][2]) if i < len(type_matches) else 0,
          }
          related_files.append(file_info)

      # Extract code snippets (first 3 high-relevance ones)
      code_blocks = re.findall(r'```\w+\n(.*?)```', search_text, re.DOTALL)
      for i, block in enumerate(code_blocks[:3]):
          if len(block.strip()) > 20:  # Skip tiny snippets
              code_snippets.append({
                  'code': block.strip()[:500],  # Limit size
                  'file': related_files[i]['path'] if i < len(related_files) else 'unknown',
              })

      result = {
          'found': len(related_files) > 0,
          'files': related_files,
          'modules': list(modules_affected),
          'snippets': code_snippets,
          'file_count': len(related_files),
          'high_relevance_count': sum(1 for f in related_files if f.get('relevance', 0) >= 60),
      }
    output: code_context
    on_error: continue

  - name: build_enhanced_description
    description: "Build enhanced description with code context"
    compute: |
      original_desc = inputs.get('description', '') or ''
      code_ctx = code_context if 'code_context' in dir() and code_context else {}

      enhanced_desc = original_desc

      # Add code context section if we found related code
      if code_ctx.get('found') and code_ctx.get('files'):
          if enhanced_desc:
              enhanced_desc += "\n\n"

          enhanced_desc += "---\n\n"
          enhanced_desc += "h3. üîç Related Code (auto-discovered)\n\n"

          # List affected modules
          if code_ctx.get('modules'):
              enhanced_desc += "*Potentially affected modules:* " + ", ".join(code_ctx['modules'][:5]) + "\n\n"

          # List relevant files
          enhanced_desc += "*Relevant files:*\n"
          for f in code_ctx.get('files', [])[:5]:
              relevance_indicator = "üü¢" if f.get('relevance', 0) >= 70 else "üü°" if f.get('relevance', 0) >= 40 else "‚ö™"
              enhanced_desc += f"* {relevance_indicator} {{{{code}}}}{f['path']}{{{{code}}}} (lines {f['start_line']}-{f['end_line']}) - {f.get('type', 'code')}: {f.get('name', 'unknown')}\n"

          # Add note about semantic search
          enhanced_desc += "\n_Code references discovered via semantic search based on issue summary._\n"

      result = {
          'description': enhanced_desc,
          'was_enhanced': code_ctx.get('found', False),
          'files_added': code_ctx.get('file_count', 0),
      }
    output: enhanced_description
    on_error: continue

  # ==================== CREATE ISSUE ====================

  - name: create_issue
    description: "Create the Jira issue with enhanced description"
    tool: jira_create_issue
    args:
      project: "{{ inputs.project }}"
      summary: "{{ inputs.summary }}"
      description: "{{ enhanced_description.description if enhanced_description and enhanced_description.description else (inputs.description or '') }}"
      issue_type: "{{ inputs.issue_type }}"
      priority: "{{ inputs.priority }}"
      labels: "{{ inputs.labels or '' }}"
    output: create_result
    on_error: continue

  - name: parse_create_result
    description: "Parse issue creation result"
    compute: |
      result_text = str(create_result) if create_result else ""

      # Extract issue key
      import re
      issue_key = None
      key_match = re.search(r'([A-Z]+-\d+)', result_text)
      if key_match:
          issue_key = key_match.group(1)

      success = issue_key is not None or ("created" in result_text.lower() and "error" not in result_text.lower())

      result = {
          "success": success,
          "issue_key": issue_key,
          "message": result_text[:300] if result_text else "No response",
      }
    output: create_status

  # ==================== ASSIGN ISSUE ====================

  - name: assign_issue
    description: "Assign the issue"
    condition: "create_status.issue_key"
    tool: jira_assign
    args:
      issue_key: "{{ create_status.issue_key }}"
      assignee: "{{ inputs.assignee or 'currentUser' }}"
    output: assign_result
    on_error: auto_heal  # Jira API - may need auth refresh

  # ==================== LINK ISSUES ====================

  - name: link_issues
    description: "Link to related issue"
    condition: "create_status.issue_key and inputs.link_to"
    tool: jira_link_issues
    args:
      inward_issue: "{{ create_status.issue_key }}"
      outward_issue: "{{ inputs.link_to }}"
      link_type: "{{ inputs.link_type }}"
    output: link_result
    on_error: continue

  - name: parse_link
    description: "Parse link result"
    condition: "link_result"
    compute: |
      link_text = str(link_result) if link_result else ""

      success = "error" not in link_text.lower()

      result = {
          "success": success,
          "message": link_text[:200] if link_text else "Unknown",
      }
    output: link_status
    on_error: continue

  # ==================== UPDATE ISSUE (add more fields) ====================

  - name: update_issue
    description: "Update issue with additional fields"
    condition: "create_status.issue_key and inputs.labels"
    tool: jira_update_issue
    args:
      issue_key: "{{ create_status.issue_key }}"
      fields: "labels"
      values: "{{ inputs.labels }}"
    output: update_result
    on_error: continue

  # ==================== TRANSITION ====================

  - name: transition_to_progress
    description: "Transition to In Progress"
    condition: "create_status.issue_key and inputs.start_progress"
    tool: jira_transition
    args:
      issue_key: "{{ create_status.issue_key }}"
      transition: "Start Progress"
    output: transition_result
    on_error: auto_heal  # Jira API - may need auth refresh

  # ==================== GET FINAL STATE ====================

  - name: get_issue
    description: "Get the created issue details"
    condition: "create_status.issue_key"
    tool: jira_view_issue
    args:
      issue_key: "{{ create_status.issue_key }}"
    output: issue_details
    on_error: auto_heal  # Jira API - may need auth refresh

  # ==================== MEMORY ====================

  - name: log_creation
    description: "Log issue creation"
    condition: "create_status.success"
    tool: memory_session_log
    args:
      action: "Created Jira issue {{ create_status.issue_key }}"
      details: "{{ inputs.summary[:50] }}{% if inputs.link_to %}, linked to {{ inputs.link_to }}{% endif %}"
    on_error: continue

  - name: track_issue_creations
    description: "Track issue creations for patterns"
    condition: "create_status and create_status.success"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "issue_creations" not in patterns:
          patterns["issue_creations"] = []

      # Record this creation
      creation_record = {
          "issue_key": create_status.issue_key if create_status else None,
          "project": inputs.project,
          "issue_type": inputs.issue_type,
          "priority": inputs.priority,
          "linked_to": inputs.link_to if inputs.link_to else None,
          "code_context_added": enhanced_description.was_enhanced if enhanced_description else False,
          "files_referenced": enhanced_description.files_added if enhanced_description else 0,
          "timestamp": datetime.now().isoformat(),
      }

      patterns["issue_creations"].append(creation_record)

      # Keep last 100 creations
      patterns["issue_creations"] = patterns["issue_creations"][-100:]

      memory.write_memory("learned/patterns", patterns)
      result = "creation tracked"
    output: creation_tracking_result
    on_error: continue

  - name: add_to_active_issues
    description: "Add created issue to active issues"
    condition: "create_status and create_status.success"
    tool: memory_append
    args:
      key: "state/current_work"
      list_path: "active_issues"
      item: |
        key: {{ create_status.issue_key }}
        status: {{ "In Progress" if inputs.start_progress else "New" }}
        type: {{ inputs.issue_type }}
        summary: {{ inputs.summary[:60] }}
        created: {{ now().isoformat() }}
    on_error: continue

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_create_failures
    description: "Detect failure patterns from issue creation"
    compute: |
      errors_detected = []

      # Check Jira API failures
      create_text = str(create_result) if 'create_result' in dir() and create_result else ""

      if "unauthorized" in create_text.lower() or "401" in create_text:
          errors_detected.append({
              "tool": "jira_create_issue",
              "pattern": "unauthorized",
              "cause": "Jira authentication failed or token expired",
              "fix": "Check Jira credentials in config.json"
          })
      if "project" in create_text.lower() and "not found" in create_text.lower():
          errors_detected.append({
              "tool": "jira_create_issue",
              "pattern": "project not found",
              "cause": "Jira project key is incorrect",
              "fix": "Verify project key (e.g., AAP, RHCLOUD)"
          })
      if "issue type" in create_text.lower() and "not found" in create_text.lower():
          errors_detected.append({
              "tool": "jira_create_issue",
              "pattern": "issue type not found",
              "cause": "Issue type doesn't exist in this project",
              "fix": "Use valid types: Story, Bug, Task, Epic"
          })

      result = errors_detected
    output: create_errors_detected
    on_error: continue

  - name: learn_jira_create_auth_failure
    description: "Learn from Jira auth failures"
    condition: "create_errors_detected and any(e.get('pattern') == 'unauthorized' for e in create_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "jira_create_issue"
      error_pattern: "unauthorized"
      root_cause: "Jira authentication failed or token expired"
      fix_description: "Check Jira credentials in config.json"
    output: create_auth_fix_learned
    on_error: continue

  - name: learn_jira_project_failure
    description: "Learn from project not found failures"
    condition: "create_errors_detected and any(e.get('pattern') == 'project not found' for e in create_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "jira_create_issue"
      error_pattern: "project not found"
      root_cause: "Jira project key is incorrect"
      fix_description: "Verify project key (e.g., AAP, RHCLOUD)"
    output: project_fix_learned
    on_error: continue

outputs:
  - name: report
    value: |
      {% set is_slack = inputs.slack_format | default(true) %}
      ## üé´ Create Jira Issue

      {% if create_status.success %}
      ### ‚úÖ Issue Created

      {% if is_slack %}
      **Key:** <https://issues.redhat.com/browse/{{ create_status.issue_key }}|{{ create_status.issue_key }}>
      {% else %}
      **Key:** [{{ create_status.issue_key }}](https://issues.redhat.com/browse/{{ create_status.issue_key }})
      {% endif %}
      **Summary:** {{ inputs.summary }}
      **Type:** {{ inputs.issue_type }}
      **Priority:** {{ inputs.priority }}

      {% if assign_result %}
      **Assigned to:** {{ inputs.assignee or "you" }}
      {% endif %}

      {% if link_status and link_status.success %}
      {% if is_slack %}
      **Linked to:** <https://issues.redhat.com/browse/{{ inputs.link_to }}|{{ inputs.link_to }}> ({{ inputs.link_type }})
      {% else %}
      **Linked to:** [{{ inputs.link_to }}](https://issues.redhat.com/browse/{{ inputs.link_to }}) ({{ inputs.link_type }})
      {% endif %}
      {% elif inputs.link_to and not link_status.success %}
      ‚ö†Ô∏è Link to {{ inputs.link_to }} failed: {{ link_status.message }}
      {% endif %}

      {% if inputs.start_progress %}
      **Status:** In Progress
      {% endif %}

      ---

      ### Next Steps

      **View issue:**
      ```python
      jira_view_issue(issue_key='{{ create_status.issue_key }}')
      ```

      **Start working:**
      ```python
      skill_run("start_work", '{"issue_key": "{{ create_status.issue_key }}"}')
      ```

      **Add comment:**
      ```python
      jira_add_comment(issue_key='{{ create_status.issue_key }}', comment='...')
      ```

      {% else %}
      ### ‚ùå Creation Failed

      {{ create_status.message }}

      Check:
      - Project key is valid ({{ inputs.project }})
      - Issue type exists ({{ inputs.issue_type }})
      - You have permission to create issues

      {% endif %}

      {% if jira_best_practices and jira_best_practices.has_practices %}
      ---

      ### üìã Jira Best Practices

      {% for practice in jira_best_practices.practices[:3] %}
      - {{ practice }}
      {% endfor %}
      {% endif %}

      {% if jira_known_issues and jira_known_issues.has_known_issues %}
      ---

      ### üí° Known Issues

      {% for issue in jira_known_issues.issues[:3] %}
      - {{ issue.pattern if issue.pattern else issue }}
      {% endfor %}
      {% endif %}

      {% if code_context and code_context.found %}
      ---

      ### üîç Code Context (Semantic Search)

      {% if enhanced_description and enhanced_description.was_enhanced %}
      ‚úÖ Issue description enhanced with {{ code_context.file_count }} related file(s)
      {% endif %}

      **Potentially affected modules:** {{ code_context.modules | join(', ') if code_context.modules else 'None identified' }}

      **Related files found:**
      {% for f in code_context.files[:5] %}
      - {% if f.relevance >= 70 %}üü¢{% elif f.relevance >= 40 %}üü°{% else %}‚ö™{% endif %} `{{ f.path }}` ({{ f.relevance }}% match) - {{ f.type }}: {{ f.name }}
      {% endfor %}

      {% if code_context.high_relevance_count > 0 %}
      üìä {{ code_context.high_relevance_count }} high-relevance match(es) found
      {% endif %}
      {% elif inputs.search_code %}
      ---

      ### üîç Code Context

      ‚ö†Ô∏è No related code found via semantic search. The codebase may not be indexed.

      To index: `code_index("{{ inputs.repo }}")`
      {% endif %}

  - name: context
    value:
      issue_key: "{{ create_status.issue_key }}"
      created: "{{ create_status.success }}"
      linked: "{{ link_status.success if link_status else false }}"
      link_to: "{{ inputs.link_to }}"
