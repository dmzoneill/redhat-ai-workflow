# Skill: Notify Team About MR
# Posts a review request to the team Slack channel for an existing MR

name: notify_mr
description: |
  Notify the team Slack channel about an existing MR that's ready for review.

  Use this when:
  - You created a draft MR and it's now ready
  - You want to remind the team about a pending review
  - You marked an MR as ready after initial work

  Uses MCP tools: gitlab_mr_view, jira_view_issue, slack_post_team

version: "1.0"

inputs:
  - name: mr_id
    type: string
    required: false
    description: "GitLab MR IID (e.g., 1459). If not provided, will try to find from current branch."

  - name: project
    type: string
    required: false
    default: ""
    description: "GitLab project path (e.g., 'automation-analytics/automation-analytics-backend')"

  - name: issue_key
    type: string
    required: false
    default: ""
    description: "Jira issue key for additional context"

  - name: message
    type: string
    required: false
    default: ""
    description: "Custom message to include (optional)"

  - name: reminder
    type: boolean
    required: false
    default: false
    description: "If true, formats as a reminder rather than new MR notification"

  - name: slack_format
    type: boolean
    required: false
    default: false
    description: "Use Slack link format in summary"

steps:

  - name: init_autoheal
    description: "Initialize failure tracking"
    compute: |
      result = {"failures": []}
    output: autoheal_state
    on_error: continue

  # ==================== KNOWLEDGE INTEGRATION ====================

  - name: get_notification_patterns
    description: "Get notification patterns from knowledge base"
    tool: knowledge_query
    args:
      project: "automation-analytics-backend"
      persona: "developer"
      query: "gotchas"
    output: notification_knowledge_raw
    on_error: continue

  - name: parse_notification_knowledge
    description: "Parse notification knowledge for context"
    compute: |
      knowledge_text = str(notification_knowledge_raw) if notification_knowledge_raw else ""

      gotchas = []
      patterns = []

      # Extract gotchas related to notifications
      if knowledge_text:
          for line in knowledge_text.split("\n"):
              line_lower = line.lower()
              if any(kw in line_lower for kw in ["slack", "notify", "channel", "mention", "review"]):
                  gotchas.append(line.strip()[:150])
              if any(kw in line_lower for kw in ["pattern", "format", "template", "message"]):
                  patterns.append(line.strip()[:150])

      result = {
          "has_knowledge": len(gotchas) > 0,
          "gotchas": gotchas[:5],
          "patterns": patterns[:3],
      }
    output: notification_knowledge
    on_error: continue

  - name: check_notification_known_issues
    description: "Check for known Slack/notification issues"
    compute: |
      # Check known issues for notification operations
      slack_issues = memory.check_known_issues("slack", "") or {}
      notification_issues = memory.check_known_issues("notification", "") or {}
      gitlab_issues = memory.check_known_issues("gitlab", "") or {}

      all_issues = []
      for issues in [slack_issues, notification_issues, gitlab_issues]:
          if issues and issues.get("matches"):
              all_issues.extend(issues.get("matches", [])[:2])

      result = {
          "has_known_issues": len(all_issues) > 0,
          "issues": all_issues[:5],
      }
    output: notification_known_issues
    on_error: continue

  # ==================== SETUP ====================

  - name: setup
    description: "Load configuration and resolve inputs"
    compute: |
      from scripts.common.config_loader import load_config
      import subprocess
      import os

      config = load_config()

      jira_url = config.get("jira", {}).get("url", "https://issues.redhat.com")
      gitlab_url = config.get("gitlab", {}).get("url", "https://gitlab.cee.redhat.com")

      # Get team group info for @mentions
      team_channel = config.get("slack", {}).get("channels", {}).get("team", {})
      team_group_id = team_channel.get("group_id", "")
      team_group_handle = team_channel.get("group_handle", "aa-api-team")

      # Resolve project - use input or find default from config
      project = inputs.get("project", "")
      if not project:
          repos = config.get("repositories", {})
          for name, cfg in repos.items():
              if cfg.get("gitlab"):
                  project = cfg.get("gitlab")
                  break

      # Resolve MR ID - use input or try to find from branch
      mr_id = inputs.get("mr_id", "")
      if not mr_id:
          # Try to get from current branch
          try:
              result_branch = subprocess.run(
                  ["git", "branch", "--show-current"],
                  capture_output=True, text=True, cwd=os.getcwd()
              )
              if result_branch.returncode == 0:
                  branch = result_branch.stdout.strip()
                  # Would need to call gitlab_mr_list here, but for now require mr_id
                  pass
          except Exception:
              pass

      if not mr_id:
          raise ValueError("mr_id is required. Please provide the MR IID.")

      result = {
          "jira_url": jira_url,
          "gitlab_url": gitlab_url,
          "project": project,
          "mr_id": str(mr_id),
          "issue_key": inputs.get("issue_key", "").upper() if inputs.get("issue_key") else "",
          "custom_message": inputs.get("message", ""),
          "is_reminder": inputs.get("reminder", False),
          "team_group_id": team_group_id,
          "team_group_handle": team_group_handle,
      }
    output: ctx

  # ==================== FETCH MR DETAILS ====================

  - name: get_mr_details
    description: "Get MR details from GitLab"
    tool: gitlab_mr_view
    args:
      project: "{{ ctx.project }}"
      mr_id: "{{ ctx.mr_id }}"
    output: mr_result
    on_error: auto_heal  # GitLab API - may need auth refresh

  - name: parse_mr_result
    description: "Parse MR details from glab output"
    compute: |
      mr_text = str(mr_result) if mr_result else ""

      # Parse the glab output
      title = ""
      web_url = ""

      for line in mr_text.split("\n"):
          if line.startswith("title:"):
              title = line.replace("title:", "").strip()
          elif line.startswith("url:"):
              web_url = line.replace("url:", "").strip()

      # If no URL found, construct it
      if not web_url:
          web_url = f"{ctx.get('gitlab_url')}/{ctx.get('project')}/-/merge_requests/{ctx.get('mr_id')}"

      # Extract issue key from title if not provided
      issue_key = ctx.get("issue_key", "")
      if not issue_key:
          import re
          match = re.search(r"(AAP-\d+|ANSTRAT-\d+|AA-\d+)", title, re.IGNORECASE)
          if match:
              issue_key = match.group(1).upper()

      result = {
          "title": title or "Merge Request",
          "web_url": web_url,
          "issue_key": issue_key,
      }
    output: mr

  # ==================== FETCH JIRA DETAILS ====================

  - name: get_jira_details
    description: "Get Jira issue details for context"
    condition: "mr.get('issue_key')"
    tool: jira_view_issue
    args:
      issue_key: "{{ mr.issue_key }}"
    output: jira_result
    on_error: auto_heal  # Jira API - may need auth refresh

  - name: parse_jira_result
    description: "Parse Jira issue summary"
    compute: |
      jira_text = str(jira_result) if jira_result else ""
      summary = ""

      # Look for summary line
      for line in jira_text.split("\n"):
          if line.startswith("summary"):
              parts = line.split(":", 1)
              if len(parts) > 1:
                  summary = parts[1].strip()[:80]
                  break

      result = {"summary": summary}
    output: jira

  # ==================== POST NOTIFICATION ====================

  - name: build_and_post
    description: "Build Slack message and post to team channel"
    compute: |
      import subprocess
      import os

      jira_url = ctx.get("jira_url", "https://issues.redhat.com")
      issue_key = mr.get("issue_key", "")
      jira_summary = jira.get("summary", "") if jira else ""
      mr_id = ctx.get("mr_id", "")
      mr_title = mr.get("title", "Merge Request")
      mr_web_url = mr.get("web_url", "")
      custom_message = ctx.get("custom_message", "")
      is_reminder = ctx.get("is_reminder", False)

      # Build team mention using group ID from config
      team_group_id = ctx.get("team_group_id", "")
      team_group_handle = ctx.get("team_group_handle", "aa-api-team")
      team_mention = slack_utils.build_team_mention(team_group_id, team_group_handle)

      # Build message
      lines = [team_mention]

      if is_reminder:
          lines.append("‚è∞ *Reminder - Please review:*")
      else:
          lines.append("üîÄ *Please review:*")

      lines.append("")

      # Jira issue as hyperlink (if available)
      if issue_key:
          jira_text = f"{issue_key}: {jira_summary}" if jira_summary else issue_key
          lines.append(f"‚Ä¢ <{jira_url}/browse/{issue_key}|{jira_text}>")

      # MR as hyperlink (ID and title)
      mr_link_text = f"!{mr_id}: {mr_title[:80]}"
      lines.append(f"‚Ä¢ <{mr_web_url}|{mr_link_text}>")

      # Custom message if provided
      if custom_message:
          lines.append("")
          lines.append(custom_message)

      slack_message = "\n".join(lines)

      # For now, store the message - actual posting needs the slack module loaded
      result = {
          "message": slack_message,
          "issue_key": issue_key,
          "mr_id": mr_id,
          "mr_url": mr_web_url,
      }
    output: notification

  - name: post_to_team
    description: "Post notification to team channel"
    tool: slack_post_team
    args:
      text: "{{ notification.message }}"
    output: slack_result
    on_error: auto_heal  # Slack API - may need auth refresh

  # ==================== SEMANTIC SEARCH ====================

  - name: search_mr_code
    description: "Search for code related to the MR being notified"
    condition: "notification and notification.mr_id"
    tool: code_search
    args:
      query: "GitLab MR !{{ notification.mr_id }} {{ mr.title or '' }}"
      project: "automation-analytics-backend"
      limit: 3
    output: mr_code_raw
    on_error: continue

  - name: parse_mr_code
    description: "Parse MR code search results"
    condition: "mr_code_raw"
    compute: |
      code_result = mr_code_raw if mr_code_raw else {}

      related_code = []
      if isinstance(code_result, dict) and code_result.get('found'):
          for item in code_result.get('content', []):
              related_code.append(item.get('path', '') + ":" + str(item.get('line_number', '')))

      result = {
          "has_code": len(related_code) > 0,
          "code_snippets": related_code[:5],
      }
    output: mr_code_search
    on_error: continue

  # ==================== MEMORY INTEGRATION ====================

  - name: log_notification
    description: "Log notification to session"
    tool: memory_session_log
    args:
      action: "Notified team about MR !{{ notification.mr_id }}"
      details: "{{ 'Reminder' if inputs.reminder else 'New notification' }}, Jira: {{ notification.issue_key }}"
    on_error: continue

  - name: track_mr_notifications
    description: "Track MR notifications for patterns"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "mr_notifications" not in patterns:
          patterns["mr_notifications"] = []

      # Record this notification
      notification_record = {
          "mr_id": notification.mr_id if notification else "unknown",
          "project": ctx.project if ctx else "unknown",
          "issue_key": notification.issue_key if notification else None,
          "is_reminder": inputs.reminder,
          "slack_posted": bool(slack_result) if 'slack_result' in dir() else False,
          "timestamp": datetime.now().isoformat(),
      }

      patterns["mr_notifications"].append(notification_record)

      # Keep last 100 notifications
      patterns["mr_notifications"] = patterns["mr_notifications"][-100:]

      memory.write_memory("learned/patterns", patterns)
      result = "notification tracked"
    output: notification_tracking_result
    on_error: continue

  - name: track_reminder_frequency
    description: "Track MRs that need frequent reminders"
    condition: "inputs.reminder"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "mr_reminder_frequency" not in patterns:
          patterns["mr_reminder_frequency"] = {}

      mr_key = f"{ctx.project}!{notification.mr_id}" if ctx and notification else "unknown"

      if mr_key not in patterns["mr_reminder_frequency"]:
          patterns["mr_reminder_frequency"][mr_key] = {
              "count": 0,
              "first_reminder": datetime.now().isoformat(),
              "last_reminder": datetime.now().isoformat(),
          }

      patterns["mr_reminder_frequency"][mr_key]["count"] += 1
      patterns["mr_reminder_frequency"][mr_key]["last_reminder"] = datetime.now().isoformat()

      memory.write_memory("learned/patterns", patterns)
      result = "reminder frequency tracked"
    output: reminder_tracking_result
    on_error: continue

outputs:
  - name: summary
    value: |
      {% set is_slack = inputs.slack_format | default(true) %}
      ## {{ "‚úÖ Team Notified" if slack_result else "üìã Message Ready" }}

      {% if is_slack %}
      **MR:** <{{ notification.mr_url }}|!{{ notification.mr_id }}>
      {% else %}
      **MR:** [!{{ notification.mr_id }}]({{ notification.mr_url }})
      {% endif %}
      **URL:** {{ notification.mr_url }}
      {% if notification.issue_key %}
      {% if is_slack %}
      **Jira:** <{{ ctx.jira_url }}/browse/{{ notification.issue_key }}|{{ notification.issue_key }}>
      {% else %}
      **Jira:** [{{ notification.issue_key }}]({{ ctx.jira_url }}/browse/{{ notification.issue_key }})
      {% endif %}
      {% endif %}

      {% if slack_result %}
      üì¢ Review request posted to team channel
      {% else %}
      ‚ö†Ô∏è Message built but Slack posting requires slack module to be loaded
      {% endif %}

      {% if notification_known_issues and notification_known_issues.has_known_issues %}
      ---

      ### üí° Known Issues

      {% for issue in notification_known_issues.issues[:3] %}
      - {{ issue.pattern if issue.pattern else issue }}
      {% endfor %}
      {% endif %}

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_notify_failures
    description: "Detect failure patterns from MR notification"
    compute: |
      errors_detected = []

      # Check GitLab failures
      mr_text = str(mr_details_raw) if 'mr_details_raw' in dir() and mr_details_raw else ""
      if "no such host" in mr_text.lower():
          errors_detected.append({
              "tool": "gitlab_mr_view",
              "pattern": "no such host",
              "cause": "VPN not connected - internal GitLab not reachable",
              "fix": "Run vpn_connect() to connect to Red Hat VPN"
          })
      if "not found" in mr_text.lower() and "merge request" in mr_text.lower():
          errors_detected.append({
              "tool": "gitlab_mr_view",
              "pattern": "merge request not found",
              "cause": "MR ID doesn't exist or wrong project",
              "fix": "Check MR ID and project path"
          })

      # Check Slack failures
      slack_text = str(slack_result_raw) if 'slack_result_raw' in dir() and slack_result_raw else ""
      if "not_in_channel" in slack_text.lower() or "channel_not_found" in slack_text.lower():
          errors_detected.append({
              "tool": "slack_post_team",
              "pattern": "not_in_channel",
              "cause": "Bot not added to Slack channel",
              "fix": "Invite the bot to the team channel"
          })
      if "invalid_auth" in slack_text.lower():
          errors_detected.append({
              "tool": "slack_post_team",
              "pattern": "invalid_auth",
              "cause": "Slack token expired or invalid",
              "fix": "Check Slack token in config.json"
          })

      result = errors_detected
    output: notify_errors_detected
    on_error: continue

  - name: learn_notify_vpn_failure
    description: "Learn from VPN failures"
    condition: "notify_errors_detected and any(e.get('pattern') == 'no such host' for e in notify_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "gitlab_mr_view"
      error_pattern: "no such host"
      root_cause: "VPN not connected - internal GitLab not reachable"
      fix_description: "Run vpn_connect() to connect to Red Hat VPN"
    output: notify_vpn_fix_learned
    on_error: continue

  - name: learn_notify_slack_failure
    description: "Learn from Slack channel failures"
    condition: "notify_errors_detected and any(e.get('pattern') == 'not_in_channel' for e in notify_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "slack_post_team"
      error_pattern: "not_in_channel"
      root_cause: "Bot not added to Slack channel"
      fix_description: "Invite the bot to the team channel"
    output: notify_slack_fix_learned
    on_error: continue

  - name: message
    value: "{{ notification.message }}"

  - name: context
    value:
      mr_id: "{{ notification.mr_id }}"
      issue_key: "{{ notification.issue_key }}"
      posted: "{{ 'true' if slack_result else 'false' }}"
