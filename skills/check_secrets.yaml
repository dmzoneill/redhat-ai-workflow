# Skill: Check Secrets
# Verify secrets and configmaps are properly configured

name: check_secrets
description: |
  Check secrets and configmaps in a namespace.

  Useful for:
  - Verifying deployment configuration
  - Debugging missing env vars
  - Auditing secret presence

  Uses: kubectl_get_secrets, kubectl_get_configmaps, kubectl_describe_deployment
version: "1.0"

inputs:
  - name: namespace
    type: string
    required: true
    description: "Kubernetes namespace"

  - name: environment
    type: string
    required: false
    default: "stage"
    description: "Environment (stage, production, ephemeral)"

  - name: deployment
    type: string
    required: false
    default: ""
    description: "Optional: specific deployment to check references"

steps:
  # ==================== KNOWLEDGE INTEGRATION ====================

  - name: check_secrets_known_issues
    description: "Check for known secrets/k8s issues"
    compute: |
      # Check known issues for secrets operations
      secrets_issues = memory.check_known_issues("secret", "") or {}
      k8s_issues = memory.check_known_issues("kubectl", "") or {}
      configmap_issues = memory.check_known_issues("configmap", "") or {}

      all_issues = []
      for issues in [secrets_issues, k8s_issues, configmap_issues]:
          if issues and issues.get("matches"):
              all_issues.extend(issues.get("matches", [])[:2])

      result = {
          "has_known_issues": len(all_issues) > 0,
          "issues": all_issues[:5],
      }
    output: secrets_known_issues
    on_error: continue

  - name: get_security_gotchas
    description: "Get security-related gotchas from knowledge"
    tool: knowledge_query
    args:
      project: "automation-analytics-backend"
      persona: "devops"
      section: "gotchas"
    output: security_gotchas_raw
    on_error: continue

  - name: parse_security_gotchas
    description: "Parse security-related gotchas"
    compute: |
      gotchas_result = security_gotchas_raw if 'security_gotchas_raw' in dir() and security_gotchas_raw else {}

      security_gotchas = []
      if isinstance(gotchas_result, dict) and gotchas_result.get('found'):
          content = gotchas_result.get('content', [])
          if isinstance(content, list):
              # Filter for security-related gotchas
              for g in content:
                  g_str = str(g).lower()
                  if any(kw in g_str for kw in ['secret', 'configmap', 'env', 'credential', 'auth', 'token']):
                      security_gotchas.append(g)

      result = {
          'gotchas': security_gotchas[:5],
          'has_gotchas': len(security_gotchas) > 0,
      }
    output: secrets_check_gotchas
    on_error: continue

  # ==================== GET SECRETS ====================

  - name: get_secrets
    description: "List secrets in namespace"
    tool: kubectl_get_secrets
    args:
      namespace: "{{ inputs.namespace }}"
      environment: "{{ inputs.environment }}"
    output: secrets_raw
    on_error: auto_heal  # K8s cluster - may need kube_login

  - name: parse_secrets
    description: "Parse secrets list"
    compute: |
      secrets_text = str(secrets_raw) if 'secrets_raw' in dir() and secrets_raw else ""

      secrets = []
      for line in secrets_text.split("\n"):
        parts = line.split()
        if len(parts) >= 2 and parts[0] != "NAME":
          secrets.append({
            "name": parts[0],
            "type": parts[1] if len(parts) > 1 else "unknown",
          })

      result = {
        "secrets": secrets,
        "count": len(secrets),
      }
    output: secrets_info

  - name: get_configmaps
    description: "List configmaps in namespace"
    tool: kubectl_get_configmaps
    args:
      namespace: "{{ inputs.namespace }}"
      environment: "{{ inputs.environment }}"
    output: configmaps_raw
    on_error: auto_heal  # K8s cluster - may need kube_login

  - name: parse_configmaps
    description: "Parse configmaps list"
    compute: |
      cm_text = str(configmaps_raw) if 'configmaps_raw' in dir() and configmaps_raw else ""

      configmaps = []
      for line in cm_text.split("\n"):
        parts = line.split()
        if len(parts) >= 1 and parts[0] != "NAME":
          configmaps.append(parts[0])

      result = {
        "configmaps": configmaps,
        "count": len(configmaps),
      }
    output: configmaps_info

  - name: describe_deployment
    description: "Get deployment to check secret/configmap references"
    condition: "inputs.deployment"
    tool: kubectl_describe_deployment
    args:
      deployment: "{{ inputs.deployment }}"
      namespace: "{{ inputs.namespace }}"
      environment: "{{ inputs.environment }}"
    output: deploy_desc_raw
    on_error: auto_heal  # K8s cluster - may need kube_login

  # ==================== SEMANTIC SEARCH ====================

  - name: search_secret_usage
    description: "Search for secret usage in code if missing secrets found"
    condition: "ref_check and ref_check.missing_secrets"
    tool: code_search
    args:
      query: "secret environment variable {{ ref_check.missing_secrets[0] if ref_check.missing_secrets else '' }}"
      project: "automation-analytics-backend"
      limit: 5
    output: secret_code_raw
    on_error: continue

  - name: parse_secret_code
    description: "Parse secret code search results"
    condition: "secret_code_raw"
    compute: |
      code_result = secret_code_raw if secret_code_raw else {}

      related_code = []
      if isinstance(code_result, dict) and code_result.get('results'):
          for r in code_result.get('results', [])[:5]:
              related_code.append({
                  'file': r.get('file_path', ''),
                  'score': r.get('score', 0),
                  'preview': r.get('code_chunk', '')[:100] if r.get('code_chunk') else '',
              })

      result = {
          'code': related_code,
          'count': len(related_code),
          'has_related_code': len(related_code) > 0,
      }
    output: secret_code_analysis
    on_error: continue

  - name: check_references
    description: "Check if deployment references existing secrets/configmaps"
    condition: "inputs.deployment and deploy_desc_raw"
    compute: |
      deploy_text = str(deploy_desc_raw) if 'deploy_desc_raw' in dir() else ""

      import re

      # Find secretKeyRef and configMapKeyRef
      secret_refs = re.findall(r'secretKeyRef:\s*\n\s*name:\s*(\S+)', deploy_text)
      cm_refs = re.findall(r'configMapKeyRef:\s*\n\s*name:\s*(\S+)', deploy_text)

      # Also find secretRef and configMapRef
      secret_refs += re.findall(r'secretRef:\s*\n\s*name:\s*(\S+)', deploy_text)
      cm_refs += re.findall(r'configMapRef:\s*\n\s*name:\s*(\S+)', deploy_text)

      # Check if referenced secrets/configmaps exist
      existing_secrets = [s["name"] for s in secrets_info.get("secrets", [])]
      existing_cms = configmaps_info.get("configmaps", [])

      missing_secrets = [s for s in set(secret_refs) if s not in existing_secrets]
      missing_cms = [c for c in set(cm_refs) if c not in existing_cms]

      result = {
        "secret_refs": list(set(secret_refs)),
        "configmap_refs": list(set(cm_refs)),
        "missing_secrets": missing_secrets,
        "missing_configmaps": missing_cms,
        "all_present": len(missing_secrets) == 0 and len(missing_cms) == 0,
      }
    output: ref_check

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_secrets_failures
    description: "Detect failure patterns from secrets check"
    compute: |
      errors_detected = []

      # Check kubectl failures
      secrets_text = str(secrets_raw) if 'secrets_raw' in dir() and secrets_raw else ""
      configmaps_text = str(configmaps_raw) if 'configmaps_raw' in dir() and configmaps_raw else ""
      combined = secrets_text + configmaps_text

      if "unauthorized" in combined.lower() or "forbidden" in combined.lower():
          errors_detected.append({
              "tool": "kubectl_get_secrets",
              "pattern": "unauthorized",
              "cause": "Kubernetes auth expired",
              "fix": "Run kube_login(cluster='stage' or 'prod') to refresh credentials"
          })
      if "no route to host" in combined.lower():
          errors_detected.append({
              "tool": "kubectl_get_secrets",
              "pattern": "no route to host",
              "cause": "VPN not connected - cannot reach cluster",
              "fix": "Run vpn_connect() to connect to Red Hat VPN"
          })

      result = errors_detected
    output: secrets_errors_detected
    on_error: continue

  - name: learn_secrets_auth_failure
    description: "Learn from k8s auth failures"
    condition: "secrets_errors_detected and any(e.get('pattern') == 'unauthorized' for e in secrets_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "kubectl_get_secrets"
      error_pattern: "unauthorized"
      root_cause: "Kubernetes auth expired"
      fix_description: "Run kube_login(cluster='stage' or 'prod') to refresh credentials"
    output: secrets_auth_fix_learned
    on_error: continue

  - name: log_session
    description: "Log skill execution to session"
    tool: memory_session_log
    args:
      action: "Checked secrets and configmaps"
      details: "namespace={{ inputs.namespace }}, environment={{ inputs.environment }}, secrets={{ secrets_info.count if secrets_info is defined else 'unknown' }}"
    on_error: continue

  - name: track_secrets_checks
    description: "Track secrets checks for patterns"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "secrets_checks" not in patterns:
          patterns["secrets_checks"] = []

      # Record this check
      check_record = {
          "namespace": inputs.namespace,
          "environment": inputs.environment,
          "secrets_count": secrets_info.count if secrets_info else 0,
          "configmaps_count": configmaps_info.count if configmaps_info else 0,
          "deployment": inputs.deployment if inputs.deployment else None,
          "all_present": ref_check.all_present if ref_check else True,
          "missing_secrets": len(ref_check.missing_secrets) if ref_check else 0,
          "timestamp": datetime.now().isoformat(),
      }

      patterns["secrets_checks"].append(check_record)

      # Keep last 100 checks
      patterns["secrets_checks"] = patterns["secrets_checks"][-100:]

      memory.write_memory("learned/patterns", patterns)
      result = "secrets check tracked"
    output: secrets_tracking_result
    on_error: continue

  - name: update_namespace_state
    description: "Update namespace secrets state"
    compute: |
      from datetime import datetime

      # Update namespace state
      state = memory.read_memory("state/namespaces") or {}
      if "namespaces" not in state:
          state["namespaces"] = {}

      ns_key = f"{inputs.environment}/{inputs.namespace}"
      state["namespaces"][ns_key] = {
          "last_secrets_check": datetime.now().isoformat(),
          "secrets_count": secrets_info.count if secrets_info else 0,
          "configmaps_count": configmaps_info.count if configmaps_info else 0,
      }

      memory.write_memory("state/namespaces", state)
      result = "namespace state updated"
    output: namespace_state_result
    on_error: continue

outputs:
  - name: report
    value: |
      ## üîê Secrets & ConfigMaps: {{ inputs.namespace }}

      **Environment:** {{ inputs.environment }}

      ---

      ### Secrets ({{ secrets_info.count }})

      {% for secret in secrets_info.secrets[:15] %}
      - `{{ secret.name }}` ({{ secret.type }})
      {% endfor %}
      {% if secrets_info.count > 15 %}
      ... and {{ secrets_info.count - 15 }} more
      {% endif %}

      ---

      ### ConfigMaps ({{ configmaps_info.count }})

      {% for cm in configmaps_info.configmaps[:15] %}
      - `{{ cm }}`
      {% endfor %}
      {% if configmaps_info.count > 15 %}
      ... and {{ configmaps_info.count - 15 }} more
      {% endif %}

      {% if inputs.deployment %}
      ---

      ### Deployment References: {{ inputs.deployment }}

      **Secrets referenced:** {{ ref_check.secret_refs | length }}
      {% for s in ref_check.secret_refs %}
      - `{{ s }}`
      {% endfor %}

      **ConfigMaps referenced:** {{ ref_check.configmap_refs | length }}
      {% for c in ref_check.configmap_refs %}
      - `{{ c }}`
      {% endfor %}

      {% if ref_check.all_present %}
      ‚úÖ All referenced secrets and configmaps exist
      {% else %}
      ‚ö†Ô∏è **Missing resources:**
      {% for s in ref_check.missing_secrets %}
      - Secret: `{{ s }}` ‚ùå
      {% endfor %}
      {% for c in ref_check.missing_configmaps %}
      - ConfigMap: `{{ c }}` ‚ùå
      {% endfor %}
      {% endif %}
      {% endif %}

      {% if secrets_check_gotchas and secrets_check_gotchas.has_gotchas %}
      ---

      ### ‚ö†Ô∏è Security Gotchas

      {% for gotcha in secrets_check_gotchas.gotchas[:3] %}
      - {{ gotcha }}
      {% endfor %}
      {% endif %}

      {% if secrets_known_issues and secrets_known_issues.has_known_issues %}
      ---

      ### üí° Known Issues

      {% for issue in secrets_known_issues.issues[:3] %}
      - {{ issue.pattern if issue.pattern else issue }}
      {% endfor %}
      {% endif %}
