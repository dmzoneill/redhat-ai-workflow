# Skill: Review All Open PRs
# Batch review of open MRs with intelligent follow-up

name: review_all_prs
description: |
  Review all open MRs in a project.
  
  Resolves project from repo_name or current directory if not explicitly provided.
  
  Automatically excludes your own MRs (detected from system username).
  
  For each MR (authored by others):
  - If I gave feedback and author addressed it ‚Üí approve
  - If I gave feedback and author didn't respond ‚Üí skip
  - If I gave feedback and author responded but issues remain ‚Üí more feedback
  - If no previous review from me ‚Üí run full review
  
  Also shows your own MRs that have feedback from others.
  
version: "1.2"

inputs:
  - name: project
    type: string
    required: false
    default: ""
    description: "GitLab project path (resolved from repo_name if not provided)"
  
  - name: repo_name
    type: string
    required: false
    description: "Repository name from config (e.g., 'automation-analytics-backend')"
  
  - name: reviewer
    type: string
    required: false
    default: ""
    description: "Filter by reviewer username (leave empty for all open MRs)"
  
  - name: limit
    type: integer
    required: false
    default: 10
    description: "Maximum number of MRs to process"
  
  - name: dry_run
    type: boolean
    required: false
    default: false
    description: "If true, show what would happen without taking action"
  
  - name: include_my_mrs
    type: boolean
    required: false
    default: true
    description: "Show my own MRs that have feedback to respond to"
  
  - name: auto_rebase
    type: boolean
    required: false
    default: true
    description: "Automatically rebase my MRs that have merge conflicts"

# No hardcoded constants - resolved dynamically

steps:
  # ==================== RESOLVE PROJECT ====================
  
  - name: resolve_project
    description: "Determine which GitLab project to check"
    compute: |
      import json
      import os
      from pathlib import Path

      gitlab_project = None

      # Load config
      config_paths = [
          Path.cwd() / "config.json",
          Path.home() / "src/redhat-ai-workflow/config.json",
      ]
      config = {}
      for p in config_paths:
          if p.exists():
              with open(p) as f:
                  config = json.load(f)
              break

      repos = config.get("repositories", {})

      # Explicit project
      if inputs.project:
          gitlab_project = inputs.project
      # Repo name from config
      elif inputs.repo_name and inputs.repo_name in repos:
          gitlab_project = repos[inputs.repo_name].get("gitlab")
      # Fall back to cwd
      else:
          cwd = os.getcwd()
          for name, cfg in repos.items():
              if cfg.get("path") == cwd:
                  gitlab_project = cfg.get("gitlab")
                  break

      if not gitlab_project:
          gitlab_project = "automation-analytics/automation-analytics-backend"

      result = {"gitlab_project": gitlab_project}
    output: resolved
  # ==================== GET CURRENT USER ====================
  
  # Step 0: Get current system username
  - name: get_username
    description: "Get current system username to exclude own MRs"
    compute: |
      import getpass
      import os
      
      # Get username from config or fallback to system
      from pathlib import Path
      import json
      
      config_paths = [Path.cwd() / "config.json", Path.home() / "src/redhat-ai-workflow/config.json"]
      cfg = {}
      for p in config_paths:
        if p.exists():
          with open(p) as f:
            cfg = json.load(f)
          break
      
      # Use config if available, otherwise fallback to system user
      gitlab_username = cfg.get("user", {}).get("gitlab_username") or \
                        cfg.get("user", {}).get("username") or \
                        os.getenv('USER') or getpass.getuser()
      
      result = gitlab_username
    output: my_username

  # ==================== GATHER MRs ====================

  # Step 1: Get list of open MRs
  - name: list_open_mrs
    description: "Fetch all open MRs from GitLab"
    tool: gitlab_mr_list
    args:
      project: "{{ resolved.gitlab_project }}"
      state: opened
      per_page: "{{ inputs.limit }}"
    output: open_mrs

  # Step 2: Parse MR list and separate own vs others
  - name: parse_mrs
    description: "Extract MR IDs, separate own MRs from others to review"
    compute: |
      import re
      
      mrs_to_review = []  # MRs by others that I should review
      my_mrs = []         # My own MRs (to check for feedback)
      
      # Parse the MR list output - format varies but usually contains IID, title, author
      lines = open_mrs.split('\n') if open_mrs else []
      
      current_mr = {}
      for line in lines:
        # Look for MR ID patterns like "!123" or "IID: 123"
        iid_match = re.search(r'!(\d+)|IID[:\s]+(\d+)|mr_id[:\s]+(\d+)', line, re.IGNORECASE)
        if iid_match:
          if current_mr.get('iid'):
            # Determine if this is my MR or someone else's
            author = current_mr.get('author', '').lower()
            if my_username.lower() in author:
              my_mrs.append(current_mr)
            else:
              mrs_to_review.append(current_mr)
          current_mr = {'iid': int(iid_match.group(1) or iid_match.group(2) or iid_match.group(3))}
        
        # Extract title
        title_match = re.search(r'Title[:\s]+(.+)|^\s*(.+)\s*$', line)
        if title_match and current_mr.get('iid') and not current_mr.get('title'):
          current_mr['title'] = (title_match.group(1) or title_match.group(2) or '').strip()[:60]
        
        # Extract author
        author_match = re.search(r'Author[:\s]+(\w+)|@(\w+)', line)
        if author_match and current_mr.get('iid'):
          current_mr['author'] = author_match.group(1) or author_match.group(2)
      
      # Don't forget the last one
      if current_mr.get('iid'):
        author = current_mr.get('author', '').lower()
        if my_username.lower() in author:
          my_mrs.append(current_mr)
        else:
          mrs_to_review.append(current_mr)
      
      # Deduplicate by IID
      seen = set()
      unique_to_review = []
      for mr in mrs_to_review:
        if mr['iid'] not in seen:
          seen.add(mr['iid'])
          unique_to_review.append(mr)
      
      unique_my_mrs = []
      for mr in my_mrs:
        if mr['iid'] not in seen:
          seen.add(mr['iid'])
          unique_my_mrs.append(mr)
      
      result = {
        'to_review': unique_to_review[:inputs.limit],
        'my_mrs': unique_my_mrs,
        'my_username': my_username
      }
    output: parsed_mrs

  # ==================== CHECK MY MRs FOR MERGE CONFLICTS ====================

  # Step 2b: Get detailed status of first of my MRs to check for conflicts
  - name: check_my_mr_status
    description: "Check if any of my MRs have merge conflicts"
    condition: "parsed_mrs.get('my_mrs') and len(parsed_mrs['my_mrs']) > 0 and inputs.include_my_mrs"
    tool: gitlab_mr_view
    args:
      project: "{{ resolved.gitlab_project }}"
      mr_id: "{{ parsed_mrs['my_mrs'][0]['iid'] }}"
    output: my_first_mr_details
    on_error: continue

  # Step 2c: Detect if my MR has merge conflicts
  - name: detect_merge_conflicts
    description: "Check for merge conflicts or needs rebase"
    condition: "my_first_mr_details"
    compute: |
      import re
      
      details = my_first_mr_details or ""
      mr = parsed_mrs['my_mrs'][0] if parsed_mrs.get('my_mrs') else {}
      
      # Detect various merge conflict indicators
      has_conflicts = False
      needs_rebase = False
      reason = None
      
      # GitLab indicators
      conflict_patterns = [
        r'cannot be merged',
        r'has conflicts',
        r'merge conflicts',
        r'conflict',
        r'needs rebase',
        r'pipeline.*failed.*conflict',
        r'cannot.*rebase',
        r'unable to merge',
      ]
      
      for pattern in conflict_patterns:
        if re.search(pattern, details, re.IGNORECASE):
          has_conflicts = True
          reason = f"Detected: {pattern}"
          break
      
      # Check for merge commits (indicator that rebase is needed)
      if re.search(r'merge branch|merge.*into|merge commit', details, re.IGNORECASE):
        needs_rebase = True
        if not has_conflicts:
          reason = "Has merge commits - should rebase"
      
      result = {
        'has_conflicts': has_conflicts,
        'needs_rebase': needs_rebase or has_conflicts,
        'mr_id': mr.get('iid'),
        'title': mr.get('title', ''),
        'reason': reason
      }
    output: my_mr_conflict_status

  # Step 2d: Auto-rebase my MR if it has conflicts
  - name: auto_rebase_my_mr
    description: "Automatically rebase my MR if it has conflicts"
    condition: "my_mr_conflict_status and my_mr_conflict_status.get('needs_rebase') and inputs.auto_rebase and not inputs.dry_run"
    tool: skill_run
    args:
      skill_name: rebase_pr
      inputs: '{"mr_id": {{ my_mr_conflict_status.get("mr_id", 0) }}, "force_push": false}'
    output: rebase_result
    on_error: continue

  # Step 3: Process each MR (excluding my own)
  - name: process_mrs
    description: "Analyze each MR for review status"
    compute: |
      import re
      
      results = []
      mrs_to_review = parsed_mrs.get('to_review', [])
      
      for mr in mrs_to_review:
        mr_id = mr.get('iid')
        if not mr_id:
          continue
        
        mr_result = {
          'iid': mr_id,
          'title': mr.get('title', ''),
          'author': mr.get('author', 'unknown'),
          'action': 'pending',
          'reason': '',
          'my_last_feedback': None,
          'author_replied': False,
          'concerns_addressed': False
        }
        
        results.append(mr_result)
      
      result = results
    output: mr_analysis

  # Step 4: For each MR, get comments and determine status
  # Note: This is a simplified version - in practice you'd call gitlab_mr_comments for each
  - name: analyze_review_status
    description: "Determine review status for each MR"
    compute: |
      # This would ideally call gitlab_mr_comments for each MR
      # For now, we'll set up the structure and the actual tool calls happen below
      
      result = {
        'needs_review': [],
        'can_approve': [],
        'needs_followup': [],
        'skip': []
      }
    output: review_status

# ==================== INDIVIDUAL MR PROCESSING ====================

  # Step 5: Get comments for first pending MR
  # Note: This is a simplified approach - a full implementation would loop
  - name: get_mr_comments
    description: "Get comments for MRs to check review status"
    condition: "len(mr_analysis) > 0"
    tool: gitlab_mr_view
    args:
      project: "{{ resolved.gitlab_project }}"
      mr_id: "{{ mr_analysis[0]['iid'] }}"
    output: first_mr_details
    on_error: continue

  # Step 6: Analyze first MR's review status
  - name: analyze_first_mr
    description: "Check if first MR needs action"
    condition: "len(mr_analysis) > 0 and first_mr_details"
    compute: |
      import re
      
      mr = mr_analysis[0]
      details = first_mr_details or ""
      
      # Get username for pattern matching
      username = my_username  # From earlier step
      
      # Look for my previous comments/feedback
      my_comments = re.findall(rf'({username}|Dave O\'Neill).*?commented|reviewed by.*?({username})', details, re.IGNORECASE)
      my_feedback_exists = len(my_comments) > 0
      
      # Look for author's replies after my feedback
      author = mr.get('author', '')
      author_replied = author and re.search(rf'{author}.*?commented|replied', details, re.IGNORECASE)
      
      # Look for approval status
      already_approved = re.search(rf'approved by.*?{username}|LGTM|Looks good', details, re.IGNORECASE)
      
      # Check for unresolved discussions
      unresolved = re.search(r'unresolved.*?discussion|open thread', details, re.IGNORECASE)
      
      # Determine action
      if already_approved:
        action = "skip"
        reason = "Already approved"
      elif not my_feedback_exists:
        action = "needs_full_review"
        reason = "No previous review from me"
      elif my_feedback_exists and not author_replied:
        action = "skip"
        reason = "Waiting for author response"
      elif my_feedback_exists and author_replied and unresolved:
        action = "needs_followup"
        reason = "Author replied but unresolved issues"
      elif my_feedback_exists and author_replied and not unresolved:
        action = "can_approve"
        reason = "Author addressed feedback"
      else:
        action = "needs_full_review"
        reason = "Unclear status"
      
      mr['action'] = action
      mr['reason'] = reason
      
      result = mr
    output: first_mr_action

  # Step 7: Run full review if needed
  - name: run_full_review
    description: "Run full review for MR that needs it"
    condition: "first_mr_action and first_mr_action.get('action') == 'needs_full_review' and not inputs.dry_run"
    tool: skill_run
    args:
      skill_name: review_pr
      inputs: '{"mr_id": {{ first_mr_action.get("iid", 0) }}, "skip_tests": true}'
    output: full_review_result
    on_error: continue

  # Step 8: Approve MR if author addressed feedback
  - name: auto_approve
    description: "Approve MR where author addressed feedback"
    condition: "first_mr_action and first_mr_action.get('action') == 'can_approve' and not inputs.dry_run"
    tool: gitlab_mr_approve
    args:
      project: "{{ resolved.gitlab_project }}"
      mr_id: "{{ first_mr_action.get('iid') }}"
    output: approve_result
    on_error: continue

  # Step 9: Post follow-up if needed
  - name: post_followup
    description: "Post follow-up comment for unresolved issues"
    condition: "first_mr_action and first_mr_action.get('action') == 'needs_followup' and not inputs.dry_run"
    tool: gitlab_mr_comment
    args:
      project: "{{ resolved.gitlab_project }}"
      mr_id: "{{ first_mr_action.get('iid') }}"
      comment: |
        ## Follow-up Review
        
        I see you've responded to my feedback. However, there appear to be unresolved discussions.
        
        Could you please address the outstanding items so we can move forward?
        
        ---
        *Automated follow-up by AI Workflow*
    output: followup_result
    on_error: continue

  # Step 10: Build summary
  - name: build_summary
    description: "Compile batch review results"
    compute: |
      my_username = parsed_mrs.get('my_username', 'unknown')
      my_mrs = parsed_mrs.get('my_mrs', [])
      mrs_to_review = parsed_mrs.get('to_review', [])
      
      lines = ["## Batch PR Review Summary", ""]
      lines.append(f"**Project:** {resolved['gitlab_project']}")
      lines.append(f"**Current User:** {my_username}")
      lines.append(f"**MRs to Review (by others):** {len(mrs_to_review)}")
      lines.append(f"**My Open MRs:** {len(my_mrs)}")
      lines.append(f"**Dry Run:** {'Yes' if inputs.dry_run else 'No'}")
      lines.append("")
      
      # Categorize actions
      actions = {
        'can_approve': [],
        'needs_full_review': [],
        'needs_followup': [],
        'skip': []
      }
      
      if first_mr_action:
        action = first_mr_action.get('action', 'skip')
        actions.get(action, actions['skip']).append(first_mr_action)
      
      # Summary by category
      if actions['can_approve']:
        lines.append("### ‚úÖ Approved")
        for mr in actions['can_approve']:
          status = "Would approve" if inputs.dry_run else "Approved"
          lines.append(f"- !{mr['iid']}: {mr.get('title', '')} ({status})")
        lines.append("")
      
      if actions['needs_full_review']:
        lines.append("### üîç Full Review Performed")
        for mr in actions['needs_full_review']:
          lines.append(f"- !{mr['iid']}: {mr.get('title', '')}")
        lines.append("")
      
      if actions['needs_followup']:
        lines.append("### üí¨ Follow-up Posted")
        for mr in actions['needs_followup']:
          status = "Would post follow-up" if inputs.dry_run else "Follow-up posted"
          lines.append(f"- !{mr['iid']}: {mr.get('title', '')} ({status})")
        lines.append("")
      
      if actions['skip']:
        lines.append("### ‚è≠Ô∏è Skipped (Waiting for Author)")
        for mr in actions['skip']:
          lines.append(f"- !{mr['iid']}: {mr.get('title', '')} - {mr.get('reason', 'No action needed')}")
        lines.append("")
      
      # Show my own MRs that might need attention
      if my_mrs and inputs.include_my_mrs:
        lines.append("---")
        lines.append("")
        lines.append("### üìù Your Open MRs")
        
        # Check if we rebased any MR
        if my_mr_conflict_status and my_mr_conflict_status.get('needs_rebase'):
          first_mr_id = my_mr_conflict_status.get('mr_id')
          reason = my_mr_conflict_status.get('reason', 'needs rebase')
          
          if rebase_result:
            lines.append(f"- !{first_mr_id}: {my_mr_conflict_status.get('title', '')} üîÑ **Rebased!**")
            lines.append(f"  - {reason}")
            lines.append(f"  - *See rebase results below*")
          elif inputs.auto_rebase and not inputs.dry_run:
            lines.append(f"- !{first_mr_id}: {my_mr_conflict_status.get('title', '')} ‚ö†Ô∏è **Rebase attempted**")
          elif inputs.dry_run:
            lines.append(f"- !{first_mr_id}: {my_mr_conflict_status.get('title', '')} üîÑ **Would rebase** (dry run)")
            lines.append(f"  - {reason}")
          else:
            lines.append(f"- !{first_mr_id}: {my_mr_conflict_status.get('title', '')} ‚ö†Ô∏è **Needs rebase**")
            lines.append(f"  - {reason}")
            lines.append(f"  - Run: `skill_run(\"rebase_pr\", '{{\"mr_id\": {first_mr_id}}}')`")
        
        # Show remaining MRs
        for mr in my_mrs[:5]:
          if my_mr_conflict_status and mr.get('iid') == my_mr_conflict_status.get('mr_id'):
            continue  # Already shown above
          lines.append(f"- !{mr.get('iid', '?')}: {mr.get('title', '')}")
        
        lines.append("")
        lines.append("*Check these for feedback from reviewers. Use:*")
        lines.append(f"*`gitlab_mr_view(project=\"{resolved['gitlab_project']}\", mr_id=<id>)` to see comments*")
        lines.append("")
      
      # Remaining MRs
      remaining = len(mr_analysis) - 1
      if remaining > 0:
        lines.append(f"---")
        lines.append(f"*{remaining} more MRs not processed in this batch.*")
        lines.append(f"*Run again to continue processing.*")
      
      result = '\n'.join(lines)
    output: batch_summary

  # Step 11: Emit batch review hook
  - name: emit_batch_review_hook
    description: "Notify team channel about batch review"
    condition: "not inputs.dry_run"
    compute: |
      import asyncio
      import sys
      from pathlib import Path
      sys.path.insert(0, str(Path.home() / "src/redhat-ai-workflow"))
      
      try:
          from scripts.skill_hooks import emit_event
          
          # Count actions taken
          approved = 1 if first_mr_action and first_mr_action.get('action') == 'can_approve' else 0
          changes = 1 if first_mr_action and first_mr_action.get('action') in ['needs_full_review', 'needs_followup'] else 0
          total = len(mr_analysis) if mr_analysis else 0
          
          if total > 0:
              asyncio.run(emit_event("batch_review_completed", {
                  "count": str(total),
                  "approved": str(approved),
                  "changes": str(changes),
                  "project": resolved.get("gitlab_project", ""),
              }))
              result = "hook sent"
          else:
              result = "no MRs to report"
      except Exception as e:
          result = f"hook skipped: {e}"
    output: batch_hook_result
    on_error: continue

# ==================== OUTPUT ====================

outputs:
  - name: summary
    value: |
      {{ batch_summary }}
      
      ---
      
      ## Quick Actions
      
      - **Review next batch:** `skill_run("review_all_prs", '{}')`
      - **Review specific MR:** `skill_run("review_pr", '{"mr_id": 123}')`
      - **Approve specific MR:** `gitlab_mr_approve(project="...", mr_id=123)`
  
  - name: stats
    value:
      total_mrs: "{{ len(mr_analysis) }}"
      processed: 1
      dry_run: "{{ inputs.dry_run }}"

